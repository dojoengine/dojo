import elliptic, { ec as ec$1 } from 'elliptic';
import * as BN from 'bn.js';
import BN__default from 'bn.js';
import { CustomError } from 'ts-custom-error';

declare type BigNumberish = string | number | BN__default;
declare function isHex(hex: string): boolean;
declare function toBN(number: BigNumberish, base?: number | 'hex'): BN__default;
declare function toHex(number: BN__default): string;
declare function hexToDecimalString(hex: string): string;
declare function toFelt(num: BigNumberish): string;
/**
 * Remove hex string leading zero and lower case '0x01A'.. -> '0x1a..'
 * @param hex string
 */
declare const cleanHex: (hex: string) => string;
declare function assertInRange(input: BigNumberish, lowerBound: BigNumberish, upperBound: BigNumberish, inputName?: string): void;
declare function bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[];
declare function bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[];
declare const isStringWholeNumber: (value: string) => boolean;
declare const toHexString: (value: string) => string;
declare function getDecimalString(value: string): string;
declare function getHexString(value: string): string;
declare function getHexStringArray(value: Array<string>): string[];
declare const toCairoBool: (value: boolean) => string;

type number_BigNumberish = BigNumberish;
declare const number_isHex: typeof isHex;
declare const number_toBN: typeof toBN;
declare const number_toHex: typeof toHex;
declare const number_hexToDecimalString: typeof hexToDecimalString;
declare const number_toFelt: typeof toFelt;
declare const number_cleanHex: typeof cleanHex;
declare const number_assertInRange: typeof assertInRange;
declare const number_bigNumberishArrayToDecimalStringArray: typeof bigNumberishArrayToDecimalStringArray;
declare const number_bigNumberishArrayToHexadecimalStringArray: typeof bigNumberishArrayToHexadecimalStringArray;
declare const number_isStringWholeNumber: typeof isStringWholeNumber;
declare const number_toHexString: typeof toHexString;
declare const number_getDecimalString: typeof getDecimalString;
declare const number_getHexString: typeof getHexString;
declare const number_getHexStringArray: typeof getHexStringArray;
declare const number_toCairoBool: typeof toCairoBool;
declare namespace number {
  export {
    number_BigNumberish as BigNumberish,
    number_isHex as isHex,
    number_toBN as toBN,
    number_toHex as toHex,
    number_hexToDecimalString as hexToDecimalString,
    number_toFelt as toFelt,
    number_cleanHex as cleanHex,
    number_assertInRange as assertInRange,
    number_bigNumberishArrayToDecimalStringArray as bigNumberishArrayToDecimalStringArray,
    number_bigNumberishArrayToHexadecimalStringArray as bigNumberishArrayToHexadecimalStringArray,
    number_isStringWholeNumber as isStringWholeNumber,
    number_toHexString as toHexString,
    number_getDecimalString as getDecimalString,
    number_getHexString as getHexString,
    number_getHexStringArray as getHexStringArray,
    number_toCairoBool as toCairoBool,
  };
}

/**
 * Starknet RPC version 0.2.0
 *
 * Starknet Node API 0.45.0 - rpc 0.2.1
 * Starknet Node Write API 0.3.0 - rpc 0.2.1
 * Starknet Trace API 0.4.0 - rpc 0.2.1
 *
 * TypeScript Representation of OpenRpc protocol types
 */
declare type FELT = string;
declare type ADDRESS = FELT;
declare type NUM_AS_HEX = string;
declare type SIGNATURE = Array<FELT>;
declare type BLOCK_NUMBER = number;
declare type BLOCK_HASH = FELT;
declare type TXN_HASH = FELT;
declare type TXN_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
declare type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';
declare type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
declare enum BLOCK_TAG {
    'latest' = 0,
    'pending' = 1
}
declare type BLOCK_ID = {
    block_hash: BLOCK_HASH;
} | {
    block_number: BLOCK_NUMBER;
} | BLOCK_TAG;
declare type MSG_TO_L1 = {
    to_address: FELT;
    payload: Array<FELT>;
};
declare type EVENT = {
    from_address: FELT;
    keys: Array<FELT>;
    data: Array<FELT>;
};
declare type COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH;
    actual_fee: FELT;
    status: TXN_STATUS;
    block_hash?: BLOCK_HASH;
    block_number?: BLOCK_NUMBER;
    type: TXN_TYPE;
    messages_sent: Array<MSG_TO_L1>;
    events: Array<EVENT>;
};
declare type PENDING_COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH;
    actual_fee: FELT;
    type?: TXN_TYPE;
    messages_sent: Array<MSG_TO_L1>;
    events: Array<EVENT>;
};
declare type INVOKE_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type DECLARE_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type DEPLOY_TXN_RECEIPT = {
    contract_address: FELT;
} & COMMON_RECEIPT_PROPERTIES;
declare type L1_HANDLER_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type PENDING_DEPLOY_TXN_RECEIPT = {
    contract_address: FELT;
} & PENDING_COMMON_RECEIPT_PROPERTIES;
declare type PENDING_TXN_RECEIPT = PENDING_DEPLOY_TXN_RECEIPT | PENDING_COMMON_RECEIPT_PROPERTIES;
declare type TXN_RECEIPT = INVOKE_TXN_RECEIPT | L1_HANDLER_TXN_RECEIPT | DECLARE_TXN_RECEIPT | DEPLOY_TXN_RECEIPT | DEPLOY_ACCOUNT_TXN_RECEIPT | PENDING_TXN_RECEIPT;
declare type BLOCK_HEADER = {
    block_hash: BLOCK_HASH;
    parent_hash: BLOCK_HASH;
    block_number: BLOCK_NUMBER;
    new_root: FELT;
    timestamp: number;
    sequencer_address: FELT;
};
declare type BLOCK_BODY_WITH_TX_HASHES = {
    transactions: Array<TXN_HASH>;
};
declare type BLOCK_WITH_TX_HASHES = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TX_HASHES;
declare type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & {
    timestamp: number;
    sequencer_address: FELT;
    parent_hash: BLOCK_HASH;
};
declare type COMMON_TXN_PROPERTIES = {
    transaction_hash?: TXN_HASH;
} & BROADCASTED_TXN_COMMON_PROPERTIES;
declare type FUNCTION_CALL = {
    contract_address?: ADDRESS;
    entry_point_selector?: FELT;
    calldata?: Array<FELT>;
};
declare type INVOKE_TXN = COMMON_TXN_PROPERTIES & (INVOKE_TXN_V0 | INVOKE_TXN_V1);
declare type DECLARE_TXN = COMMON_TXN_PROPERTIES & {
    class_hash: FELT;
    sender_address: ADDRESS;
};
declare type DEPLOY_TXN = {
    transaction_hash: TXN_HASH;
    class_hash: FELT;
} & DEPLOY_TXN_PROPERTIES;
declare type DEPLOY_ACCOUNT_TXN = COMMON_TXN_PROPERTIES & DEPLOY_ACCOUNT_TXN_PROPERTIES;
declare type DEPLOY_ACCOUNT_TXN_PROPERTIES = {
    contract_address_salt: FELT;
    constructor_calldata: Array<FELT>;
    class_hash: FELT;
};
declare type DEPLOY_ACCOUNT_TXN_RECEIPT = DEPLOY_TXN_RECEIPT;
declare type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;
declare enum L1_HANDLER {
    'L1_HANDLER' = 0
}
declare type L1_HANDLER_TXN = {
    transaction_hash: TXN_HASH;
    version: NUM_AS_HEX;
    type: L1_HANDLER;
    nonce: NUM_AS_HEX;
} & FUNCTION_CALL;
declare type BROADCASTED_DEPLOY_ACCOUNT_TXN = BROADCASTED_TXN_COMMON_PROPERTIES & DEPLOY_ACCOUNT_TXN_PROPERTIES;
declare type BROADCASTED_TXN = BROADCASTED_INVOKE_TXN | BROADCASTED_DECLARE_TXN | BROADCASTED_DEPLOY_TXN | BROADCASTED_DEPLOY_ACCOUNT_TXN;
declare type BROADCASTED_INVOKE_TXN = BROADCASTED_TXN_COMMON_PROPERTIES & (INVOKE_TXN_V0 | INVOKE_TXN_V1);
declare type BROADCASTED_TXN_COMMON_PROPERTIES = {
    type: TXN_TYPE;
    max_fee: FELT;
    version: NUM_AS_HEX;
    signature: SIGNATURE;
    nonce: FELT;
};
declare type BROADCASTED_DECLARE_TXN = {
    contract_class: CONTRACT_CLASS;
    sender_address: ADDRESS;
} & BROADCASTED_TXN_COMMON_PROPERTIES;
declare type BROADCASTED_DEPLOY_TXN = {
    contract_class: CONTRACT_CLASS;
} & DEPLOY_TXN_PROPERTIES;
declare type DEPLOY_TXN_PROPERTIES = {
    version: NUM_AS_HEX;
    type: TXN_TYPE;
    contract_address_salt: FELT;
    constructor_calldata: Array<FELT>;
};
declare type INVOKE_TXN_V0 = FUNCTION_CALL;
declare type INVOKE_TXN_V1 = {
    sender_address: ADDRESS;
    calldata: Array<FELT>;
};
declare type BLOCK_BODY_WITH_TXS = {
    transactions: Array<TXN>;
};
declare type BLOCK_WITH_TXS = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;
declare type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & {
    timestamp: number;
    sequencer_address: FELT;
    parent_hash: BLOCK_HASH;
};
declare type CONTRACT_CLASS = {
    program: string;
    entry_points_by_type: {
        CONSTRUCTOR: CONTRACT_ENTRY_POINT_LIST;
        EXTERNAL: CONTRACT_ENTRY_POINT_LIST;
        L1_HANDLER: CONTRACT_ENTRY_POINT_LIST;
    };
    abi?: CONTRACT_ABI;
};
declare type CONTRACT_ABI = Array<CONTRACT_ABI_ENTRY>;
declare type CONTRACT_ABI_ENTRY = FUNCTION_ABI_ENTRY | EVENT_ABI_ENTRY | STRUCT_ABI_ENTRY;
declare enum STRUCT_ABI_TYPE {
    'struct' = 0
}
declare enum EVENT_ABI_TYPE {
    'event' = 0
}
declare enum FUNCTION_ABI_TYPE {
    'function' = 0,
    'l1_handler' = 1,
    'constructor' = 2
}
declare type STRUCT_ABI_ENTRY = STRUCT_ABI_TYPE & {
    name: string;
    size: number;
    members: Array<STRUCT_MEMBER>;
};
declare type STRUCT_MEMBER = {
    offset: number;
} & TYPED_PARAMETER;
declare type EVENT_ABI_ENTRY = {
    name: string;
    keys: Array<TYPED_PARAMETER>;
    data: Array<TYPED_PARAMETER>;
} & EVENT_ABI_TYPE;
declare type FUNCTION_ABI_ENTRY = {
    type: FUNCTION_ABI_TYPE;
    name: string;
    inputs: Array<TYPED_PARAMETER>;
    outputs: Array<TYPED_PARAMETER>;
};
declare type TYPED_PARAMETER = {
    name: string;
    type: string;
};
declare type CONTRACT_ENTRY_POINT_LIST = Array<CONTRACT_ENTRY_POINT>;
declare type CONTRACT_ENTRY_POINT = {
    offset: NUM_AS_HEX;
    selector: FELT;
};
declare type CONTRACT_STORAGE_DIFF_ITEM = {
    address: FELT;
    storage_entries: [key: FELT, value: FELT];
};
declare type DEPLOYED_CONTRACT_ITEM = {
    address: FELT;
    class_hash: FELT;
};
declare type STATE_UPDATE = {
    block_hash: BLOCK_HASH;
    new_root: FELT;
    old_root: FELT;
    state_diff: {
        storage_diffs: Array<CONTRACT_STORAGE_DIFF_ITEM>;
        declared_contract_hashes: Array<FELT>;
        deployed_contracts: Array<DEPLOYED_CONTRACT_ITEM>;
        nonces: Array<{
            contract_address: ADDRESS;
            nonce: FELT;
        }>;
    };
};
declare type STORAGE_KEY = string;
declare type EVENT_FILTER = {
    from_block?: BLOCK_ID;
    to_block?: BLOCK_ID;
    address?: ADDRESS;
    keys?: Array<FELT>;
};
declare type RESULT_PAGE_REQUEST = {
    continuation_token?: string;
    chunk_size: number;
};
declare type EMITTED_EVENT = EVENT & {
    block_hash: BLOCK_HASH;
    block_number: BLOCK_NUMBER;
    transaction_hash: TXN_HASH;
};
declare type SYNC_STATUS = {
    starting_block_hash: BLOCK_HASH;
    starting_block_num: NUM_AS_HEX;
    current_block_hash: BLOCK_HASH;
    current_block_num: NUM_AS_HEX;
    highest_block_hash: BLOCK_HASH;
    highest_block_num: NUM_AS_HEX;
};
declare type FEE_ESTIMATE = {
    gas_consumed: NUM_AS_HEX;
    gas_price: NUM_AS_HEX;
    overall_fee: NUM_AS_HEX;
};
declare enum CALL_TYPE {
    'DELEGATE' = 0,
    'CALL' = 1
}
declare enum ENTRY_POINT_TYPE {
    'EXTERNAL' = 0,
    'L1_HANDLER' = 1,
    'CONSTRUCTOR' = 2
}
declare type FUNCTION_INVOCATION = FUNCTION_CALL & {
    caller_address: FELT;
    code_address: FELT;
    entry_point_type: ENTRY_POINT_TYPE;
    call_type: CALL_TYPE;
    result: FELT;
    calls: NESTED_CALL;
    events: Array<EVENT>;
    messages: MSG_TO_L1;
};
declare type NESTED_CALL = FUNCTION_INVOCATION;
declare type TRACE_ROOT = {
    nonce: FELT;
    signature: FELT;
    function_invocation: FUNCTION_INVOCATION;
};
declare namespace OPENRPC {
    type Nonce = FELT;
    type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;
    type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;
    type StateUpdate = STATE_UPDATE;
    type Storage = FELT;
    type Transaction = TXN;
    type TransactionReceipt = TXN_RECEIPT;
    type ContractClass = CONTRACT_CLASS;
    type CallResponse = Array<FELT>;
    type EstimatedFee = FEE_ESTIMATE;
    type BlockNumber = BLOCK_NUMBER;
    type BlockHashAndNumber = {
        block_hash: BLOCK_HASH;
        block_number: BLOCK_NUMBER;
    };
    type CHAIN_ID = string;
    type PendingTransactions = Array<TXN>;
    type SyncingStatus = false | SYNC_STATUS;
    type Events = {
        events: Array<EMITTED_EVENT>;
        continuation_token: string;
    };
    type Trace = TRACE_ROOT;
    type Traces = Array<{
        transaction_hash: FELT;
        trace_root: TRACE_ROOT;
    }>;
    type TransactionHash = TXN_HASH;
    type BlockHash = BLOCK_HASH;
    type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;
    type InvokedTransaction = {
        transaction_hash: TXN_HASH;
    };
    type DeclaredTransaction = {
        transaction_hash: TXN_HASH;
        class_hash: FELT;
    };
    type DeployedTransaction = {
        transaction_hash: TXN_HASH;
        contract_address: FELT;
    };
    type Methods = {
        starknet_getBlockWithTxHashes: {
            params: {
                block_id: BLOCK_ID;
            };
            result: BlockWithTxHashes;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getBlockWithTxs: {
            params: {
                block_id: BLOCK_ID;
            };
            result: BlockWithTxs;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getStateUpdate: {
            params: {
                block_id: BLOCK_ID;
            };
            result: StateUpdate;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getStorageAt: {
            params: {
                contract_address: ADDRESS;
                key: STORAGE_KEY;
                block_id: BLOCK_ID;
            };
            result: Storage;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.BLOCK_NOT_FOUND;
        };
        starknet_getTransactionByHash: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: Transaction;
            errors: Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_getTransactionByBlockIdAndIndex: {
            params: {
                block_id: BLOCK_ID;
                index: number;
            };
            result: Transaction;
            errors: Errors.BLOCK_NOT_FOUND | Errors.INVALID_TXN_INDEX;
        };
        starknet_getTransactionReceipt: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: TransactionReceipt;
            errors: Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_getClass: {
            params: {
                block_id: BLOCK_ID;
                class_hash: FELT;
            };
            result: ContractClass;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CLASS_HASH_NOT_FOUND;
        };
        starknet_getClassHashAt: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: FELT;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_getClassAt: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: ContractClass;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_getBlockTransactionCount: {
            params: {
                block_id: BLOCK_ID;
            };
            result: number;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_call: {
            params: {
                request: FUNCTION_CALL;
                block_id: BLOCK_ID;
            };
            result: Array<FELT>;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.INVALID_MESSAGE_SELECTOR | Errors.INVALID_CALL_DATA | Errors.CONTRACT_ERROR | Errors.BLOCK_NOT_FOUND;
        };
        starknet_estimateFee: {
            params: {
                request: BROADCASTED_TXN;
                block_id: BLOCK_ID;
            };
            result: FEE_ESTIMATE;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.INVALID_MESSAGE_SELECTOR | Errors.INVALID_CALL_DATA | Errors.CONTRACT_ERROR | Errors.BLOCK_NOT_FOUND;
        };
        starknet_blockNumber: {
            params: {};
            result: BLOCK_NUMBER;
            errors: Errors.NO_BLOCKS;
        };
        starknet_blockHashAndNumber: {
            params: {};
            result: BLOCK_HASH & BLOCK_NUMBER;
            errors: Errors.NO_BLOCKS;
        };
        starknet_chainId: {
            params: {};
            result: CHAIN_ID;
        };
        starknet_pendingTransactions: {
            params: {};
            result: PendingTransactions;
        };
        starknet_syncing: {
            params: {};
            result: SyncingStatus;
        };
        starknet_getEvents: {
            params: {
                filter: EVENT_FILTER & RESULT_PAGE_REQUEST;
            };
            result: Events;
            errors: Errors.PAGE_SIZE_TOO_BIG | Errors.INVALID_CONTINUATION_TOKEN | Errors.BLOCK_NOT_FOUND;
        };
        starknet_getNonce: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: FELT;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_addInvokeTransaction: {
            params: {
                invoke_transaction: BROADCASTED_INVOKE_TXN;
            };
            result: InvokedTransaction;
        };
        starknet_addDeclareTransaction: {
            params: {
                declare_transaction: BROADCASTED_DECLARE_TXN;
            };
            result: DeclaredTransaction;
            errors: Errors.INVALID_CONTRACT_CLASS;
        };
        starknet_addDeployTransaction: {
            params: {
                deploy_transaction: BROADCASTED_DEPLOY_TXN;
            };
            result: DeployedTransaction;
            errors: Errors.INVALID_CONTRACT_CLASS;
        };
        starknet_addDeployAccountTransaction: {
            params: {
                deploy_account_transaction: BROADCASTED_DEPLOY_ACCOUNT_TXN;
            };
            result: {
                transaction_hash: TXN_HASH;
                contract_address: FELT;
            };
            errors: Errors.CLASS_HASH_NOT_FOUND;
        };
        starknet_traceTransaction: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: Trace;
            errors: Errors.TXN_HASH_NOT_FOUND | Errors.NO_TRACE_AVAILABLE | Errors.INVALID_BLOCK_HASH | Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_traceBlockTransactions: {
            params: {
                block_hash: BLOCK_HASH;
            };
            result: Traces;
            errors: Errors.INVALID_BLOCK_HASH;
        };
    };
}
declare namespace Errors {
    interface FAILED_TO_RECEIVE_TXN {
        code: 1;
        message: 'Failed to write transaction';
    }
    interface CONTRACT_NOT_FOUND {
        code: 20;
        message: 'Contract not found';
    }
    interface INVALID_MESSAGE_SELECTOR {
        code: 21;
        message: 'Invalid message selector';
    }
    interface INVALID_CALL_DATA {
        code: 22;
        message: 'Invalid call data';
    }
    interface BLOCK_NOT_FOUND {
        code: 24;
        message: 'Block not found';
    }
    interface INVALID_TXN_INDEX {
        code: 27;
        message: 'Invalid transaction index in a block';
    }
    interface CLASS_HASH_NOT_FOUND {
        code: 28;
        message: 'Class hash not found';
    }
    interface PAGE_SIZE_TOO_BIG {
        code: 31;
        message: 'Requested page size is too big';
    }
    interface NO_BLOCKS {
        code: 32;
        message: 'There are no blocks';
    }
    interface INVALID_CONTINUATION_TOKEN {
        code: 33;
        message: 'The supplied continuation token is invalid or unknown';
    }
    interface CONTRACT_ERROR {
        code: 40;
        message: 'Contract error';
    }
    interface INVALID_CONTRACT_CLASS {
        code: 50;
        message: 'Invalid contract class';
    }
    interface NO_TRACE_AVAILABLE {
        code: 10;
        message: 'No trace available for transaction';
        data: {
            status: 'RECEIVED' | 'REJECTED';
        };
    }
    interface INVALID_BLOCK_HASH {
        code: 24;
        message: 'Invalid block hash';
    }
    interface TXN_HASH_NOT_FOUND {
        code: 25;
        message: 'Transaction hash not found';
    }
}

declare namespace RPC {
    type Response = {
        id: number;
        jsonrpc: string;
        result?: any;
        error?: {
            code: string;
            message: string;
        };
    };
    type ChainId = OPENRPC.CHAIN_ID;
    type CallResponse = OPENRPC.CallResponse;
    type ContractAddress = ADDRESS;
    type Felt = FELT;
    type Nonce = OPENRPC.Nonce;
    type ContractClass = OPENRPC.ContractClass;
    type StateUpdate = OPENRPC.StateUpdate;
    type Transaction = OPENRPC.Transaction;
    type PendingTransactions = OPENRPC.PendingTransactions;
    type TransactionHash = OPENRPC.TransactionHash;
    type Trace = OPENRPC.Trace;
    type Traces = OPENRPC.Traces;
    type BlockHash = OPENRPC.BlockHash;
    type BlockHashAndNumber = OPENRPC.BlockHashAndNumber;
    type GetClassResponse = OPENRPC.ContractClass;
    type EstimateFeeResponse = OPENRPC.EstimatedFee;
    type GetBlockWithTxHashesResponse = OPENRPC.BlockWithTxHashes;
    type GetBlockWithTxs = OPENRPC.BlockWithTxs;
    type GetStorageAtResponse = OPENRPC.Storage;
    type TransactionReceipt = OPENRPC.TransactionReceipt;
    type GetTransactionByHashResponse = OPENRPC.Transaction;
    type GetTransactionByBlockIdAndIndex = OPENRPC.Transaction;
    type GetTransactionCountResponse = number;
    type GetBlockNumberResponse = OPENRPC.BlockNumber;
    type GetSyncingStatsResponse = OPENRPC.SyncingStatus;
    type EventFilter = OPENRPC.EventFilter;
    type GetEventsResponse = OPENRPC.Events;
    type InvokedTransaction = OPENRPC.InvokedTransaction;
    type DeclaredTransaction = OPENRPC.DeclaredTransaction;
    type DeployedTransaction = OPENRPC.DeployedTransaction;
    type Methods = OPENRPC.Methods;
}

declare type KeyPair = ec$1.KeyPair;
declare type Signature = string[];
declare type RawCalldata = BigNumberish[];
declare type AllowArray<T> = T | T[];
declare type RawArgs = {
    [inputName: string]: string | string[] | {
        type: 'struct';
        [k: string]: BigNumberish;
    };
} | string[];
interface ContractClass {
    program: CompressedProgram;
    entry_points_by_type: RPC.ContractClass['entry_points_by_type'];
    abi?: Abi;
}
declare type UniversalDeployerContractPayload = {
    classHash: BigNumberish;
    salt?: string;
    unique?: boolean;
    constructorCalldata?: RawArgs;
};
declare type DeployContractPayload = {
    contract: CompiledContract | string;
    constructorCalldata?: RawCalldata;
    addressSalt?: string;
};
declare type DeployAccountContractPayload = {
    classHash: BigNumberish;
    constructorCalldata?: RawCalldata;
    addressSalt?: BigNumberish;
    contractAddress?: string;
};
declare type DeployAccountContractTransaction = Omit<DeployAccountContractPayload, 'contractAddress'> & {
    signature?: Signature;
};
declare type DeclareContractPayload = {
    contract: CompiledContract | string;
    classHash: BigNumberish;
};
declare type DeclareDeployContractPayload = DeclareContractPayload & UniversalDeployerContractPayload;
declare type DeclareContractTransaction = {
    contractDefinition: ContractClass;
    senderAddress: string;
    signature?: Signature;
};
declare type CallDetails = {
    contractAddress: string;
    calldata?: RawCalldata;
};
declare type Invocation = CallDetails & {
    signature?: Signature;
};
declare type Call = CallDetails & {
    entrypoint: string;
};
declare type InvocationsDetails = {
    nonce?: BigNumberish;
    maxFee?: BigNumberish;
    version?: BigNumberish;
};
declare type InvocationsDetailsWithNonce = InvocationsDetails & {
    nonce: BigNumberish;
};
declare type TransactionBulk = Array<({
    type: 'DECLARE';
} & {
    payload: DeclareContractPayload;
}) | ({
    type: 'DEPLOY';
} & {
    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[];
}) | ({
    type: 'DEPLOY_ACCOUNT';
} & {
    payload: DeployAccountContractPayload;
}) | ({
    type: 'INVOKE_FUNCTION';
} & {
    payload: AllowArray<Call>;
})>;
declare type InvocationBulk = Array<(({
    type: 'DECLARE';
} & DeclareContractTransaction) | ({
    type: 'DEPLOY_ACCOUNT';
} & DeployAccountContractTransaction) | ({
    type: 'INVOKE_FUNCTION';
} & Invocation)) & InvocationsDetailsWithNonce & {
    blockIdentifier: BlockNumber | BigNumberish;
}>;
declare type Status = 'NOT_RECEIVED' | 'RECEIVED' | 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
declare type TransactionStatus = 'TRANSACTION_RECEIVED';
declare type TransactionType = 'DECLARE' | 'DEPLOY' | 'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT';
declare type EntryPointType = 'EXTERNAL';
declare type CompressedProgram = string;
declare type AbiEntry = {
    name: string;
    type: 'felt' | 'felt*' | string;
};
declare type FunctionAbi = {
    inputs: AbiEntry[];
    name: string;
    outputs: AbiEntry[];
    stateMutability?: 'view';
    type: FunctionAbiType;
};
declare enum FunctionAbiType {
    'function' = 0,
    'l1_handler' = 1,
    'constructor' = 2
}
declare type StructAbi = {
    members: (AbiEntry & {
        offset: number;
    })[];
    name: string;
    size: number;
    type: 'struct';
};
declare type Abi = Array<FunctionAbi | EventAbi | StructAbi>;
declare type EventAbi = any;
declare type EntryPointsByType = object;
declare type Program = Record<any, any>;
declare type BlockTag = 'pending' | 'latest';
declare type BlockNumber = BlockTag | null | number;
declare type CompiledContract = {
    abi: Abi;
    entry_points_by_type: EntryPointsByType;
    program: Program;
};
declare type CompressedCompiledContract = Omit<CompiledContract, 'program'> & {
    program: CompressedProgram;
};
declare type Struct = {
    type: 'struct';
    [k: string]: BigNumberish;
};
declare type Args = {
    [inputName: string]: BigNumberish | BigNumberish[] | ParsedStruct | ParsedStruct[];
};
declare type ParsedStruct = {
    [key: string]: BigNumberish | ParsedStruct;
};

declare type Calldata = string[];
declare type Overrides = {
    maxFee?: BigNumberish;
    nonce?: BigNumberish;
    signature?: Signature;
};

declare const IS_BROWSER: boolean;
declare function arrayBufferToString(array: ArrayBuffer): string;
declare function btoaUniversal(b: ArrayBuffer): string;
declare function buf2hex(buffer: Uint8Array): string;
/**
 * Some function imported from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts
 * enc-utils is no dependency to avoid using `Buffer` which just works in node and no browsers
 */
declare function removeHexPrefix(hex: string): string;
declare function addHexPrefix(hex: string): string;
declare function padLeft(str: string, length: number, padding?: string): string;
declare function calcByteLength(length: number, byteSize?: number): number;
declare function sanitizeBytes(str: string, byteSize?: number, padding?: string): string;
declare function sanitizeHex(hex: string): string;
declare function utf8ToArray(str: string): Uint8Array;

declare const encode_IS_BROWSER: typeof IS_BROWSER;
declare const encode_arrayBufferToString: typeof arrayBufferToString;
declare const encode_btoaUniversal: typeof btoaUniversal;
declare const encode_buf2hex: typeof buf2hex;
declare const encode_removeHexPrefix: typeof removeHexPrefix;
declare const encode_addHexPrefix: typeof addHexPrefix;
declare const encode_padLeft: typeof padLeft;
declare const encode_calcByteLength: typeof calcByteLength;
declare const encode_sanitizeBytes: typeof sanitizeBytes;
declare const encode_sanitizeHex: typeof sanitizeHex;
declare const encode_utf8ToArray: typeof utf8ToArray;
declare namespace encode {
  export {
    encode_IS_BROWSER as IS_BROWSER,
    encode_arrayBufferToString as arrayBufferToString,
    encode_btoaUniversal as btoaUniversal,
    encode_buf2hex as buf2hex,
    encode_removeHexPrefix as removeHexPrefix,
    encode_addHexPrefix as addHexPrefix,
    encode_padLeft as padLeft,
    encode_calcByteLength as calcByteLength,
    encode_sanitizeBytes as sanitizeBytes,
    encode_sanitizeHex as sanitizeHex,
    encode_utf8ToArray as utf8ToArray,
  };
}

declare const ZERO: BN;
declare const ONE: BN;
declare const TWO: BN;
declare const MASK_250: BN;
declare const MASK_251: BN;
declare enum StarknetChainId {
    MAINNET = "0x534e5f4d41494e",
    TESTNET = "0x534e5f474f45524c49",
    TESTNET2 = "0x534e5f474f45524c4932"
}
declare enum TransactionHashPrefix {
    DECLARE = "0x6465636c617265",
    DEPLOY = "0x6465706c6f79",
    DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74",
    INVOKE = "0x696e766f6b65",
    L1_HANDLER = "0x6c315f68616e646c6572"
}
declare const UDC: {
    ADDRESS: string;
    ENTRYPOINT: string;
};
/**
 * The following is taken from https://github.com/starkware-libs/starkex-resources/blob/master/crypto/starkware/crypto/signature/pedersen_params.json but converted to hex, because JS is very bad handling big integers by default
 * Please do not edit until the JSON changes.
 */
declare const FIELD_PRIME = "800000000000011000000000000000000000000000000000000000000000001";
declare const FIELD_GEN = "3";
declare const FIELD_SIZE = 251;
declare const EC_ORDER = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F";
declare const ALPHA = "1";
declare const BETA = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89";
declare const MAX_ECDSA_VAL = "800000000000000000000000000000000000000000000000000000000000000";
declare const CONSTANT_POINTS: string[][];

declare const constants_ZERO: typeof ZERO;
declare const constants_ONE: typeof ONE;
declare const constants_TWO: typeof TWO;
declare const constants_MASK_250: typeof MASK_250;
declare const constants_MASK_251: typeof MASK_251;
type constants_StarknetChainId = StarknetChainId;
declare const constants_StarknetChainId: typeof StarknetChainId;
type constants_TransactionHashPrefix = TransactionHashPrefix;
declare const constants_TransactionHashPrefix: typeof TransactionHashPrefix;
declare const constants_UDC: typeof UDC;
declare const constants_FIELD_PRIME: typeof FIELD_PRIME;
declare const constants_FIELD_GEN: typeof FIELD_GEN;
declare const constants_FIELD_SIZE: typeof FIELD_SIZE;
declare const constants_EC_ORDER: typeof EC_ORDER;
declare const constants_ALPHA: typeof ALPHA;
declare const constants_BETA: typeof BETA;
declare const constants_MAX_ECDSA_VAL: typeof MAX_ECDSA_VAL;
declare const constants_CONSTANT_POINTS: typeof CONSTANT_POINTS;
declare const constants_IS_BROWSER: typeof IS_BROWSER;
declare namespace constants {
  export {
    constants_ZERO as ZERO,
    constants_ONE as ONE,
    constants_TWO as TWO,
    constants_MASK_250 as MASK_250,
    constants_MASK_251 as MASK_251,
    constants_StarknetChainId as StarknetChainId,
    constants_TransactionHashPrefix as TransactionHashPrefix,
    constants_UDC as UDC,
    constants_FIELD_PRIME as FIELD_PRIME,
    constants_FIELD_GEN as FIELD_GEN,
    constants_FIELD_SIZE as FIELD_SIZE,
    constants_EC_ORDER as EC_ORDER,
    constants_ALPHA as ALPHA,
    constants_BETA as BETA,
    constants_MAX_ECDSA_VAL as MAX_ECDSA_VAL,
    constants_CONSTANT_POINTS as CONSTANT_POINTS,
    constants_IS_BROWSER as IS_BROWSER,
  };
}

interface InvocationsSignerDetails extends Required<InvocationsDetails> {
    walletAddress: string;
    chainId: StarknetChainId;
}
interface DeclareSignerDetails {
    classHash: BigNumberish;
    senderAddress: BigNumberish;
    chainId: StarknetChainId;
    maxFee: BigNumberish;
    version: BigNumberish;
    nonce: BigNumberish;
}
declare type DeployAccountSignerDetails = Required<DeployAccountContractPayload> & Required<InvocationsDetails> & {
    contractAddress: BigNumberish;
    chainId: StarknetChainId;
};

declare type AsyncContractFunction<T = any> = (...args: Array<any>) => Promise<T>;
declare type ContractFunction = (...args: Array<any>) => any;
interface Result extends Array<any> {
    [key: string]: any;
}

declare type BlockIdentifier = BlockNumber | BigNumberish;

declare type GetTransactionStatusResponse = {
    tx_status: Status;
    block_hash?: string;
    tx_failure_reason?: {
        code: string;
        error_message: string;
    };
};
declare type GetContractAddressesResponse = {
    Starknet: string;
    GpsStatementVerifier: string;
};
declare type FunctionInvocation = {
    caller_address: string;
    contract_address: string;
    calldata: RawCalldata;
    call_type?: string;
    class_hash?: string;
    selector?: string;
    entry_point_type?: EntryPointType;
    result: Array<any>;
    execution_resources: ExecutionResources;
    internal_calls: Array<FunctionInvocation>;
    events: Array<any>;
    messages: Array<any>;
};
declare type ExecutionResources = {
    n_steps: number;
    builtin_instance_counter: {
        pedersen_builtin: number;
        range_check_builtin: number;
        bitwise_builtin: number;
        output_builtin: number;
        ecdsa_builtin: number;
        ec_op_builtin?: number;
    };
    n_memory_holes: number;
};
declare type TransactionTraceResponse = {
    validate_invocation?: FunctionInvocation;
    function_invocation?: FunctionInvocation;
    fee_transfer_invocation?: FunctionInvocation;
    signature: Signature;
};
declare type CallL1Handler = {
    from_address: string;
    to_address: string;
    entry_point_selector: string;
    payload: Array<string>;
};
declare type StateDiffItem = {
    key: string;
    value: string;
};
declare type StorageDiffItem = {
    address: string;
    storage_entries: [key: string, value: string];
};
declare type DeployedContractItem = {
    address: string;
    class_hash: string;
};
declare type Nonces = {
    contract_address: string;
    nonce: string;
};
declare type SequencerIdentifier = {
    blockHash: string;
} | {
    blockNumber: BlockNumber;
};
declare namespace Sequencer {
    type DeclareTransaction = {
        type: 'DECLARE';
        sender_address: string;
        contract_class: ContractClass;
        signature?: Signature;
        nonce: BigNumberish;
        max_fee?: BigNumberish;
        version?: BigNumberish;
    };
    type DeployTransaction = {
        type: 'DEPLOY';
        contract_definition: ContractClass;
        contract_address_salt: BigNumberish;
        constructor_calldata: string[];
        nonce?: BigNumberish;
    };
    type DeployAccountTransaction = {
        type: 'DEPLOY_ACCOUNT';
        class_hash: string;
        contract_address_salt: BigNumberish;
        constructor_calldata: string[];
        signature?: Signature;
        max_fee?: BigNumberish;
        version?: BigNumberish;
        nonce?: BigNumberish;
    };
    type InvokeFunctionTransaction = {
        type: 'INVOKE_FUNCTION';
        contract_address: string;
        signature?: Signature;
        entry_point_type?: EntryPointType;
        calldata?: RawCalldata;
        nonce: BigNumberish;
        max_fee?: BigNumberish;
        version?: BigNumberish;
    };
    type Transaction = DeclareTransaction | DeployTransaction | InvokeFunctionTransaction | DeployAccountTransaction;
    type AddTransactionResponse = {
        transaction_hash: string;
        code?: TransactionStatus;
        address?: string;
        class_hash?: string;
    };
    type GetCodeResponse = {
        bytecode: string[];
        abi: Abi;
    };
    interface InvokeFunctionTransactionResponse extends InvokeFunctionTransaction {
        transaction_hash: string;
        entry_point_selector: string;
    }
    type TransactionResponse = DeclareTransaction | DeployTransaction | InvokeFunctionTransactionResponse;
    type SuccessfulTransactionResponse = {
        status: Status;
        transaction: TransactionResponse;
        block_hash: string;
        block_number: BlockNumber;
        transaction_index: number;
    };
    type FailedTransactionResponse = {
        status: 'REJECTED';
        transaction_failure_reason: {
            code: string;
            error_message: string;
        };
        transaction: TransactionResponse;
    };
    type GetTransactionResponse = SuccessfulTransactionResponse | FailedTransactionResponse;
    type TransactionReceiptResponse = SuccessfulTransactionReceiptResponse | FailedTransactionReceiptResponse;
    type SuccessfulTransactionReceiptResponse = {
        status: Status;
        transaction_hash: string;
        transaction_index: number;
        block_hash: string;
        block_number: BlockNumber;
        l2_to_l1_messages: string[];
        events: string[];
        actual_fee: string;
        execution_resources: ExecutionResources;
    };
    type FailedTransactionReceiptResponse = {
        status: 'REJECTED';
        transaction_failure_reason: {
            code: string;
            error_message: string;
        };
        transaction_hash: string;
        l2_to_l1_messages: string[];
        events: string[];
    };
    type GetBlockResponse = {
        block_number: number;
        state_root: string;
        block_hash: string;
        transactions: {
            [txHash: string]: TransactionResponse;
        };
        timestamp: number;
        transaction_receipts: {
            [txHash: string]: {
                block_hash: string;
                transaction_hash: string;
                l2_to_l1_messages: {
                    to_address: string;
                    payload: string[];
                    from_address: string;
                }[];
                block_number: BlockNumber;
                status: Status;
                transaction_index: number;
            };
        };
        parent_block_hash: string;
        status: Status;
        gas_price: string;
        sequencer_address: string;
        starknet_version: string;
    };
    type CallContractTransaction = Omit<InvokeFunctionTransaction, 'type' | 'entry_point_type' | 'nonce'> & {
        entry_point_selector: string;
    };
    type CallContractResponse = {
        result: string[];
    };
    type InvokeEstimateFee = Omit<InvokeFunctionTransaction, 'max_fee' | 'entry_point_type'>;
    type DeclareEstimateFee = Omit<DeclareTransaction, 'max_fee'>;
    type DeployAccountEstimateFee = Omit<DeployAccountTransaction, 'max_fee'>;
    type DeployEstimateFee = DeployTransaction;
    type EstimateFeeRequest = InvokeEstimateFee | DeclareEstimateFee | DeployEstimateFee | DeployAccountEstimateFee;
    type TransactionSimulationResponse = {
        trace: TransactionTraceResponse;
        fee_estimation: Sequencer.EstimateFeeResponse;
    };
    type SimulateTransaction = Omit<InvokeFunctionTransaction, 'max_fee' | 'entry_point_type'>;
    type EstimateFeeRequestBulk = AllowArray<InvokeEstimateFee | DeclareEstimateFee | DeployEstimateFee | DeployAccountEstimateFee>;
    type EstimateFeeResponse = {
        overall_fee: number;
        gas_price: number;
        gas_usage: number;
        uint: string;
    } | {
        amount: BN__default;
        unit: string;
    };
    type EstimateFeeResponseBulk = AllowArray<EstimateFeeResponse>;
    type BlockTransactionTracesResponse = {
        traces: Array<TransactionTraceResponse & {
            transaction_hash: string;
        }>;
    };
    type StateUpdateResponse = {
        block_hash: string;
        new_root: string;
        old_root: string;
        state_diff: {
            storage_diffs: Array<{
                [address: string]: Array<StateDiffItem>;
            }>;
            declared_contract_hashes: Array<string>;
            deployed_contracts: Array<DeployedContractItem>;
            nonces: Array<Nonces>;
        };
    };
    type Endpoints = {
        get_contract_addresses: {
            QUERY: never;
            REQUEST: never;
            RESPONSE: GetContractAddressesResponse;
        };
        add_transaction: {
            QUERY: never;
            REQUEST: Transaction;
            RESPONSE: AddTransactionResponse;
        };
        get_transaction: {
            QUERY: {
                transactionHash: string;
            };
            REQUEST: never;
            RESPONSE: GetTransactionResponse;
        };
        get_transaction_status: {
            QUERY: {
                transactionHash: string;
            };
            REQUEST: never;
            RESPONSE: GetTransactionStatusResponse;
        };
        get_transaction_trace: {
            QUERY: {
                transactionHash: string;
            };
            REQUEST: never;
            RESPONSE: TransactionTraceResponse;
        };
        get_transaction_receipt: {
            QUERY: {
                transactionHash: string;
            };
            REQUEST: never;
            RESPONSE: TransactionReceiptResponse;
        };
        get_nonce: {
            QUERY: {
                contractAddress: string;
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: BigNumberish;
        };
        get_storage_at: {
            QUERY: {
                contractAddress: string;
                key: BigNumberish;
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: string;
        };
        get_code: {
            QUERY: {
                contractAddress: string;
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: GetCodeResponse;
        };
        get_block: {
            QUERY: {
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: GetBlockResponse;
        };
        call_contract: {
            QUERY: {
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: CallContractTransaction;
            RESPONSE: CallContractResponse;
        };
        estimate_fee: {
            QUERY: {
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: EstimateFeeRequest;
            RESPONSE: EstimateFeeResponse;
        };
        get_class_by_hash: {
            QUERY: {
                classHash: string;
            };
            REQUEST: never;
            RESPONSE: any;
        };
        get_class_hash_at: {
            QUERY: {
                contractAddress: string;
                blockIdentifier?: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: string;
        };
        get_state_update: {
            QUERY: {
                blockHash?: string;
                blockNumber?: BlockNumber;
            };
            REQUEST: never;
            RESPONSE: StateUpdateResponse;
        };
        get_full_contract: {
            QUERY: {
                contractAddress: string;
                blockIdentifier?: BlockIdentifier;
            };
            REQUEST: never;
            RESPONSE: any;
        };
        estimate_message_fee: {
            QUERY: any;
            REQUEST: any;
            RESPONSE: EstimateFeeResponse;
        };
        simulate_transaction: {
            QUERY: {
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: SimulateTransaction;
            RESPONSE: TransactionSimulationResponse;
        };
        estimate_fee_bulk: {
            QUERY: {
                blockIdentifier: BlockIdentifier;
            };
            REQUEST: EstimateFeeRequestBulk;
            RESPONSE: EstimateFeeResponseBulk;
        };
        get_block_traces: {
            QUERY: {
                blockHash?: string;
                blockNumber?: BlockNumber;
            };
            REQUEST: never;
            RESPONSE: BlockTransactionTracesResponse;
        };
    };
}

/**
 * Common interface response
 * Intersection (sequencer response ∩ (∪ rpc responses))
 */

interface GetBlockResponse {
    timestamp: number;
    block_hash: string;
    block_number: number;
    new_root: string;
    parent_hash: string;
    status: Status;
    transactions: Array<string>;
    gas_price?: string;
    sequencer_address?: string;
    starknet_version?: string;
    transaction_receipts?: any;
}
interface GetCodeResponse {
    bytecode: string[];
}
declare type GetTransactionResponse = InvokeTransactionResponse & DeclareTransactionResponse;
interface CommonTransactionResponse {
    transaction_hash?: string;
    version?: string;
    signature?: Signature;
    max_fee?: string;
    nonce?: string;
}
interface InvokeTransactionResponse extends CommonTransactionResponse {
    contract_address?: string;
    entry_point_selector?: string;
    calldata: RawCalldata;
}
interface ContractEntryPoint {
    offset: string;
    selector: string;
}
interface DeclareTransactionResponse extends CommonTransactionResponse {
    contract_class?: any;
    sender_address?: string;
}
declare type GetTransactionReceiptResponse = InvokeTransactionReceiptResponse | DeclareTransactionReceiptResponse;
interface CommonTransactionReceiptResponse {
    transaction_hash: string;
    status?: Status;
    actual_fee?: string;
    status_data?: string;
}
interface MessageToL1 {
    to_address: string;
    payload: Array<string>;
}
interface Event {
    from_address: string;
    keys: Array<string>;
    data: Array<string>;
}
interface MessageToL2 {
    from_address: string;
    payload: Array<string>;
}
interface InvokeTransactionReceiptResponse extends CommonTransactionReceiptResponse {
    /** @deprecated Use l2_to_l1_messages */
    messages_sent?: Array<MessageToL1>;
    events?: Array<Event>;
    l1_origin_message?: MessageToL2;
}
declare type DeclareTransactionReceiptResponse = CommonTransactionReceiptResponse;
interface EstimateFeeResponse {
    overall_fee: BN__default;
    gas_consumed?: BN__default;
    gas_price?: BN__default;
}
interface InvokeFunctionResponse {
    transaction_hash: string;
}
interface DeclareContractResponse {
    transaction_hash: string;
    class_hash: string;
}
declare type CallContractResponse = {
    result: Array<string>;
};
declare type EstimateFeeAction = {
    type: 'INVOKE';
    payload: AllowArray<Call>;
} | {
    type: 'DECLARE';
    payload: DeclareContractPayload;
} | {
    type: 'DEPLOY_ACCOUNT';
    payload: DeployAccountContractPayload;
} | {
    type: 'DEPLOY';
    payload: UniversalDeployerContractPayload;
};
declare type EstimateFeeResponseBulk = Array<EstimateFeeResponse>;
interface TransactionSimulationResponse {
    trace: TransactionTraceResponse;
    fee_estimation: EstimateFeeResponse;
}
interface StateUpdateResponse {
    block_hash: string;
    new_root: string;
    old_root: string;
    state_diff: {
        storage_diffs: Array<StorageDiffItem>;
        declared_contract_hashes: Array<string>;
        deployed_contracts: Array<DeployedContractItem>;
        nonces: Array<Nonces>;
    };
}

interface EstimateFee extends EstimateFeeResponse {
    suggestedMaxFee: BN__default;
}
declare type EstimateFeeBulk = Array<EstimateFee>;
interface EstimateFeeDetails {
    nonce?: BigNumberish;
    blockIdentifier?: BlockIdentifier;
}
interface DeployContractResponse {
    contract_address: string;
    transaction_hash: string;
}
declare type MultiDeployContractResponse = {
    contract_address: Array<string>;
    transaction_hash: string;
};
declare type DeployContractUDCResponse = {
    contract_address: string;
    transaction_hash: string;
    address: string;
    deployer: string;
    unique: string;
    classHash: string;
    calldata_len: string;
    calldata: Array<string>;
    salt: string;
};
declare type DeclareDeployUDCResponse = {
    declare: {
        class_hash: BigNumberish;
    } & DeclareTransactionReceiptResponse;
    deploy: DeployContractUDCResponse;
};
interface TransactionSimulation extends TransactionSimulationResponse {
    fee_estimation: EstimateFee;
}

declare abstract class ProviderInterface {
    abstract chainId: StarknetChainId;
    /**
     * Gets the Starknet chain Id
     *
     * @returns the chain Id
     */
    abstract getChainId(): Promise<StarknetChainId>;
    /**
     * Calls a function on the Starknet contract.
     *
     * @param call transaction to be called
     * @param blockIdentifier block identifier
     * @returns the result of the function on the smart contract.
     */
    abstract callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<CallContractResponse>;
    /**
     * Gets the block information
     *
     * @param blockIdentifier block identifier
     * @returns the block object
     */
    abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;
    /**
     * @deprecated The method should not be used
     */
    abstract getCode(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<GetCodeResponse>;
    /**
     * Gets the contract class of the deployed contract.
     *
     * @param contractAddress - contract address
     * @param blockIdentifier - block identifier
     * @returns Contract class of compiled contract
     */
    abstract getClassAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<ContractClass>;
    /**
     * Returns the class hash deployed under the given address.
     *
     * @param contractAddress - contract address
     * @param blockIdentifier - block identifier
     * @returns Class hash
     */
    abstract getClassHashAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<string>;
    /**
     * Returns the contract class deployed under the given class hash.
     *
     * @param classHash - class hash
     * @returns Contract class of compiled contract
     */
    abstract getClassByHash(classHash: string): Promise<ContractClass>;
    /**
     * Gets the nonce of a contract with respect to a specific block
     *
     * @param contractAddress - contract address
     * @returns the hex nonce
     */
    abstract getNonceForAddress(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    /**
     * Gets the contract's storage variable at a specific key.
     *
     * @param contractAddress
     * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)
     * @param blockIdentifier - block identifier
     * @returns the value of the storage variable
     */
    abstract getStorageAt(contractAddress: string, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    /**
     * Gets the transaction information from a tx id.
     *
     * @param txHash
     * @returns the transaction object { transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? }
     */
    abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;
    /**
     * Gets the transaction receipt from a tx hash.
     *
     * @param txHash
     * @returns the transaction receipt object
     */
    abstract getTransactionReceipt(transactionHash: BigNumberish): Promise<GetTransactionReceiptResponse>;
    /**
     * Deploys a given compiled Account contract (json) to starknet
     *
     * @param payload payload to be deployed containing:
     * - compiled contract code
     * - constructor calldata
     * - address salt
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract deployAccountContract(payload: DeployAccountContractPayload, details: InvocationsDetailsWithNonce): Promise<DeployContractResponse>;
    /**
     * Invokes a function on starknet
     * @deprecated This method wont be supported as soon as fees are mandatory. Should not be used outside of Account class
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * - maxFee - optional maxFee
     * @returns response from addTransaction
     */
    abstract invokeFunction(invocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokeFunctionResponse>;
    /**
     * Declares a given compiled contract (json) to starknet
     * @param transaction transaction payload to be deployed containing:
     * - compiled contract code
     * - sender address
     * - signature
     * @param details Invocation Details containing:
     * - nonce
     * - optional version
     * - optional maxFee
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract declareContract(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclareContractResponse>;
    /**
     * Estimates the fee for a given INVOKE transaction
     * @deprecated Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param blockIdentifier - block identifier
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * @returns the estimated fee
     */
    abstract getEstimateFee(invocation: Invocation, details: InvocationsDetailsWithNonce, blockIdentifier: BlockIdentifier): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given INVOKE transaction
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param blockIdentifier - block identifier
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * @returns the estimated fee
     */
    abstract getInvokeEstimateFee(invocation: Invocation, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given DECLARE transaction
     *
     * @param transaction transaction payload to be declared containing:
     * - compiled contract code
     * - sender address
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce
     * - version - optional version
     * - optional maxFee
     * @param blockIdentifier - block identifier
     * @returns the estimated fee
     */
    abstract getDeclareEstimateFee(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given DEPLOY_ACCOUNT transaction
     *
     * @param transaction transaction payload to be deployed containing:
     * - classHash
     * - constructorCalldata
     * - addressSalt
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce
     * - version - optional version
     * - optional maxFee
     * @param blockIdentifier - block identifier
     * @returns the estimated fee
     */
    abstract getDeployAccountEstimateFee(transaction: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a list of INVOKE transaction
     *
     * @param invocations the array of invocation and invocation details object containing:
     * - contractAddress - the address of the account
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * - nonce - optional nonce
     * - version - optional version
     * @param blockIdentifier - block identifier
     * @returns the estimated fee
     */
    abstract getEstimateFeeBulk(invocations: InvocationBulk, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponseBulk>;
    /**
     * Wait for the transaction to be accepted
     * @param txHash - transaction hash
     * @param retryInterval - retry interval
     * @return GetTransactionReceiptResponse
     */
    abstract waitForTransaction(txHash: BigNumberish, retryInterval?: number, successStates?: Array<Status>): Promise<GetTransactionReceiptResponse>;
    /**
     * Simulates the transaction and returns the transaction trace and estimated fee.
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * @param blockIdentifier - block identifier
     * @returns the transaction trace and estimated fee
     */
    abstract getSimulateTransaction(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<TransactionSimulationResponse>;
    /**
     * Gets the state changes in a specific block
     *
     * @param blockIdentifier - block identifier
     * @returns StateUpdateResponse
     */
    abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
}

declare type RpcProviderOptions = {
    nodeUrl: string;
    retries?: number;
    headers?: object;
    blockIdentifier?: BlockIdentifier;
};
declare class RpcProvider implements ProviderInterface {
    nodeUrl: string;
    chainId: StarknetChainId;
    headers: object;
    private responseParser;
    private retries;
    private blockIdentifier;
    constructor(optionsOrProvider: RpcProviderOptions);
    fetch(method: any, params: any): Promise<any>;
    protected errorHandler(error: any): void;
    protected fetchEndpoint<T extends keyof RPC.Methods>(method: T, params?: RPC.Methods[T]['params']): Promise<RPC.Methods[T]['result']>;
    getChainId(): Promise<any>;
    getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;
    getBlockHashAndNumber(): Promise<RPC.BlockHashAndNumber>;
    getBlockWithTxHashes(blockIdentifier?: BlockIdentifier): Promise<RPC.GetBlockWithTxHashesResponse>;
    getBlockWithTxs(blockIdentifier?: BlockIdentifier): Promise<RPC.GetBlockWithTxs>;
    getClassHashAt(contractAddress: RPC.ContractAddress, blockIdentifier?: BlockIdentifier): Promise<RPC.Felt>;
    getNonceForAddress(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<RPC.Nonce>;
    getPendingTransactions(): Promise<RPC.PendingTransactions>;
    getProtocolVersion(): Promise<Error>;
    getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<RPC.StateUpdate>;
    getStorageAt(contractAddress: string, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    getTransaction(txHash: string): Promise<GetTransactionResponse>;
    getTransactionByHash(txHash: string): Promise<RPC.GetTransactionByHashResponse>;
    getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number): Promise<RPC.GetTransactionByBlockIdAndIndex>;
    getTransactionReceipt(txHash: string): Promise<RPC.TransactionReceipt>;
    getClassByHash(classHash: RPC.Felt): Promise<RPC.ContractClass>;
    getClass(classHash: RPC.Felt, blockIdentifier?: BlockIdentifier): Promise<RPC.ContractClass>;
    getClassAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<RPC.ContractClass>;
    getCode(_contractAddress: string, _blockIdentifier?: BlockIdentifier): Promise<GetCodeResponse>;
    getEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getInvokeEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getDeclareEstimateFee({ senderAddress, contractDefinition, signature }: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getDeployAccountEstimateFee({ classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getEstimateFeeBulk(_invocations: InvocationBulk, _blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponseBulk>;
    declareContract({ contractDefinition, signature, senderAddress }: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclareContractResponse>;
    deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeployContractResponse>;
    invokeFunction(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokeFunctionResponse>;
    callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<CallContractResponse>;
    traceTransaction(transactionHash: RPC.TransactionHash): Promise<RPC.Trace>;
    traceBlockTransactions(blockHash: RPC.BlockHash): Promise<RPC.Traces>;
    waitForTransaction(txHash: string, retryInterval?: number, successStates?: string[]): Promise<any>;
    /**
     * Gets the transaction count from a block.
     *
     *
     * @param blockIdentifier
     * @returns Number of transactions
     */
    getTransactionCount(blockIdentifier?: BlockIdentifier): Promise<RPC.GetTransactionCountResponse>;
    /**
     * Gets the latest block number
     *
     *
     * @returns Number of the latest block
     */
    getBlockNumber(): Promise<RPC.GetBlockNumberResponse>;
    /**
     * Gets syncing status of the node
     *
     *
     * @returns Object with the stats data
     */
    getSyncingStats(): Promise<RPC.GetSyncingStatsResponse>;
    /**
     * Gets all the events filtered
     *
     *
     * @returns events and the pagination of the events
     */
    getEvents(eventFilter: RPC.EventFilter): Promise<RPC.GetEventsResponse>;
    getSimulateTransaction(_invocation: Invocation, _invocationDetails: InvocationsDetailsWithNonce, _blockIdentifier?: BlockIdentifier): Promise<TransactionSimulationResponse>;
    getStarkName(address: BigNumberish, StarknetIdContract?: string): Promise<string>;
    getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string>;
}

declare type NetworkName = 'mainnet-alpha' | 'goerli-alpha' | 'goerli-alpha-2';
declare type SequencerProviderOptions = {
    headers?: object;
    blockIdentifier?: BlockIdentifier;
} & ({
    network: NetworkName | StarknetChainId;
    chainId?: StarknetChainId;
} | {
    baseUrl: string;
    feederGatewayUrl?: string;
    gatewayUrl?: string;
    chainId?: StarknetChainId;
});
declare class SequencerProvider implements ProviderInterface {
    baseUrl: string;
    feederGatewayUrl: string;
    gatewayUrl: string;
    chainId: StarknetChainId;
    headers: object | undefined;
    private responseParser;
    private blockIdentifier;
    constructor(optionsOrProvider?: SequencerProviderOptions);
    protected static getNetworkFromName(name: NetworkName | StarknetChainId): "https://alpha-mainnet.starknet.io" | "https://alpha4.starknet.io" | "https://alpha4-2.starknet.io";
    protected static getChainIdFromBaseUrl(baseUrl: string): StarknetChainId;
    private getFetchUrl;
    private getFetchMethod;
    private getQueryString;
    private getHeaders;
    protected fetchEndpoint<T extends keyof Sequencer.Endpoints>(endpoint: T, ...[query, request]: Sequencer.Endpoints[T]['QUERY'] extends never ? Sequencer.Endpoints[T]['REQUEST'] extends never ? [] : [undefined, Sequencer.Endpoints[T]['REQUEST']] : Sequencer.Endpoints[T]['REQUEST'] extends never ? [Sequencer.Endpoints[T]['QUERY']] : [Sequencer.Endpoints[T]['QUERY'], Sequencer.Endpoints[T]['REQUEST']]): Promise<Sequencer.Endpoints[T]['RESPONSE']>;
    getChainId(): Promise<StarknetChainId>;
    callContract({ contractAddress, entrypoint: entryPointSelector, calldata }: Call, blockIdentifier?: BlockIdentifier): Promise<CallContractResponse>;
    getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;
    getNonceForAddress(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    getStorageAt(contractAddress: string, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    getTransaction(txHash: BigNumberish): Promise<GetTransactionResponse>;
    getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse>;
    getClassAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<ContractClass>;
    getClassHashAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClassByHash(classHash: string): Promise<ContractClass>;
    invokeFunction(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokeFunctionResponse>;
    deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeployContractResponse>;
    declareContract({ senderAddress, contractDefinition, signature }: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclareContractResponse>;
    getEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getInvokeEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getDeclareEstimateFee({ senderAddress, contractDefinition, signature }: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getDeployAccountEstimateFee({ classHash, addressSalt, constructorCalldata, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getEstimateFeeBulk(invocations: InvocationBulk, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponseBulk>;
    getCode(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<Sequencer.GetCodeResponse>;
    waitForTransaction(txHash: BigNumberish, retryInterval?: number, successStates?: string[]): Promise<GetTransactionReceiptResponse>;
    /**
     * Gets the status of a transaction.
     *
     * [Reference](https://github.com/starkware-libs/cairo-lang/blob/f464ec4797361b6be8989e36e02ec690e74ef285/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L48-L52)
     *
     * @param txHash
     * @returns the transaction status object { block_number, tx_status: NOT_RECEIVED | RECEIVED | PENDING | REJECTED | ACCEPTED_ONCHAIN }
     */
    getTransactionStatus(txHash: BigNumberish): Promise<GetTransactionStatusResponse>;
    /**
     * Gets the smart contract address on the goerli testnet.
     *
     * [Reference](https://github.com/starkware-libs/cairo-lang/blob/f464ec4797361b6be8989e36e02ec690e74ef285/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L13-L15)
     * @returns starknet smart contract addresses
     */
    getContractAddresses(): Promise<GetContractAddressesResponse>;
    /**
     * Gets the transaction trace from a tx id.
     *
     * @param txHash
     * @returns the transaction trace
     */
    getTransactionTrace(txHash: BigNumberish): Promise<TransactionTraceResponse>;
    estimateMessageFee({ from_address, to_address, entry_point_selector, payload }: CallL1Handler, blockIdentifier?: BlockIdentifier): Promise<Sequencer.EstimateFeeResponse>;
    getSimulateTransaction(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<TransactionSimulationResponse>;
    getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
    getBlockTraces(blockIdentifier?: BlockIdentifier): Promise<Sequencer.BlockTransactionTracesResponse>;
    getStarkName(address: BigNumberish, StarknetIdContract?: string): Promise<string>;
    getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string>;
}

interface ProviderOptions {
    sequencer?: SequencerProviderOptions;
    rpc?: RpcProviderOptions;
}
declare class Provider implements ProviderInterface {
    private provider;
    constructor(providerOrOptions?: ProviderOptions | ProviderInterface);
    get chainId(): StarknetChainId;
    getChainId(): Promise<StarknetChainId>;
    getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;
    getClassAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<ContractClass>;
    getClassHashAt(contractAddress: string, blockIdentifier: BlockIdentifier): Promise<string>;
    getClassByHash(classHash: string): Promise<ContractClass>;
    getEstimateFee(invocationWithTxType: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier: BlockIdentifier): Promise<EstimateFeeResponse>;
    getInvokeEstimateFee(invocationWithTxType: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getEstimateFeeBulk(invocations: InvocationBulk, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponseBulk>;
    getNonceForAddress(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    getStorageAt(contractAddress: string, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    getTransaction(txHash: BigNumberish): Promise<GetTransactionResponse>;
    getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse>;
    callContract(request: Call, blockIdentifier?: BlockIdentifier): Promise<CallContractResponse>;
    invokeFunction(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokeFunctionResponse>;
    deployAccountContract(payload: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeployContractResponse>;
    declareContract(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclareContractResponse>;
    getDeclareEstimateFee(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getDeployAccountEstimateFee(transaction: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<EstimateFeeResponse>;
    getCode(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<GetCodeResponse>;
    waitForTransaction(txHash: BigNumberish, retryInterval?: number, successStates?: Array<Status>): Promise<GetTransactionReceiptResponse>;
    getSimulateTransaction(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier): Promise<TransactionSimulationResponse>;
    getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
    getStarkName(address: BigNumberish, StarknetIdContract?: string): Promise<string>;
    getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string>;
}

declare class LibraryError extends CustomError {
}
declare class GatewayError extends LibraryError {
    errorCode: string;
    constructor(message: string, errorCode: string);
}
declare class HttpError extends LibraryError {
    errorCode: number;
    constructor(message: string, errorCode: number);
}

declare const defaultProvider: Provider;

declare type StarkNetMerkleType = {
    name: string;
    type: 'merkletree';
    contains: string;
};
/**
 * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types.
 *
 * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712
 * standard.
 */
declare type StarkNetType = {
    name: string;
    type: string;
} | StarkNetMerkleType;
/**
 * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.
 */
interface StarkNetDomain extends Record<string, unknown> {
    name?: string;
    version?: string;
    chainId?: string | number;
}
/**
 * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.
 */
interface TypedData {
    types: Record<string, StarkNetType[]>;
    primaryType: string;
    domain: StarkNetDomain;
    message: Record<string, unknown>;
}

declare function prepareSelector(selector: string): string;
declare function isMerkleTreeType(type: StarkNetType): type is StarkNetMerkleType;
interface Context {
    parent?: string;
    key?: string;
}
/**
 * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once
 * in the resulting array.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {string[]} [dependencies]
 * @return {string[]}
 */
declare const getDependencies: (types: TypedData['types'], type: string, dependencies?: string[]) => string[];
/**
 * Encode a type to a string. All dependant types are alphabetically sorted.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {string}
 */
declare const encodeType: (types: TypedData['types'], type: string) => string;
/**
 * Get a type string as hash.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {string}
 */
declare const getTypeHash: (types: TypedData['types'], type: string) => string;
/**
 * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of
 * an array of ABI compatible types, and an array of corresponding values.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {any} data
 * @returns {[string, string]}
 */
declare const encodeValue: (types: TypedData['types'], type: string, data: unknown, ctx?: Context) => [string, string];
/**
 * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All
 * dependant types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 */
declare const encodeData: <T extends TypedData>(types: T["types"], type: string, data: T["message"]) => string[][];
/**
 * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant
 * types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 * @return {Buffer}
 */
declare const getStructHash: <T extends TypedData>(types: T["types"], type: string, data: T["message"]) => string;
/**
 * Get the EIP-191 encoded message to sign, from the typedData object.
 *
 * @param {TypedData} typedData
 * @param {BigNumberish} account
 * @return {string}
 */
declare const getMessageHash: (typedData: TypedData, account: BigNumberish) => string;

declare const index_prepareSelector: typeof prepareSelector;
declare const index_isMerkleTreeType: typeof isMerkleTreeType;
declare const index_getDependencies: typeof getDependencies;
declare const index_encodeType: typeof encodeType;
declare const index_getTypeHash: typeof getTypeHash;
declare const index_encodeValue: typeof encodeValue;
declare const index_encodeData: typeof encodeData;
declare const index_getStructHash: typeof getStructHash;
declare const index_getMessageHash: typeof getMessageHash;
type index_StarkNetMerkleType = StarkNetMerkleType;
type index_StarkNetType = StarkNetType;
type index_StarkNetDomain = StarkNetDomain;
type index_TypedData = TypedData;
declare namespace index {
  export {
    index_prepareSelector as prepareSelector,
    index_isMerkleTreeType as isMerkleTreeType,
    index_getDependencies as getDependencies,
    index_encodeType as encodeType,
    index_getTypeHash as getTypeHash,
    index_encodeValue as encodeValue,
    index_encodeData as encodeData,
    index_getStructHash as getStructHash,
    index_getMessageHash as getMessageHash,
    index_StarkNetMerkleType as StarkNetMerkleType,
    index_StarkNetType as StarkNetType,
    index_StarkNetDomain as StarkNetDomain,
    index_TypedData as TypedData,
  };
}

declare abstract class SignerInterface {
    /**
     * Method to get the public key of the signer
     *
     * @returns public key of signer as hex string with 0x prefix
     */
    abstract getPubKey(): Promise<string>;
    /**
     * Sign an JSON object for off-chain usage with the starknet private key and return the signature
     * This adds a message prefix so it cant be interchanged with transactions
     *
     * @param typedData - JSON object to be signed
     * @param accountAddress - account
     * @returns the signature of the JSON object
     * @throws {Error} if the JSON object is not a valid JSON
     */
    abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;
    /**
     * Signs a transaction with the starknet private key and returns the signature
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * @param abi (optional) the abi of the contract for better displaying
     *
     * @returns signature
     */
    abstract signTransaction(transactions: Call[], transactionsDetail: InvocationsSignerDetails, abis?: Abi[]): Promise<Signature>;
    /**
     * Signs a DEPLOY_ACCOUNT transaction with the starknet private key and returns the signature
     *
     * @param transaction
     * - contractAddress - the computed address of the contract
     * - constructorCalldata - calldata to be passed in deploy constructor
     * - addressSalt - contract address salt
     * - chainId - the chainId to declare contract on
     * - maxFee - maxFee for the declare transaction
     * - version - transaction version
     * - nonce - Nonce of the declare transaction
     * @returns signature
     */
    abstract signDeployAccountTransaction(transaction: DeployAccountSignerDetails): Promise<Signature>;
    /**
     * Signs a DECLARE transaction with the starknet private key and returns the signature
     *
     * @param transaction
     * - classHash - computed class hash. Will be replaced by ContractClass in future once class hash is present in CompiledContract
     * - senderAddress - the address of the sender
     * - chainId - the chainId to declare contract on
     * - maxFee - maxFee for the declare transaction
     * - version - transaction version
     * - nonce - Nonce of the declare transaction
     * @returns signature
     */
    abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;
}

declare class Signer implements SignerInterface {
    protected keyPair: KeyPair;
    constructor(keyPair?: KeyPair);
    getPubKey(): Promise<string>;
    signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;
    signTransaction(transactions: Call[], transactionsDetail: InvocationsSignerDetails, abis?: Abi[]): Promise<Signature>;
    signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce, }: DeployAccountSignerDetails): Promise<Signature>;
    signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce }: DeclareSignerDetails): Promise<Signature>;
}

declare abstract class AccountInterface extends ProviderInterface {
    abstract address: string;
    abstract signer: SignerInterface;
    /**
     * @deprecated Use estimateInvokeFee or estimateDeclareFee instead
     * Estimate Fee for executing an INVOKE transaction on starknet
     *
     * @param calls the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     *
     * @returns response from estimate_fee
     */
    abstract estimateFee(calls: AllowArray<Call>, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing an INVOKE transaction on starknet
     *
     * @param calls the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     *
     * @returns response from estimate_fee
     */
    abstract estimateInvokeFee(calls: AllowArray<Call>, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a DECLARE transaction on starknet
     *
     * @param contractPayload the payload object containing:
     * - contract - the compiled contract to be declared
     * - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli.
     *
     * @returns response from estimate_fee
     */
    abstract estimateDeclareFee(contractPayload: DeclareContractPayload, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet
     *
     * @param contractPayload -
     * - contract - the compiled contract to be deployed
     * - classHash - the class hash of the compiled contract. This can be obtained by using starknet-cli.
     * @param estimateFeeDetails -
     * - optional blockIdentifier
     * - constant nonce = 0
     * @returns response from estimate_fee
     */
    abstract estimateAccountDeployFee(contractPayload: DeployAccountContractPayload, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a UDC DEPLOY transaction on starknet
     * This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC)
     
    * @param deployContractPayload containing
     * - classHash: computed class hash of compiled contract
     * - salt: address salt
     * - unique: bool if true ensure unique salt
     * - calldata: constructor calldata
     *
     * @param transactionsDetail Invocation Details containing:
     *  - optional nonce
     *  - optional version
     *  - optional maxFee
     */
    abstract estimateDeployFee(deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], transactionsDetail?: InvocationsDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a list of transactions on starknet
     * Contract must be deployed for fee estimation to be possible
     *
     * @param transactions array of transaction object containing :
     * - type - the type of transaction : 'DECLARE' | 'DEPLOY' | 'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT'
     * - payload - the payload of the transaction
     *
     * @returns response from estimate_fee
     */
    abstract estimateFeeBulk(transactions: TransactionBulk, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponseBulk>;
    /**
     * Invoke execute function in account contract
     *
     * @param transactions the invocation object or an array of them, containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param abi (optional) the abi of the contract for better displaying
     *
     * @returns response from addTransaction
     */
    abstract execute(transactions: AllowArray<Call>, abis?: Abi[], transactionsDetail?: InvocationsDetails): Promise<InvokeFunctionResponse>;
    /**
     * Declares a given compiled contract (json) to starknet
     *
     * @param contractPayload transaction payload to be deployed containing:
    - contract: compiled contract code
    - classHash: computed class hash of compiled contract
     * @param transactionsDetail Invocation Details containing:
    - optional nonce
    - optional version
    - optional maxFee
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract declare(contractPayload: DeclareContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeclareContractResponse>;
    /**
     * Deploys a declared contract to starknet - using Universal Deployer Contract (UDC)
     * support multicall
     *
     * @param payload -
     * - classHash: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details -
     * - [nonce=getNonce]
     * - [version=transactionVersion]
     * - [maxFee=getSuggestedMaxFee]
     * @returns
     * - contract_address[]
     * - transaction_hash
     */
    abstract deploy(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails | undefined): Promise<MultiDeployContractResponse>;
    /**
     * Simplify deploy simulating old DeployContract with same response + UDC specific response
     * Internal wait for L2 transaction, support multicall
     *
     * @param payload -
     * - classHash: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details -
     * - [nonce=getNonce]
     * - [version=transactionVersion]
     * - [maxFee=getSuggestedMaxFee]
     * @returns
     *  - contract_address
     *  - transaction_hash
     *  - address
     *  - deployer
     *  - unique
     *  - classHash
     *  - calldata_len
     *  - calldata
     *  - salt
     */
    abstract deployContract(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails | undefined): Promise<DeployContractUDCResponse>;
    /**
     * Declares and Deploy a given compiled contract (json) to starknet using UDC
     * Internal wait for L2 transaction, do not support multicall
     *
     * @param  containing
     * - contract: compiled contract code
     * - classHash: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details
     * - [nonce=getNonce]
     * - [version=transactionVersion]
     * - [maxFee=getSuggestedMaxFee]
     * @returns
     * - declare
     *    - transaction_hash
     * - deploy
     *    - contract_address
     *    - transaction_hash
     *    - address
     *    - deployer
     *    - unique
     *    - classHash
     *    - calldata_len
     *    - calldata
     *    - salt
     */
    abstract declareDeploy(payload: DeclareDeployContractPayload, details?: InvocationsDetails | undefined): Promise<DeclareDeployUDCResponse>;
    /**
     * Deploy the account on Starknet
     *
     * @param contractPayload transaction payload to be deployed containing:
    - classHash: computed class hash of compiled contract
    - optional constructor calldata
    - optional address salt
    - optional contractAddress
     * @param transactionsDetail Invocation Details containing:
    - constant nonce = 0
    - optional version
    - optional maxFee
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract deployAccount(contractPayload: DeployAccountContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeployContractResponse>;
    /**
     * Sign an JSON object for off-chain usage with the starknet private key and return the signature
     * This adds a message prefix so it cant be interchanged with transactions
     *
     * @param json - JSON object to be signed
     * @returns the signature of the JSON object
     * @throws {Error} if the JSON object is not a valid JSON
     */
    abstract signMessage(typedData: TypedData): Promise<Signature>;
    /**
     * Hash a JSON object with pederson hash and return the hash
     * This adds a message prefix so it cant be interchanged with transactions
     *
     * @param json - JSON object to be hashed
     * @returns the hash of the JSON object
     * @throws {Error} if the JSON object is not a valid JSON
     */
    abstract hashMessage(typedData: TypedData): Promise<string>;
    /**
     * Verify a signature of a JSON object
     *
     * @param typedData - JSON object to be verified
     * @param signature - signature of the JSON object
     * @returns true if the signature is valid, false otherwise
     * @throws {Error} if the JSON object is not a valid JSON or the signature is not a valid signature
     */
    abstract verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;
    /**
     * Verify a signature of a given hash
     * @warning This method is not recommended, use verifyMessage instead
     *
     * @param hash - hash to be verified
     * @param signature - signature of the hash
     * @returns true if the signature is valid, false otherwise
     * @throws {Error} if the signature is not a valid signature
     */
    abstract verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;
    /**
     * Gets the nonce of the account with respect to a specific block
     *
     * @param  {BlockIdentifier} blockIdentifier - optional blockIdentifier. Defaults to 'pending'
     * @returns nonce of the account
     */
    abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    /**
     * Gets Suggested Max Fee based on the transaction type
     *
     * @param  {EstimateFeeAction} estimateFeeAction
     * @param  {EstimateFeeDetails} details
     * @returns suggestedMaxFee
     */
    abstract getSuggestedMaxFee(estimateFeeAction: EstimateFeeAction, details: EstimateFeeDetails): Promise<BigNumberish>;
    /**
     * Simulates the transaction and returns the transaction trace and estimated fee.
     *
     * @param calls the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     *
     * @returns response from estimate_fee
     */
    abstract simulateTransaction(calls: AllowArray<Call>, estimateFeeDetails?: EstimateFeeDetails): Promise<TransactionSimulation>;
}

declare class Account extends Provider implements AccountInterface {
    signer: SignerInterface;
    address: string;
    constructor(providerOrOptions: ProviderOptions | ProviderInterface, address: string, keyPairOrSigner: KeyPair | SignerInterface);
    getNonce(blockIdentifier?: BlockIdentifier): Promise<BigNumberish>;
    estimateFee(calls: AllowArray<Call>, estimateFeeDetails?: EstimateFeeDetails | undefined): Promise<EstimateFee>;
    estimateInvokeFee(calls: AllowArray<Call>, { nonce: providedNonce, blockIdentifier }?: EstimateFeeDetails): Promise<EstimateFee>;
    estimateDeclareFee({ classHash, contract }: DeclareContractPayload, { blockIdentifier, nonce: providedNonce }?: EstimateFeeDetails): Promise<EstimateFee>;
    estimateAccountDeployFee({ classHash, addressSalt, constructorCalldata, contractAddress: providedContractAddress, }: DeployAccountContractPayload, { blockIdentifier }?: EstimateFeeDetails): Promise<EstimateFee>;
    estimateDeployFee(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], transactionsDetail?: InvocationsDetails | undefined): Promise<EstimateFee>;
    estimateFeeBulk(transactions: TransactionBulk, { nonce: providedNonce, blockIdentifier }?: EstimateFeeDetails): Promise<EstimateFeeBulk>;
    buildInvocation(call: Array<Call>, signerDetails: InvocationsSignerDetails): Promise<Invocation>;
    execute(calls: AllowArray<Call>, abis?: Abi[] | undefined, transactionsDetail?: InvocationsDetails): Promise<InvokeFunctionResponse>;
    declare({ classHash, contract }: DeclareContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeclareContractResponse>;
    deploy(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails | undefined): Promise<MultiDeployContractResponse>;
    deployContract(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails | undefined): Promise<DeployContractUDCResponse>;
    declareDeploy(payload: DeclareDeployContractPayload, details?: InvocationsDetails | undefined): Promise<DeclareDeployUDCResponse>;
    deployAccount({ classHash, constructorCalldata, addressSalt, contractAddress: providedContractAddress, }: DeployAccountContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeployContractResponse>;
    signMessage(typedData: TypedData): Promise<Signature>;
    hashMessage(typedData: TypedData): Promise<string>;
    verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;
    verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;
    getSuggestedMaxFee({ type, payload }: EstimateFeeAction, details: EstimateFeeDetails): Promise<string>;
    buildDeclarePayload({ classHash, contract }: DeclareContractPayload, { nonce, chainId, version, walletAddress, maxFee }: InvocationsSignerDetails): Promise<DeclareContractTransaction>;
    buildAccountDeployPayload({ classHash, addressSalt, constructorCalldata, contractAddress: providedContractAddress, }: DeployAccountContractPayload, { nonce, chainId, version, maxFee }: InvocationsSignerDetails): Promise<DeployAccountContractTransaction>;
    buildUDCContractPayload(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]): Call[];
    simulateTransaction(calls: AllowArray<Call>, { nonce: providedNonce, blockIdentifier }?: EstimateFeeDetails): Promise<TransactionSimulation>;
    getStarkName(address?: BigNumberish, // default to the wallet address
    StarknetIdContract?: string): Promise<string>;
}

declare type CallOptions = {
    blockIdentifier?: BlockIdentifier;
};
declare abstract class ContractInterface {
    abstract abi: Abi;
    abstract address: string;
    abstract providerOrAccount: ProviderInterface | AccountInterface;
    abstract deployTransactionHash?: string;
    readonly functions: {
        [name: string]: AsyncContractFunction;
    };
    readonly callStatic: {
        [name: string]: AsyncContractFunction;
    };
    readonly populateTransaction: {
        [name: string]: ContractFunction;
    };
    readonly estimateFee: {
        [name: string]: ContractFunction;
    };
    readonly [key: string]: AsyncContractFunction | any;
    /**
     * Saves the address of the contract deployed on network that will be used for interaction
     *
     * @param address - address of the contract
     */
    abstract attach(address: string): void;
    /**
     * Attaches to new Provider or Account
     *
     * @param providerOrAccount - new Provider or Account to attach to
     */
    abstract connect(providerOrAccount: ProviderInterface | AccountInterface): void;
    /**
     * Resolves when contract is deployed on the network or when no deployment transaction is found
     *
     * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found
     * @throws When deployment fails
     */
    abstract deployed(): Promise<ContractInterface>;
    /**
     * Calls a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call
     * @param options optional blockIdentifier
     * @returns Result of the call as an array with key value pars
     */
    abstract call(method: string, args?: Array<any>, options?: CallOptions): Promise<Result>;
    /**
     * Invokes a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the invoke
     * @param options
     * @returns Add Transaction Response
     */
    abstract invoke(method: string, args?: Array<any>, options?: Overrides): Promise<InvokeFunctionResponse>;
    /**
     * Estimates a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call
     * @param options optional blockIdentifier
     */
    abstract estimate(method: string, args?: Array<any>, options?: {
        blockIdentifier?: BlockIdentifier;
    }): Promise<any>;
    /**
     * Calls a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call
     * @returns Invocation object
     */
    abstract populate(method: string, args?: Array<any>): Invocation;
}

declare class Contract implements ContractInterface {
    abi: Abi;
    address: string;
    providerOrAccount: ProviderInterface | AccountInterface;
    deployTransactionHash?: string;
    protected readonly structs: {
        [name: string]: StructAbi;
    };
    readonly functions: {
        [name: string]: AsyncContractFunction;
    };
    readonly callStatic: {
        [name: string]: AsyncContractFunction;
    };
    readonly populateTransaction: {
        [name: string]: ContractFunction;
    };
    readonly estimateFee: {
        [name: string]: ContractFunction;
    };
    readonly [key: string]: AsyncContractFunction | any;
    private checkCalldata;
    /**
     * Contract class to handle contract methods
     *
     * @param abi - Abi of the contract object
     * @param address (optional) - address to connect to
     * @param providerOrAccount (optional) - Provider or Account to attach to
     */
    constructor(abi: Abi, address: string, providerOrAccount?: ProviderInterface | AccountInterface);
    attach(address: string): void;
    connect(providerOrAccount: ProviderInterface | AccountInterface): void;
    deployed(): Promise<Contract>;
    call(method: string, args?: Array<any>, options?: CallOptions): Promise<Result>;
    invoke(method: string, args?: Array<any>, options?: Overrides): Promise<InvokeFunctionResponse>;
    estimate(method: string, args?: Array<any>): Promise<EstimateFeeResponse>;
    populate(method: string, args?: Array<any>): Call;
    /**
     * Parse of the response elements that are converted to Object (Struct) by using the abi
     *
     * @param responseIterator - iterator of the response
     * @param type - type of the struct
     * @return {BigNumberish | ParsedStruct} - parsed arguments in format that contract is expecting
     */
    protected parseResponseStruct(responseIterator: Iterator<string>, type: string): BigNumberish | ParsedStruct;
    /**
     * Parse elements of the response and structuring them into one field by using output property from the abi for that method
     *
     * @param responseIterator - iterator of the response
     * @param output  - output(field) information from the abi that will be used to parse the data
     * @return - parsed response corresponding to the abi structure of the field
     */
    protected parseResponseField(responseIterator: Iterator<string>, output: AbiEntry, parsedResult?: Args): any;
    /**
     * Parse elements of the response array and structuring them into response object
     *
     * @param method - method name
     * @param response  - response from the method
     * @return - parsed response corresponding to the abi
     */
    protected parseResponse(method: string, response: string[]): Result;
}

declare class ContractFactory {
    abi: Abi;
    compiledContract: CompiledContract;
    classHash: string;
    account: AccountInterface;
    private checkCalldata;
    constructor(compiledContract: CompiledContract, classHash: string, account: AccountInterface, abi?: Abi);
    /**
     * Deploys contract and returns new instance of the Contract
     *
     * @param args - Array of the constructor arguments for deployment
     * @param addressSalt (optional) - Address Salt for deployment
     * @returns deployed Contract
     */
    deploy(args?: Array<any>, addressSalt?: string | undefined): Promise<Contract>;
    /**
     * Attaches to new Provider or Account
     *
     * @param account - new Provider or Account to attach to
     * @returns ContractFactory
     */
    connect(account: AccountInterface): ContractFactory;
    /**
     * Attaches current abi and provider or account to the new address
     *
     * @param address - Contract address
     * @returns Contract
     */
    attach(address: string): Contract;
}

declare const transactionVersion = 1;
declare const feeTransactionVersion: BN__default;
declare function keccakBn(value: BigNumberish): string;
/**
 * Function to get the starknet keccak hash from a string
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L17-L22)
 * @param value - string you want to get the starknetKeccak hash from
 * @returns starknet keccak hash as BigNumber
 */
declare function starknetKeccak(value: string): BN__default;
/**
 * Function to get the hex selector from a given function name
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L25-L26)
 * @param funcName - selectors abi function name
 * @returns hex selector of given abi function name
 */
declare function getSelectorFromName(funcName: string): string;
/**
 * Function to get hex selector from function name, decimal string or hex string
 * @param value hex string | decimal string | string
 * @returns Hex selector
 */
declare function getSelector(value: string): string;
declare function pedersen(input: [BigNumberish, BigNumberish]): string;
declare function computeHashOnElements(data: BigNumberish[]): string;
declare function calculateTransactionHashCommon(txHashPrefix: TransactionHashPrefix, version: BigNumberish, contractAddress: BigNumberish, entryPointSelector: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, additionalData?: BigNumberish[]): string;
declare function calculateDeployTransactionHash(contractAddress: BigNumberish, constructorCalldata: BigNumberish[], version: BigNumberish, chainId: StarknetChainId): string;
declare function calculateDeclareTransactionHash(classHash: BigNumberish, senderAddress: BigNumberish, version: BigNumberish, maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string;
declare function calculateDeployAccountTransactionHash(contractAddress: BigNumberish, classHash: BigNumberish, constructorCalldata: BigNumberish[], salt: BigNumberish, version: BigNumberish, maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string;
declare function calculateTransactionHash(contractAddress: BigNumberish, version: BigNumberish, calldata: BigNumberish[], maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string;
declare function calculateContractAddressFromHash(salt: BigNumberish, classHash: BigNumberish, constructorCalldata: RawCalldata, deployerAddress: BigNumberish): string;

declare const hash_transactionVersion: typeof transactionVersion;
declare const hash_feeTransactionVersion: typeof feeTransactionVersion;
declare const hash_keccakBn: typeof keccakBn;
declare const hash_starknetKeccak: typeof starknetKeccak;
declare const hash_getSelectorFromName: typeof getSelectorFromName;
declare const hash_getSelector: typeof getSelector;
declare const hash_pedersen: typeof pedersen;
declare const hash_computeHashOnElements: typeof computeHashOnElements;
declare const hash_calculateTransactionHashCommon: typeof calculateTransactionHashCommon;
declare const hash_calculateDeployTransactionHash: typeof calculateDeployTransactionHash;
declare const hash_calculateDeclareTransactionHash: typeof calculateDeclareTransactionHash;
declare const hash_calculateDeployAccountTransactionHash: typeof calculateDeployAccountTransactionHash;
declare const hash_calculateTransactionHash: typeof calculateTransactionHash;
declare const hash_calculateContractAddressFromHash: typeof calculateContractAddressFromHash;
declare namespace hash {
  export {
    hash_transactionVersion as transactionVersion,
    hash_feeTransactionVersion as feeTransactionVersion,
    hash_keccakBn as keccakBn,
    hash_starknetKeccak as starknetKeccak,
    hash_getSelectorFromName as getSelectorFromName,
    hash_getSelector as getSelector,
    hash_pedersen as pedersen,
    hash_computeHashOnElements as computeHashOnElements,
    hash_calculateTransactionHashCommon as calculateTransactionHashCommon,
    hash_calculateDeployTransactionHash as calculateDeployTransactionHash,
    hash_calculateDeclareTransactionHash as calculateDeclareTransactionHash,
    hash_calculateDeployAccountTransactionHash as calculateDeployAccountTransactionHash,
    hash_calculateTransactionHash as calculateTransactionHash,
    hash_calculateContractAddressFromHash as calculateContractAddressFromHash,
  };
}

declare const parse: (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any;
declare const stringify: {
    (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
    (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
};
declare const parseAlwaysAsBig: (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any;
declare const stringifyAlwaysAsBig: {
    (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
    (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
};
declare const _default: {
    parse: (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any;
    stringify: {
        (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
        (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
    };
};

declare const json_parse: typeof parse;
declare const json_stringify: typeof stringify;
declare const json_parseAlwaysAsBig: typeof parseAlwaysAsBig;
declare const json_stringifyAlwaysAsBig: typeof stringifyAlwaysAsBig;
declare namespace json {
  export {
    _default as default,
    json_parse as parse,
    json_stringify as stringify,
    json_parseAlwaysAsBig as parseAlwaysAsBig,
    json_stringifyAlwaysAsBig as stringifyAlwaysAsBig,
  };
}

/**
 * Transforms a list of Calls, each with their own calldata, into
 * two arrays: one with the entrypoints, and one with the concatenated calldata.
 * @param calls
 * @returns
 */
declare const transformCallsToMulticallArrays: (calls: Call[]) => {
    callArray: ParsedStruct[];
    calldata: string[];
};
/**
 * Transforms a list of calls in the full flattened calldata expected
 * by the __execute__ protocol.
 * @param calls
 * @returns
 */
declare const fromCallsToExecuteCalldata: (calls: Call[]) => string[];
declare const fromCallsToExecuteCalldataWithNonce: (calls: Call[], nonce: BigNumberish) => string[];

declare const transaction_transformCallsToMulticallArrays: typeof transformCallsToMulticallArrays;
declare const transaction_fromCallsToExecuteCalldata: typeof fromCallsToExecuteCalldata;
declare const transaction_fromCallsToExecuteCalldataWithNonce: typeof fromCallsToExecuteCalldataWithNonce;
declare namespace transaction {
  export {
    transaction_transformCallsToMulticallArrays as transformCallsToMulticallArrays,
    transaction_fromCallsToExecuteCalldata as fromCallsToExecuteCalldata,
    transaction_fromCallsToExecuteCalldataWithNonce as fromCallsToExecuteCalldataWithNonce,
  };
}

/**
 * Function to compress compiled cairo program
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)
 * @param jsonProgram - json file representing the compiled cairo program
 * @returns Compressed cairo program
 */
declare function compressProgram(jsonProgram: Program | string): CompressedProgram;
declare function randomAddress(): string;
declare function makeAddress(input: string): string;
declare function formatSignature(sig?: Signature): string[];
declare function compileCalldata(args: RawArgs): Calldata;
declare function estimatedFeeToMaxFee(estimatedFee: BigNumberish, overhead?: number): BN__default;

declare const stark_compressProgram: typeof compressProgram;
declare const stark_randomAddress: typeof randomAddress;
declare const stark_makeAddress: typeof makeAddress;
declare const stark_formatSignature: typeof formatSignature;
declare const stark_compileCalldata: typeof compileCalldata;
declare const stark_estimatedFeeToMaxFee: typeof estimatedFeeToMaxFee;
declare namespace stark {
  export {
    stark_compressProgram as compressProgram,
    stark_randomAddress as randomAddress,
    stark_makeAddress as makeAddress,
    stark_formatSignature as formatSignature,
    stark_compileCalldata as compileCalldata,
    stark_estimatedFeeToMaxFee as estimatedFeeToMaxFee,
  };
}

declare class MerkleTree {
    leaves: string[];
    branches: string[][];
    root: string;
    constructor(leafHashes: string[]);
    private build;
    static hash(a: string, b: string): string;
    getProof(leaf: string, branch?: string[], hashPath?: string[]): string[];
}
declare function proofMerklePath(root: string, leaf: string, path: string[]): boolean;

type merkle_MerkleTree = MerkleTree;
declare const merkle_MerkleTree: typeof MerkleTree;
declare const merkle_proofMerklePath: typeof proofMerklePath;
declare namespace merkle {
  export {
    merkle_MerkleTree as MerkleTree,
    merkle_proofMerklePath as proofMerklePath,
  };
}

declare const ec: elliptic.ec;
declare const genKeyPair: (options?: elliptic.ec.GenKeyPairOptions | undefined) => elliptic.ec.KeyPair;
declare function getKeyPair(pk: BigNumberish): KeyPair;
declare function getStarkKey(keyPair: KeyPair): string;
/**
 * Takes a public key and casts it into `elliptic` KeyPair format.
 *
 * @param publicKey - public key which should get casted to a KeyPair
 * @returns keyPair with public key only, which can be used to verify signatures, but cant sign anything
 */
declare function getKeyPairFromPublicKey(publicKey: BigNumberish): KeyPair;
/**
 * Signs a message using the provided key.
 *
 * @param keyPair should be an KeyPair with a valid private key.
 * @returns an Signature.
 */
declare function sign(keyPair: KeyPair, msgHash: string): Signature;
/**
 * Verifies a message using the provided key.
 *
 * @param keyPair should be an KeyPair with a valid public key.
 * @param sig should be an Signature.
 * @returns true if the verification succeeds.
 */
declare function verify(keyPair: KeyPair | KeyPair[], msgHash: string, sig: Signature): boolean;

declare const ellipticCurve_ec: typeof ec;
declare const ellipticCurve_genKeyPair: typeof genKeyPair;
declare const ellipticCurve_getKeyPair: typeof getKeyPair;
declare const ellipticCurve_getStarkKey: typeof getStarkKey;
declare const ellipticCurve_getKeyPairFromPublicKey: typeof getKeyPairFromPublicKey;
declare const ellipticCurve_sign: typeof sign;
declare const ellipticCurve_verify: typeof verify;
declare namespace ellipticCurve {
  export {
    ellipticCurve_ec as ec,
    ellipticCurve_genKeyPair as genKeyPair,
    ellipticCurve_getKeyPair as getKeyPair,
    ellipticCurve_getStarkKey as getStarkKey,
    ellipticCurve_getKeyPairFromPublicKey as getKeyPairFromPublicKey,
    ellipticCurve_sign as sign,
    ellipticCurve_verify as verify,
  };
}

interface Uint256 {
    low: BigNumberish;
    high: BigNumberish;
}
declare function uint256ToBN(uint256: Uint256): BN;
declare const UINT_128_MAX: BN;
declare const UINT_256_MAX: BN;
declare function isUint256(bn: BigNumberish): boolean;
declare function bnToUint256(bignumber: BigNumberish): Uint256;

type uint256_Uint256 = Uint256;
declare const uint256_uint256ToBN: typeof uint256ToBN;
declare const uint256_UINT_128_MAX: typeof UINT_128_MAX;
declare const uint256_UINT_256_MAX: typeof UINT_256_MAX;
declare const uint256_isUint256: typeof isUint256;
declare const uint256_bnToUint256: typeof bnToUint256;
declare namespace uint256 {
  export {
    uint256_Uint256 as Uint256,
    uint256_uint256ToBN as uint256ToBN,
    uint256_UINT_128_MAX as UINT_128_MAX,
    uint256_UINT_256_MAX as UINT_256_MAX,
    uint256_isUint256 as isUint256,
    uint256_bnToUint256 as bnToUint256,
  };
}

declare function isASCII(str: string): boolean;
declare function isShortString(str: string): boolean;
declare function isDecimalString(decim: string): boolean;
/**
 * Convert an ASCII string to an hexadecimal string.
 * @param str - ASCII string -
 * 31 characters maxi. Ex : "uri/item23.jpg"
 * @returns a string representing an Hex number 248 bits max.
 * @Example
 * ```typescript
 * const myEncodedString: string = encodeShortString("uri/pict/t38.jpg");
 * ```
 * returns : string : "0x7572692f706963742f7433382e6a7067"
 */
declare function encodeShortString(str: string): string;
/**
 * Convert an hexadecimal or decimal string to an ASCII string.
 * @param str - string - representing a 248 bits max number.
 *
 * Ex : hex : "0x1A4F64EA56" or decimal : "236942575435676423"
 * @returns a string with 31 characters max.
 * @Example
 * ```typescript
 * const myDecodedString: string = decodeShortString("0x7572692f706963742f7433382e6a7067");
 * ```
 * return : string : "uri/pict/t38.jpg"
 */
declare function decodeShortString(str: string): string;

declare const shortString_isASCII: typeof isASCII;
declare const shortString_isShortString: typeof isShortString;
declare const shortString_isDecimalString: typeof isDecimalString;
declare const shortString_encodeShortString: typeof encodeShortString;
declare const shortString_decodeShortString: typeof decodeShortString;
declare namespace shortString {
  export {
    shortString_isASCII as isASCII,
    shortString_isShortString as isShortString,
    shortString_isDecimalString as isDecimalString,
    shortString_encodeShortString as encodeShortString,
    shortString_decodeShortString as decodeShortString,
  };
}

declare function addAddressPadding(address: BigNumberish): string;
declare function validateAndParseAddress(address: BigNumberish): string;
declare function getChecksumAddress(address: BigNumberish): string;
declare function validateChecksumAddress(address: string): boolean;

/**
 * Loosely validate a URL `string`.
 * @param {String} s
 * @return {Boolean}
 */
declare function isUrl(s?: string): boolean;
declare function buildUrl(baseUrl: string, defaultPath: string, urlOrPath?: string): string;

export { Abi, AbiEntry, Account, AccountInterface, AllowArray, Args, AsyncContractFunction, BlockNumber, BlockTag, Call, CallContractResponse, CallDetails, CallL1Handler, CallOptions, Calldata, CommonTransactionReceiptResponse, CommonTransactionResponse, CompiledContract, CompressedCompiledContract, CompressedProgram, Contract, ContractClass, ContractEntryPoint, ContractFactory, ContractFunction, ContractInterface, DeclareContractPayload, DeclareContractResponse, DeclareContractTransaction, DeclareDeployContractPayload, DeclareDeployUDCResponse, DeclareSignerDetails, DeclareTransactionReceiptResponse, DeclareTransactionResponse, DeployAccountContractPayload, DeployAccountContractTransaction, DeployAccountSignerDetails, DeployContractPayload, DeployContractResponse, DeployContractUDCResponse, DeployedContractItem, EntryPointType, EntryPointsByType, EstimateFee, EstimateFeeAction, EstimateFeeBulk, EstimateFeeDetails, EstimateFeeResponse, EstimateFeeResponseBulk, Event, ExecutionResources, FunctionAbi, FunctionInvocation, GatewayError, GetBlockResponse, GetCodeResponse, GetContractAddressesResponse, GetTransactionReceiptResponse, GetTransactionResponse, GetTransactionStatusResponse, HttpError, Invocation, InvocationBulk, InvocationsDetails, InvocationsDetailsWithNonce, InvocationsSignerDetails, InvokeFunctionResponse, InvokeTransactionReceiptResponse, InvokeTransactionResponse, KeyPair, LibraryError, MessageToL1, MessageToL2, MultiDeployContractResponse, Nonces, Overrides, ParsedStruct, Program, Provider, ProviderInterface, ProviderOptions, RPC, RawArgs, RawCalldata, Result, RpcProvider, RpcProviderOptions, Sequencer, SequencerIdentifier, SequencerProvider, SequencerProviderOptions, Signature, Signer, SignerInterface, StateDiffItem, StateUpdateResponse, Status, StorageDiffItem, Struct, StructAbi, TransactionBulk, TransactionSimulation, TransactionSimulationResponse, TransactionStatus, TransactionTraceResponse, TransactionType, UniversalDeployerContractPayload, addAddressPadding, buildUrl, constants, defaultProvider, ellipticCurve as ec, encode, getChecksumAddress, hash, isUrl, json, merkle, number, shortString, stark, transaction, index as typedData, uint256, validateAndParseAddress, validateChecksumAddress };
