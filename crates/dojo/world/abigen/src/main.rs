//! Programs that generates the bindings for World and Model contracts.
//!
//! The bindings are generated by cainome and outputted in rust modules
//! to be imported by downstream crates.
//!
//! Usage:
//! `cargo run -r -p dojo-abigen` form the workspace root to generate the bindings.
//! Don't forget the `-r` flag to run the program in release mode as Scarb is very slow
//! in debug mode.
//!
//! To check if the bindings are up to date, run `cargo run -p dojo-abigen -- --check`.
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use std::process::Command;

use anyhow::{anyhow, Result};
use cainome::rs::Abigen;
use camino::Utf8PathBuf;
use scarb::core::{Config, TargetKind};
use scarb::ops::{CompileOpts, FeaturesOpts, FeaturesSelector};

const SCARB_MANIFEST: &str = "crates/dojo/core/Scarb.toml";
const WORLD_ARTIFACT: &str = "crates/dojo/core/target/dev/dojo_world.contract_class.json";
const MODEL_ARTIFACT: &str =
    "crates/dojo/core/target/dev/dojo_resource_metadata.contract_class.json";
const OUT_DIR: &str = "crates/dojo/world/src/contracts/abigen";

/// Entrypoint for the abigen program to generate or check the bindings for the world and model
/// contracts.
fn main() -> Result<()> {
    let is_check_only = define_check_only();

    compile_dojo_core()?;

    generate_bindings("WorldContract", WORLD_ARTIFACT, "world.rs", is_check_only)?;
    generate_bindings("ModelContract", MODEL_ARTIFACT, "model.rs", is_check_only)?;

    Ok(())
}

/// Returns true if the bindings should be generated, false if the bindings should be checked only.
fn define_check_only() -> bool {
    let args: Vec<_> = std::env::args().collect();

    args.len() > 1 && args[1] == "--check"
}

/// Generates the bindings for the given contracts, or verifies
/// if the bindings are up to date.
///
/// # Arguments
///
/// * `contract_name` - The name of the contract to generate bindings for.
/// * `contract_artifact_path` - The path to the contract artifact.
/// * `bindings_filename` - The name of the file to write the bindings to.
/// * `is_check_only` - Whether to check if the bindings are up to date or generate them.
fn generate_bindings(
    contract_name: &str,
    contract_artifact_path: &str,
    bindings_filename: &str,
    is_check_only: bool,
) -> Result<()> {
    // Use a temporary file to avoid conflicts with other bindings and comparing
    // the bindings with the existing file in case of check only mode.
    let tmp_file = format!("/tmp/{contract_name}.rs");

    let abigen = Abigen::new(contract_name, contract_artifact_path)
        .with_types_aliases(HashMap::from([(
            String::from("dojo::world::config::Config::Event"),
            String::from("DojoConfigEvent"),
        )]))
        .with_derives(vec![
            String::from("Clone"),
            String::from("serde::Serialize"),
            String::from("serde::Deserialize"),
            String::from("PartialEq"),
            String::from("Debug"),
        ])
        .with_contract_derives(vec![String::from("Debug")]);

    abigen.generate()?.write_to_file(&tmp_file)?;

    // The formatting is not the same we need nighty.
    Command::new("rustfmt")
        .arg("+nightly-2024-08-28")
        .arg(&tmp_file)
        .status()
        .expect("Failed to run rustfmt on generated bindings");

    let out_path = format!("{OUT_DIR}/{bindings_filename}");

    if is_check_only {
        let generated_bindings = fs::read_to_string(tmp_file)?;

        if Path::new(&out_path).exists() {
            let tmp_e_file = "/tmp/existing_bindings.rs";

            let existing_bindings = fs::read_to_string(out_path)?;
            fs::write(tmp_e_file, existing_bindings.clone())?;

            Command::new("rustfmt")
                .arg("+nightly-2024-08-28")
                .arg(tmp_e_file)
                .status()
                .expect("Failed to run rustfmt on generated bindings");

            let existing_bindings =
                fs::read_to_string(tmp_e_file)?.replace(char::is_whitespace, "");

            let mut first_diff_index = None;
            for (i, (existing_char, generated_char)) in
                existing_bindings.chars().zip(generated_bindings.chars()).enumerate()
            {
                if existing_char != generated_char {
                    first_diff_index = Some(i);
                    break;
                }
            }

            if let Some(index) = first_diff_index {
                println!("First differing character is at index: {}", index);
            } else {
                println!("No differing characters found.");
            }

            if existing_bindings != generated_bindings {
                return Err(anyhow!(
                    "{contract_name} ABI bindings are not up to date. Consider generating them \
                     running `cargo run -p dojo-abigen`.",
                ));
            }
        } else {
            return Err(anyhow!("No bindings found for {contract_name}, expected at {out_path}."));
        }
    } else {
        // Rename the temporary file to the output file is enough to update the bindings.
        rename_file(&tmp_file, &out_path)?;
    }

    Ok(())
}

/// Renames a file from the old path to the new path.
///
/// # Arguments
///
/// * `old_path` - The path to the file to rename.
/// * `new_path` - The new path to rename the file to.
fn rename_file(old_path: &str, new_path: &str) -> Result<()> {
    let o = Path::new(old_path);
    let n = Path::new(new_path);
    Ok(fs::rename(o, n)?)
}

/// Compiles dojo-core contracts programatically using Scarb.
fn compile_dojo_core() -> Result<()> {
    let path = Utf8PathBuf::from(SCARB_MANIFEST);
    let config = Config::builder(path.canonicalize_utf8()?).build()?;
    let ws = scarb::ops::read_workspace(config.manifest_path(), &config)?;
    let packages = ws.members().map(|p| p.id).collect();

    let features_opts =
        FeaturesOpts { features: FeaturesSelector::AllFeatures, no_default_features: false };

    scarb::ops::compile(
        packages,
        CompileOpts {
            include_target_names: vec![],
            include_target_kinds: vec![],
            exclude_target_kinds: vec![TargetKind::TEST],
            features: features_opts,
        },
        &ws,
    )
}
