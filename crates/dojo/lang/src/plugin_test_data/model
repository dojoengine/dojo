//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > test_id
model

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}
impl Modelv0Introspect<> of dojo::meta::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::meta::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::meta::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct Modelv0Entity {
    __id: felt252, // private field
    pub v: Vec3,

} 

type Modelv0KeyType = felt252;

pub impl Modelv0KeyParser of dojo::model::model::KeyParser<Modelv0, Modelv0KeyType>{
    #[inline(always)]
    fn parse_key(self: @Modelv0) -> Modelv0KeyType {
        *self.id
    }
}

impl Modelv0EntityKey of dojo::model::entity::EntityKey<Modelv0Entity, Modelv0KeyType> {
}

// Impl to get the static definition of a model
pub mod modelv_0_definition {
    use super::Modelv0;
    pub impl Modelv0DefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "Modelv0"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-Modelv0"
        }

        #[inline(always)]
        fn version() -> u8 {
            0
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            "Modelv0"
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            2212879130471315306779111820244908968466545702031328551192231795237740448313
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<Modelv0>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<Modelv0>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<Modelv0>::size()
        }
    }
    
}


pub impl Modelv0Definition = modelv_0_definition::Modelv0DefinitionImpl<Modelv0>;
pub impl Modelv0EntityDefinition = modelv_0_definition::Modelv0DefinitionImpl<Modelv0Entity>;

pub impl Modelv0ModelParser of dojo::model::model::ModelParser<Modelv0>{
    fn serialize_keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl Modelv0EntityParser of dojo::model::entity::EntityParser<Modelv0Entity>{
    fn parse_id(self: @Modelv0Entity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @Modelv0Entity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl Modelv0ModelImpl = dojo::model::model::ModelImpl<Modelv0>;
pub impl Modelv0Store = dojo::model::model::ModelStoreImpl<Modelv0>;

pub impl Modelv0EntityImpl = dojo::model::entity::EntityImpl<Modelv0Entity>;
pub impl Modelv0EntityStore = dojo::model::entity::EntityStoreImpl<Modelv0Entity>;


#[generate_trait]
pub impl Modelv0MembersStoreImpl of Modelv0MembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: Modelv0KeyType) -> Vec3 {
        Modelv0Store::get_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        Modelv0EntityStore::get_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn update_v(self: dojo::world::IWorldDispatcher, key: Modelv0KeyType, value: Vec3) {
        Modelv0Store::update_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3) {
        Modelv0EntityStore::update_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }


}


#[starknet::interface]
pub trait IModelv0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
pub mod modelv_0 {
    use super::Modelv0;
    use super::IModelv0;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, Modelv0>;

    #[abi(embed_v0)]
    impl Modelv0Impl of IModelv0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__Modelv0Impl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Modelv0>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    Modelv0Impl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__Modelv0Impl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::meta::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::meta::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::meta::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithBadNamespaceFormatEntity {
    __id: felt252, // private field
    pub v: Vec3,

} 

type ModelWithBadNamespaceFormatKeyType = felt252;

pub impl ModelWithBadNamespaceFormatKeyParser of dojo::model::model::KeyParser<ModelWithBadNamespaceFormat, ModelWithBadNamespaceFormatKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithBadNamespaceFormat) -> ModelWithBadNamespaceFormatKeyType {
        *self.id
    }
}

impl ModelWithBadNamespaceFormatEntityKey of dojo::model::entity::EntityKey<ModelWithBadNamespaceFormatEntity, ModelWithBadNamespaceFormatKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_bad_namespace_format_definition {
    use super::ModelWithBadNamespaceFormat;
    pub impl ModelWithBadNamespaceFormatDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithBadNamespaceFormat"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "MyNamespace"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "MyNamespace-ModelWithBadNamespaceFormat"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            3498075185010572568869958326439183660947774785526793544998939163671395407352
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            513559242384681567568052881519197161166285694153303371154270254637843894159
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            2518247443458975119180817677753479732439290689944304814934908400279022945373
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithBadNamespaceFormat>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithBadNamespaceFormat>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithBadNamespaceFormat>::size()
        }
    }
    
}


pub impl ModelWithBadNamespaceFormatDefinition = model_with_bad_namespace_format_definition::ModelWithBadNamespaceFormatDefinitionImpl<ModelWithBadNamespaceFormat>;
pub impl ModelWithBadNamespaceFormatEntityDefinition = model_with_bad_namespace_format_definition::ModelWithBadNamespaceFormatDefinitionImpl<ModelWithBadNamespaceFormatEntity>;

pub impl ModelWithBadNamespaceFormatModelParser of dojo::model::model::ModelParser<ModelWithBadNamespaceFormat>{
    fn serialize_keys(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithBadNamespaceFormatEntityParser of dojo::model::entity::EntityParser<ModelWithBadNamespaceFormatEntity>{
    fn parse_id(self: @ModelWithBadNamespaceFormatEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithBadNamespaceFormatEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithBadNamespaceFormatModelImpl = dojo::model::model::ModelImpl<ModelWithBadNamespaceFormat>;
pub impl ModelWithBadNamespaceFormatStore = dojo::model::model::ModelStoreImpl<ModelWithBadNamespaceFormat>;

pub impl ModelWithBadNamespaceFormatEntityImpl = dojo::model::entity::EntityImpl<ModelWithBadNamespaceFormatEntity>;
pub impl ModelWithBadNamespaceFormatEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithBadNamespaceFormatEntity>;


#[generate_trait]
pub impl ModelWithBadNamespaceFormatMembersStoreImpl of ModelWithBadNamespaceFormatMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithBadNamespaceFormatKeyType) -> Vec3 {
        ModelWithBadNamespaceFormatStore::get_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        ModelWithBadNamespaceFormatEntityStore::get_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithBadNamespaceFormatKeyType, value: Vec3) {
        ModelWithBadNamespaceFormatStore::update_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3) {
        ModelWithBadNamespaceFormatEntityStore::update_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }


}


#[starknet::interface]
pub trait IModelWithBadNamespaceFormat<T> {
    fn ensure_abi(self: @T, model: ModelWithBadNamespaceFormat);
}

#[starknet::contract]
pub mod model_with_bad_namespace_format {
    use super::ModelWithBadNamespaceFormat;
    use super::IModelWithBadNamespaceFormat;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithBadNamespaceFormat>;

    #[abi(embed_v0)]
    impl ModelWithBadNamespaceFormatImpl of IModelWithBadNamespaceFormat<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithBadNamespaceFormat) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithBadNamespaceFormatImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithBadNamespaceFormatImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithBadNamespaceFormatImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::meta::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::meta::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::meta::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithShortStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

} 

type ModelWithShortStringNamespaceKeyType = felt252;

pub impl ModelWithShortStringNamespaceKeyParser of dojo::model::model::KeyParser<ModelWithShortStringNamespace, ModelWithShortStringNamespaceKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithShortStringNamespace) -> ModelWithShortStringNamespaceKeyType {
        *self.id
    }
}

impl ModelWithShortStringNamespaceEntityKey of dojo::model::entity::EntityKey<ModelWithShortStringNamespaceEntity, ModelWithShortStringNamespaceKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_short_string_namespace_definition {
    use super::ModelWithShortStringNamespace;
    pub impl ModelWithShortStringNamespaceDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithShortStringNamespace"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "my_namespace"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "my_namespace-ModelWithShortStringNamespace"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            643350075018191729855964658181798951445581630505240307235771395728709379388
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            4646597166239297873853881466258165424425132957303541470648153031188639878
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1685136890688416384941629523783652800960468745356230625531475538826800548713
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithShortStringNamespace>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithShortStringNamespace>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithShortStringNamespace>::size()
        }
    }
    
}


pub impl ModelWithShortStringNamespaceDefinition = model_with_short_string_namespace_definition::ModelWithShortStringNamespaceDefinitionImpl<ModelWithShortStringNamespace>;
pub impl ModelWithShortStringNamespaceEntityDefinition = model_with_short_string_namespace_definition::ModelWithShortStringNamespaceDefinitionImpl<ModelWithShortStringNamespaceEntity>;

pub impl ModelWithShortStringNamespaceModelParser of dojo::model::model::ModelParser<ModelWithShortStringNamespace>{
    fn serialize_keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithShortStringNamespaceEntityParser of dojo::model::entity::EntityParser<ModelWithShortStringNamespaceEntity>{
    fn parse_id(self: @ModelWithShortStringNamespaceEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithShortStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithShortStringNamespaceModelImpl = dojo::model::model::ModelImpl<ModelWithShortStringNamespace>;
pub impl ModelWithShortStringNamespaceStore = dojo::model::model::ModelStoreImpl<ModelWithShortStringNamespace>;

pub impl ModelWithShortStringNamespaceEntityImpl = dojo::model::entity::EntityImpl<ModelWithShortStringNamespaceEntity>;
pub impl ModelWithShortStringNamespaceEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithShortStringNamespaceEntity>;


#[generate_trait]
pub impl ModelWithShortStringNamespaceMembersStoreImpl of ModelWithShortStringNamespaceMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithShortStringNamespaceKeyType) -> Vec3 {
        ModelWithShortStringNamespaceStore::get_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        ModelWithShortStringNamespaceEntityStore::get_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithShortStringNamespaceKeyType, value: Vec3) {
        ModelWithShortStringNamespaceStore::update_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3) {
        ModelWithShortStringNamespaceEntityStore::update_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }


}


#[starknet::interface]
pub trait IModelWithShortStringNamespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
pub mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::IModelWithShortStringNamespace;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithShortStringNamespace>;

    #[abi(embed_v0)]
    impl ModelWithShortStringNamespaceImpl of IModelWithShortStringNamespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithShortStringNamespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithShortStringNamespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithShortStringNamespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithStringNamespaceIntrospect<> of dojo::meta::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::meta::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::meta::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

} 

type ModelWithStringNamespaceKeyType = felt252;

pub impl ModelWithStringNamespaceKeyParser of dojo::model::model::KeyParser<ModelWithStringNamespace, ModelWithStringNamespaceKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithStringNamespace) -> ModelWithStringNamespaceKeyType {
        *self.id
    }
}

impl ModelWithStringNamespaceEntityKey of dojo::model::entity::EntityKey<ModelWithStringNamespaceEntity, ModelWithStringNamespaceKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_string_namespace_definition {
    use super::ModelWithStringNamespace;
    pub impl ModelWithStringNamespaceDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithStringNamespace"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "my_namespace"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "my_namespace-ModelWithStringNamespace"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            2567055065785696374111447326195815858786390804996225951953791904194802101726
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            36187013840655350498900857372670392628596870210415176261336407419317644423
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1685136890688416384941629523783652800960468745356230625531475538826800548713
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithStringNamespace>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithStringNamespace>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithStringNamespace>::size()
        }
    }
    
}


pub impl ModelWithStringNamespaceDefinition = model_with_string_namespace_definition::ModelWithStringNamespaceDefinitionImpl<ModelWithStringNamespace>;
pub impl ModelWithStringNamespaceEntityDefinition = model_with_string_namespace_definition::ModelWithStringNamespaceDefinitionImpl<ModelWithStringNamespaceEntity>;

pub impl ModelWithStringNamespaceModelParser of dojo::model::model::ModelParser<ModelWithStringNamespace>{
    fn serialize_keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithStringNamespaceEntityParser of dojo::model::entity::EntityParser<ModelWithStringNamespaceEntity>{
    fn parse_id(self: @ModelWithStringNamespaceEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithStringNamespaceModelImpl = dojo::model::model::ModelImpl<ModelWithStringNamespace>;
pub impl ModelWithStringNamespaceStore = dojo::model::model::ModelStoreImpl<ModelWithStringNamespace>;

pub impl ModelWithStringNamespaceEntityImpl = dojo::model::entity::EntityImpl<ModelWithStringNamespaceEntity>;
pub impl ModelWithStringNamespaceEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithStringNamespaceEntity>;


#[generate_trait]
pub impl ModelWithStringNamespaceMembersStoreImpl of ModelWithStringNamespaceMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithStringNamespaceKeyType) -> Vec3 {
        ModelWithStringNamespaceStore::get_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        ModelWithStringNamespaceEntityStore::get_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithStringNamespaceKeyType, value: Vec3) {
        ModelWithStringNamespaceStore::update_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3) {
        ModelWithStringNamespaceEntityStore::update_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }


}


#[starknet::interface]
pub trait IModelWithStringNamespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
pub mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::IModelWithStringNamespace;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithStringNamespace>;

    #[abi(embed_v0)]
    impl ModelWithStringNamespaceImpl of IModelWithStringNamespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithStringNamespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithStringNamespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithStringNamespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl PositionIntrospect<> of dojo::meta::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::meta::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::meta::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct PositionEntity {
    __id: felt252, // private field
    pub v: Vec3,

} 

type PositionKeyType = felt252;

pub impl PositionKeyParser of dojo::model::model::KeyParser<Position, PositionKeyType>{
    #[inline(always)]
    fn parse_key(self: @Position) -> PositionKeyType {
        *self.id
    }
}

impl PositionEntityKey of dojo::model::entity::EntityKey<PositionEntity, PositionKeyType> {
}

// Impl to get the static definition of a model
pub mod position_definition {
    use super::Position;
    pub impl PositionDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "Position"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-Position"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            1782729361185285637005619480739442196364037716000358448825261820703351159758
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            2899920299641094436341712346886623904698864491830316325765258522168980161362
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<Position>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<Position>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<Position>::size()
        }
    }
    
}


pub impl PositionDefinition = position_definition::PositionDefinitionImpl<Position>;
pub impl PositionEntityDefinition = position_definition::PositionDefinitionImpl<PositionEntity>;

pub impl PositionModelParser of dojo::model::model::ModelParser<Position>{
    fn serialize_keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl PositionEntityParser of dojo::model::entity::EntityParser<PositionEntity>{
    fn parse_id(self: @PositionEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @PositionEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl PositionModelImpl = dojo::model::model::ModelImpl<Position>;
pub impl PositionStore = dojo::model::model::ModelStoreImpl<Position>;

pub impl PositionEntityImpl = dojo::model::entity::EntityImpl<PositionEntity>;
pub impl PositionEntityStore = dojo::model::entity::EntityStoreImpl<PositionEntity>;


#[generate_trait]
pub impl PositionMembersStoreImpl of PositionMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: PositionKeyType) -> Vec3 {
        PositionStore::get_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        PositionEntityStore::get_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080)
    }

    fn update_v(self: dojo::world::IWorldDispatcher, key: PositionKeyType, value: Vec3) {
        PositionStore::update_member(self, key, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3) {
        PositionEntityStore::update_member_from_id(self, entity_id, 578691550836206188651404750433984985630363913126316857592149308417275000080, value);
    }


}


#[starknet::interface]
pub trait IPosition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
pub mod position {
    use super::Position;
    use super::IPosition;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, Position>;

    #[abi(embed_v0)]
    impl PositionImpl of IPosition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__PositionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Position>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    PositionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__PositionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl PlayerIntrospect<> of dojo::meta::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::meta::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        },
dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct PlayerEntity {
    __id: felt252, // private field
    pub name: felt252,

} 

type PlayerKeyType = (felt252, ContractAddress);

pub impl PlayerKeyParser of dojo::model::model::KeyParser<Player, PlayerKeyType>{
    #[inline(always)]
    fn parse_key(self: @Player) -> PlayerKeyType {
        (*self.game, *self.player)
    }
}

impl PlayerEntityKey of dojo::model::entity::EntityKey<PlayerEntity, PlayerKeyType> {
}

// Impl to get the static definition of a model
pub mod player_definition {
    use super::Player;
    pub impl PlayerDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "Player"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-Player"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            32472305970791489884889070587064570056671760620943135506258424375410423946
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            1073075359926275415180704315933677548333097210683379121732618306925003101845
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<Player>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<Player>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<Player>::size()
        }
    }
    
}


pub impl PlayerDefinition = player_definition::PlayerDefinitionImpl<Player>;
pub impl PlayerEntityDefinition = player_definition::PlayerDefinitionImpl<PlayerEntity>;

pub impl PlayerModelParser of dojo::model::model::ModelParser<Player>{
    fn serialize_keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.game, ref serialized);
core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.name, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl PlayerEntityParser of dojo::model::entity::EntityParser<PlayerEntity>{
    fn parse_id(self: @PlayerEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @PlayerEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.name, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl PlayerModelImpl = dojo::model::model::ModelImpl<Player>;
pub impl PlayerStore = dojo::model::model::ModelStoreImpl<Player>;

pub impl PlayerEntityImpl = dojo::model::entity::EntityImpl<PlayerEntity>;
pub impl PlayerEntityStore = dojo::model::entity::EntityStoreImpl<PlayerEntity>;


#[generate_trait]
pub impl PlayerMembersStoreImpl of PlayerMembersStore {
    fn get_name(self: @dojo::world::IWorldDispatcher, key: PlayerKeyType) -> felt252 {
        PlayerStore::get_member(self, key, 1528802474226268325865027367859591458315299653151958663884057507666229546336)
    }

    fn get_name_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252 {
        PlayerEntityStore::get_member_from_id(self, entity_id, 1528802474226268325865027367859591458315299653151958663884057507666229546336)
    }

    fn update_name(self: dojo::world::IWorldDispatcher, key: PlayerKeyType, value: felt252) {
        PlayerStore::update_member(self, key, 1528802474226268325865027367859591458315299653151958663884057507666229546336, value);
    }

    fn update_name_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: felt252) {
        PlayerEntityStore::update_member_from_id(self, entity_id, 1528802474226268325865027367859591458315299653151958663884057507666229546336, value);
    }


}


#[starknet::interface]
pub trait IPlayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
pub mod player {
    use super::Player;
    use super::IPlayer;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, Player>;

    #[abi(embed_v0)]
    impl PlayerImpl of IPlayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__PlayerImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Player>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    PlayerImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__PlayerImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithSimpleArrayIntrospect<> of dojo::meta::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::meta::introspect::Introspect::<u16>::layout()
                },
dojo::meta::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::meta::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<u16>::ty()
        },
dojo::meta::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Ty::Array(
                array![
                dojo::meta::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithSimpleArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<u8>,

} 

type ModelWithSimpleArrayKeyType = ContractAddress;

pub impl ModelWithSimpleArrayKeyParser of dojo::model::model::KeyParser<ModelWithSimpleArray, ModelWithSimpleArrayKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithSimpleArray) -> ModelWithSimpleArrayKeyType {
        *self.player
    }
}

impl ModelWithSimpleArrayEntityKey of dojo::model::entity::EntityKey<ModelWithSimpleArrayEntity, ModelWithSimpleArrayKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_simple_array_definition {
    use super::ModelWithSimpleArray;
    pub impl ModelWithSimpleArrayDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithSimpleArray"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-ModelWithSimpleArray"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            2155888289741706273257207428305937938996511115291276975807216945184181752777
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            173141902001925402715103859951360389436088950156916962046507357841237663931
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithSimpleArray>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithSimpleArray>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithSimpleArray>::size()
        }
    }
    
}


pub impl ModelWithSimpleArrayDefinition = model_with_simple_array_definition::ModelWithSimpleArrayDefinitionImpl<ModelWithSimpleArray>;
pub impl ModelWithSimpleArrayEntityDefinition = model_with_simple_array_definition::ModelWithSimpleArrayDefinitionImpl<ModelWithSimpleArrayEntity>;

pub impl ModelWithSimpleArrayModelParser of dojo::model::model::ModelParser<ModelWithSimpleArray>{
    fn serialize_keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithSimpleArrayEntityParser of dojo::model::entity::EntityParser<ModelWithSimpleArrayEntity>{
    fn parse_id(self: @ModelWithSimpleArrayEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithSimpleArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithSimpleArrayModelImpl = dojo::model::model::ModelImpl<ModelWithSimpleArray>;
pub impl ModelWithSimpleArrayStore = dojo::model::model::ModelStoreImpl<ModelWithSimpleArray>;

pub impl ModelWithSimpleArrayEntityImpl = dojo::model::entity::EntityImpl<ModelWithSimpleArrayEntity>;
pub impl ModelWithSimpleArrayEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithSimpleArrayEntity>;


#[generate_trait]
pub impl ModelWithSimpleArrayMembersStoreImpl of ModelWithSimpleArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType) -> u16 {
        ModelWithSimpleArrayStore::get_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        ModelWithSimpleArrayEntityStore::get_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType, value: u16) {
        ModelWithSimpleArrayStore::update_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16) {
        ModelWithSimpleArrayEntityStore::update_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType) -> Array<u8> {
        ModelWithSimpleArrayStore::get_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8> {
        ModelWithSimpleArrayEntityStore::get_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType, value: Array<u8>) {
        ModelWithSimpleArrayStore::update_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Array<u8>) {
        ModelWithSimpleArrayEntityStore::update_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }


}


#[starknet::interface]
pub trait IModelWithSimpleArray<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
pub mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::IModelWithSimpleArray;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithSimpleArray>;

    #[abi(embed_v0)]
    impl ModelWithSimpleArrayImpl of IModelWithSimpleArray<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithSimpleArrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithSimpleArrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithSimpleArrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithByteArrayIntrospect<> of dojo::meta::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::meta::introspect::Introspect::<u16>::layout()
                },
dojo::meta::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::meta::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<u16>::ty()
        },
dojo::meta::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithByteArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: ByteArray,

} 

type ModelWithByteArrayKeyType = ContractAddress;

pub impl ModelWithByteArrayKeyParser of dojo::model::model::KeyParser<ModelWithByteArray, ModelWithByteArrayKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithByteArray) -> ModelWithByteArrayKeyType {
        *self.player
    }
}

impl ModelWithByteArrayEntityKey of dojo::model::entity::EntityKey<ModelWithByteArrayEntity, ModelWithByteArrayKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_byte_array_definition {
    use super::ModelWithByteArray;
    pub impl ModelWithByteArrayDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithByteArray"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-ModelWithByteArray"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            2309493726682581230048608406375650493303358263694405202817326852234706548038
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            2176409715042145900636260236501596599545103472111273072320531220776338338674
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithByteArray>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithByteArray>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithByteArray>::size()
        }
    }
    
}


pub impl ModelWithByteArrayDefinition = model_with_byte_array_definition::ModelWithByteArrayDefinitionImpl<ModelWithByteArray>;
pub impl ModelWithByteArrayEntityDefinition = model_with_byte_array_definition::ModelWithByteArrayDefinitionImpl<ModelWithByteArrayEntity>;

pub impl ModelWithByteArrayModelParser of dojo::model::model::ModelParser<ModelWithByteArray>{
    fn serialize_keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithByteArrayEntityParser of dojo::model::entity::EntityParser<ModelWithByteArrayEntity>{
    fn parse_id(self: @ModelWithByteArrayEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithByteArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithByteArrayModelImpl = dojo::model::model::ModelImpl<ModelWithByteArray>;
pub impl ModelWithByteArrayStore = dojo::model::model::ModelStoreImpl<ModelWithByteArray>;

pub impl ModelWithByteArrayEntityImpl = dojo::model::entity::EntityImpl<ModelWithByteArrayEntity>;
pub impl ModelWithByteArrayEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithByteArrayEntity>;


#[generate_trait]
pub impl ModelWithByteArrayMembersStoreImpl of ModelWithByteArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType) -> u16 {
        ModelWithByteArrayStore::get_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        ModelWithByteArrayEntityStore::get_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType, value: u16) {
        ModelWithByteArrayStore::update_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16) {
        ModelWithByteArrayEntityStore::update_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType) -> ByteArray {
        ModelWithByteArrayStore::get_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray {
        ModelWithByteArrayEntityStore::get_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType, value: ByteArray) {
        ModelWithByteArrayStore::update_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: ByteArray) {
        ModelWithByteArrayEntityStore::update_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }


}


#[starknet::interface]
pub trait IModelWithByteArray<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
pub mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::IModelWithByteArray;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithByteArray>;

    #[abi(embed_v0)]
    impl ModelWithByteArrayImpl of IModelWithByteArray<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithByteArrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithByteArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithByteArrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithByteArrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithComplexArrayIntrospect<> of dojo::meta::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::meta::introspect::Introspect::<u16>::layout()
                },
dojo::meta::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::meta::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<u16>::ty()
        },
dojo::meta::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Ty::Array(
                array![
                dojo::meta::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithComplexArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<Vec3>,

} 

type ModelWithComplexArrayKeyType = ContractAddress;

pub impl ModelWithComplexArrayKeyParser of dojo::model::model::KeyParser<ModelWithComplexArray, ModelWithComplexArrayKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithComplexArray) -> ModelWithComplexArrayKeyType {
        *self.player
    }
}

impl ModelWithComplexArrayEntityKey of dojo::model::entity::EntityKey<ModelWithComplexArrayEntity, ModelWithComplexArrayKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_complex_array_definition {
    use super::ModelWithComplexArray;
    pub impl ModelWithComplexArrayDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithComplexArray"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-ModelWithComplexArray"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            1293570145807126672811046976011709110822800800255162893130594439459909679461
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            2866472224509756243720005045848892642397514372569303051745174230372637769655
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithComplexArray>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithComplexArray>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithComplexArray>::size()
        }
    }
    
}


pub impl ModelWithComplexArrayDefinition = model_with_complex_array_definition::ModelWithComplexArrayDefinitionImpl<ModelWithComplexArray>;
pub impl ModelWithComplexArrayEntityDefinition = model_with_complex_array_definition::ModelWithComplexArrayDefinitionImpl<ModelWithComplexArrayEntity>;

pub impl ModelWithComplexArrayModelParser of dojo::model::model::ModelParser<ModelWithComplexArray>{
    fn serialize_keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithComplexArrayEntityParser of dojo::model::entity::EntityParser<ModelWithComplexArrayEntity>{
    fn parse_id(self: @ModelWithComplexArrayEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithComplexArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithComplexArrayModelImpl = dojo::model::model::ModelImpl<ModelWithComplexArray>;
pub impl ModelWithComplexArrayStore = dojo::model::model::ModelStoreImpl<ModelWithComplexArray>;

pub impl ModelWithComplexArrayEntityImpl = dojo::model::entity::EntityImpl<ModelWithComplexArrayEntity>;
pub impl ModelWithComplexArrayEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithComplexArrayEntity>;


#[generate_trait]
pub impl ModelWithComplexArrayMembersStoreImpl of ModelWithComplexArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType) -> u16 {
        ModelWithComplexArrayStore::get_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        ModelWithComplexArrayEntityStore::get_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType, value: u16) {
        ModelWithComplexArrayStore::update_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16) {
        ModelWithComplexArrayEntityStore::update_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType) -> Array<Vec3> {
        ModelWithComplexArrayStore::get_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3> {
        ModelWithComplexArrayEntityStore::get_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType, value: Array<Vec3>) {
        ModelWithComplexArrayStore::update_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Array<Vec3>) {
        ModelWithComplexArrayEntityStore::update_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }


}


#[starknet::interface]
pub trait IModelWithComplexArray<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
pub mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::IModelWithComplexArray;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithComplexArray>;

    #[abi(embed_v0)]
    impl ModelWithComplexArrayImpl of IModelWithComplexArray<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithComplexArrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithComplexArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithComplexArrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithComplexArrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithTupleIntrospect<> of dojo::meta::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::meta::introspect::Introspect::<u16>::layout()
                },
dojo::meta::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::meta::Layout::Tuple(
            array![
            dojo::meta::introspect::Introspect::<u8>::layout(),
dojo::meta::introspect::Introspect::<u16>::layout(),
dojo::meta::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<u16>::ty()
        },
dojo::meta::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Ty::Tuple(
            array![
            dojo::meta::introspect::Introspect::<u8>::ty(),
dojo::meta::introspect::Introspect::<u16>::ty(),
dojo::meta::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithTupleEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, u16, u32),

} 

type ModelWithTupleKeyType = ContractAddress;

pub impl ModelWithTupleKeyParser of dojo::model::model::KeyParser<ModelWithTuple, ModelWithTupleKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithTuple) -> ModelWithTupleKeyType {
        *self.player
    }
}

impl ModelWithTupleEntityKey of dojo::model::entity::EntityKey<ModelWithTupleEntity, ModelWithTupleKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_tuple_definition {
    use super::ModelWithTuple;
    pub impl ModelWithTupleDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithTuple"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-ModelWithTuple"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            2556860780543194947392385177981405629628409496147617432088261544126553394590
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            3222351670132870101782632958288197874250493316621507272653773018669253981260
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithTuple>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithTuple>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithTuple>::size()
        }
    }
    
}


pub impl ModelWithTupleDefinition = model_with_tuple_definition::ModelWithTupleDefinitionImpl<ModelWithTuple>;
pub impl ModelWithTupleEntityDefinition = model_with_tuple_definition::ModelWithTupleDefinitionImpl<ModelWithTupleEntity>;

pub impl ModelWithTupleModelParser of dojo::model::model::ModelParser<ModelWithTuple>{
    fn serialize_keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithTupleEntityParser of dojo::model::entity::EntityParser<ModelWithTupleEntity>{
    fn parse_id(self: @ModelWithTupleEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithTupleEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithTupleModelImpl = dojo::model::model::ModelImpl<ModelWithTuple>;
pub impl ModelWithTupleStore = dojo::model::model::ModelStoreImpl<ModelWithTuple>;

pub impl ModelWithTupleEntityImpl = dojo::model::entity::EntityImpl<ModelWithTupleEntity>;
pub impl ModelWithTupleEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithTupleEntity>;


#[generate_trait]
pub impl ModelWithTupleMembersStoreImpl of ModelWithTupleMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType) -> u16 {
        ModelWithTupleStore::get_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        ModelWithTupleEntityStore::get_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType, value: u16) {
        ModelWithTupleStore::update_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16) {
        ModelWithTupleEntityStore::update_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType) -> (u8, u16, u32) {
        ModelWithTupleStore::get_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32) {
        ModelWithTupleEntityStore::get_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType, value: (u8, u16, u32)) {
        ModelWithTupleStore::update_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: (u8, u16, u32)) {
        ModelWithTupleEntityStore::update_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }


}


#[starknet::interface]
pub trait IModelWithTuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
pub mod model_with_tuple {
    use super::ModelWithTuple;
    use super::IModelWithTuple;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithTuple>;

    #[abi(embed_v0)]
    impl ModelWithTupleImpl of IModelWithTuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithTupleImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTuple>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithTupleImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithTupleImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::meta::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::meta::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::utils::sum(sizes))
                
    }

    fn layout() -> dojo::meta::Layout {
        dojo::meta::Layout::Struct(
            array![
            dojo::meta::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::meta::introspect::Introspect::<u16>::layout()
                },
dojo::meta::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::meta::Layout::Tuple(
            array![
            dojo::meta::introspect::Introspect::<u8>::layout(),
dojo::meta::introspect::Introspect::<Vec3>::layout(),
dojo::meta::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::meta::introspect::Ty {
        dojo::meta::introspect::Ty::Struct(
            dojo::meta::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::meta::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::meta::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::meta::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Introspect::<u16>::ty()
        },
dojo::meta::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::meta::introspect::Ty::Tuple(
            array![
            dojo::meta::introspect::Introspect::<u8>::ty(),
dojo::meta::introspect::Introspect::<Vec3>::ty(),
dojo::meta::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        #[derive()]
pub struct ModelWithTupleNoPrimitivesEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, Vec3, u32),

} 

type ModelWithTupleNoPrimitivesKeyType = ContractAddress;

pub impl ModelWithTupleNoPrimitivesKeyParser of dojo::model::model::KeyParser<ModelWithTupleNoPrimitives, ModelWithTupleNoPrimitivesKeyType>{
    #[inline(always)]
    fn parse_key(self: @ModelWithTupleNoPrimitives) -> ModelWithTupleNoPrimitivesKeyType {
        *self.player
    }
}

impl ModelWithTupleNoPrimitivesEntityKey of dojo::model::entity::EntityKey<ModelWithTupleNoPrimitivesEntity, ModelWithTupleNoPrimitivesKeyType> {
}

// Impl to get the static definition of a model
pub mod model_with_tuple_no_primitives_definition {
    use super::ModelWithTupleNoPrimitives;
    pub impl ModelWithTupleNoPrimitivesDefinitionImpl<T> of dojo::model::ModelDefinition<T>{
        #[inline(always)]
        fn name() -> ByteArray {
            "ModelWithTupleNoPrimitives"
        }
        
        #[inline(always)]
        fn namespace() -> ByteArray {
            "dojo_test"
        }
        
        #[inline(always)]
        fn tag() -> ByteArray {
            "dojo_test-ModelWithTupleNoPrimitives"
        }

        #[inline(always)]
        fn version() -> u8 {
            1
        }
       
        #[inline(always)]
        fn selector() -> felt252 {
            59168777730614245274545541976317431416582911855710103554159293691166950405
        }
        
        #[inline(always)]
        fn name_hash() -> felt252 {
            157059227407493660591195028728750607977045261142495925435047270200565107096
        }
    
        #[inline(always)]
        fn namespace_hash() -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }
        
    
        #[inline(always)]
        fn layout() -> dojo::meta::Layout {
            dojo::meta::Introspect::<ModelWithTupleNoPrimitives>::layout()
        }

        #[inline(always)]
        fn schema() -> dojo::meta::introspect::Ty {
            dojo::meta::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }

        #[inline(always)]
        fn size() -> Option<usize> {
            dojo::meta::Introspect::<ModelWithTupleNoPrimitives>::size()
        }
    }
    
}


pub impl ModelWithTupleNoPrimitivesDefinition = model_with_tuple_no_primitives_definition::ModelWithTupleNoPrimitivesDefinitionImpl<ModelWithTupleNoPrimitives>;
pub impl ModelWithTupleNoPrimitivesEntityDefinition = model_with_tuple_no_primitives_definition::ModelWithTupleNoPrimitivesDefinitionImpl<ModelWithTupleNoPrimitivesEntity>;

pub impl ModelWithTupleNoPrimitivesModelParser of dojo::model::model::ModelParser<ModelWithTupleNoPrimitives>{
    fn serialize_keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
    fn serialize_values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
} 

pub impl ModelWithTupleNoPrimitivesEntityParser of dojo::model::entity::EntityParser<ModelWithTupleNoPrimitivesEntity>{
    fn parse_id(self: @ModelWithTupleNoPrimitivesEntity) -> felt252 {
        *self.__id
    }
    fn serialize_values(self: @ModelWithTupleNoPrimitivesEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }
}


pub impl ModelWithTupleNoPrimitivesModelImpl = dojo::model::model::ModelImpl<ModelWithTupleNoPrimitives>;
pub impl ModelWithTupleNoPrimitivesStore = dojo::model::model::ModelStoreImpl<ModelWithTupleNoPrimitives>;

pub impl ModelWithTupleNoPrimitivesEntityImpl = dojo::model::entity::EntityImpl<ModelWithTupleNoPrimitivesEntity>;
pub impl ModelWithTupleNoPrimitivesEntityStore = dojo::model::entity::EntityStoreImpl<ModelWithTupleNoPrimitivesEntity>;


#[generate_trait]
pub impl ModelWithTupleNoPrimitivesMembersStoreImpl of ModelWithTupleNoPrimitivesMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType) -> u16 {
        ModelWithTupleNoPrimitivesStore::get_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        ModelWithTupleNoPrimitivesEntityStore::get_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331)
    }

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType, value: u16) {
        ModelWithTupleNoPrimitivesStore::update_member(self, key, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16) {
        ModelWithTupleNoPrimitivesEntityStore::update_member_from_id(self, entity_id, 512066735765477566404754172672287371265995314501343422459174036873487219331, value);
    }

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType) -> (u8, Vec3, u32) {
        ModelWithTupleNoPrimitivesStore::get_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32) {
        ModelWithTupleNoPrimitivesEntityStore::get_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819)
    }

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType, value: (u8, Vec3, u32)) {
        ModelWithTupleNoPrimitivesStore::update_member(self, key, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: (u8, Vec3, u32)) {
        ModelWithTupleNoPrimitivesEntityStore::update_member_from_id(self, entity_id, 1591024729085637502504777720563487898377940395575083379770417352976841400819, value);
    }


}


#[starknet::interface]
pub trait IModelWithTupleNoPrimitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
pub mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::IModelWithTupleNoPrimitives;

    #[abi(embed_v0)]
    impl DojoModelImpl = dojo::model::component::IModelImpl<ContractState, ModelWithTupleNoPrimitives>;

    #[abi(embed_v0)]
    impl ModelWithTupleNoPrimitivesImpl of IModelWithTupleNoPrimitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
#[allow(unused_imports)]
use starknet::storage::Map as LegacyMap;

impl ContractStateIModelImpl of
    dojo::model::component::UnsafeNewContractStateTraitForIModelImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ModelWithTupleNoPrimitivesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    ModelWithTupleNoPrimitivesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ModelWithTupleNoPrimitivesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}
pub trait Modelv0MembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: Modelv0KeyType) -> Vec3;

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn update_v(self: dojo::world::IWorldDispatcher, key: Modelv0KeyType, value: Vec3);

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3);


}
pub trait IModelv0DispatcherTrait<T> {
    fn ensure_abi(self: T, model: Modelv0);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelv0Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelv0DispatcherImpl of IModelv0DispatcherTrait<IModelv0Dispatcher> {
    fn ensure_abi(self: IModelv0Dispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelv0LibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelv0LibraryDispatcherImpl of IModelv0DispatcherTrait<IModelv0LibraryDispatcher> {
    fn ensure_abi(self: IModelv0LibraryDispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelv0SafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Modelv0) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelv0SafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelv0SafeLibraryDispatcherImpl of IModelv0SafeDispatcherTrait<IModelv0SafeLibraryDispatcher> {
    fn ensure_abi(self: IModelv0SafeLibraryDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelv0SafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelv0SafeDispatcherImpl of IModelv0SafeDispatcherTrait<IModelv0SafeDispatcher> {
    fn ensure_abi(self: IModelv0SafeDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithBadNamespaceFormatMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithBadNamespaceFormatKeyType) -> Vec3;

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithBadNamespaceFormatKeyType, value: Vec3);

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3);


}
pub trait IModelWithBadNamespaceFormatDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithBadNamespaceFormatDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithBadNamespaceFormatDispatcherImpl of IModelWithBadNamespaceFormatDispatcherTrait<IModelWithBadNamespaceFormatDispatcher> {
    fn ensure_abi(self: IModelWithBadNamespaceFormatDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithBadNamespaceFormatLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithBadNamespaceFormatLibraryDispatcherImpl of IModelWithBadNamespaceFormatDispatcherTrait<IModelWithBadNamespaceFormatLibraryDispatcher> {
    fn ensure_abi(self: IModelWithBadNamespaceFormatLibraryDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithBadNamespaceFormatSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithBadNamespaceFormatSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithBadNamespaceFormatSafeLibraryDispatcherImpl of IModelWithBadNamespaceFormatSafeDispatcherTrait<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithBadNamespaceFormatSafeLibraryDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithBadNamespaceFormatSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithBadNamespaceFormatSafeDispatcherImpl of IModelWithBadNamespaceFormatSafeDispatcherTrait<IModelWithBadNamespaceFormatSafeDispatcher> {
    fn ensure_abi(self: IModelWithBadNamespaceFormatSafeDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithShortStringNamespaceMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithShortStringNamespaceKeyType) -> Vec3;

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithShortStringNamespaceKeyType, value: Vec3);

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3);


}
pub trait IModelWithShortStringNamespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithShortStringNamespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithShortStringNamespaceDispatcherImpl of IModelWithShortStringNamespaceDispatcherTrait<IModelWithShortStringNamespaceDispatcher> {
    fn ensure_abi(self: IModelWithShortStringNamespaceDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithShortStringNamespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithShortStringNamespaceLibraryDispatcherImpl of IModelWithShortStringNamespaceDispatcherTrait<IModelWithShortStringNamespaceLibraryDispatcher> {
    fn ensure_abi(self: IModelWithShortStringNamespaceLibraryDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithShortStringNamespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithShortStringNamespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithShortStringNamespaceSafeLibraryDispatcherImpl of IModelWithShortStringNamespaceSafeDispatcherTrait<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithShortStringNamespaceSafeLibraryDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithShortStringNamespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithShortStringNamespaceSafeDispatcherImpl of IModelWithShortStringNamespaceSafeDispatcherTrait<IModelWithShortStringNamespaceSafeDispatcher> {
    fn ensure_abi(self: IModelWithShortStringNamespaceSafeDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithStringNamespaceMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: ModelWithStringNamespaceKeyType) -> Vec3;

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn update_v(self: dojo::world::IWorldDispatcher, key: ModelWithStringNamespaceKeyType, value: Vec3);

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3);


}
pub trait IModelWithStringNamespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithStringNamespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithStringNamespaceDispatcherImpl of IModelWithStringNamespaceDispatcherTrait<IModelWithStringNamespaceDispatcher> {
    fn ensure_abi(self: IModelWithStringNamespaceDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithStringNamespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithStringNamespaceLibraryDispatcherImpl of IModelWithStringNamespaceDispatcherTrait<IModelWithStringNamespaceLibraryDispatcher> {
    fn ensure_abi(self: IModelWithStringNamespaceLibraryDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithStringNamespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithStringNamespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithStringNamespaceSafeLibraryDispatcherImpl of IModelWithStringNamespaceSafeDispatcherTrait<IModelWithStringNamespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithStringNamespaceSafeLibraryDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithStringNamespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithStringNamespaceSafeDispatcherImpl of IModelWithStringNamespaceSafeDispatcherTrait<IModelWithStringNamespaceSafeDispatcher> {
    fn ensure_abi(self: IModelWithStringNamespaceSafeDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait PositionMembersStore {
    fn get_v(self: @dojo::world::IWorldDispatcher, key: PositionKeyType) -> Vec3;

    fn get_v_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn update_v(self: dojo::world::IWorldDispatcher, key: PositionKeyType, value: Vec3);

    fn update_v_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Vec3);


}
pub trait IPositionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Position);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPositionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IPositionDispatcherImpl of IPositionDispatcherTrait<IPositionDispatcher> {
    fn ensure_abi(self: IPositionDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPositionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IPositionLibraryDispatcherImpl of IPositionDispatcherTrait<IPositionLibraryDispatcher> {
    fn ensure_abi(self: IPositionLibraryDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IPositionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Position) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPositionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IPositionSafeLibraryDispatcherImpl of IPositionSafeDispatcherTrait<IPositionSafeLibraryDispatcher> {
    fn ensure_abi(self: IPositionSafeLibraryDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPositionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IPositionSafeDispatcherImpl of IPositionSafeDispatcherTrait<IPositionSafeDispatcher> {
    fn ensure_abi(self: IPositionSafeDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait PlayerMembersStore {
    fn get_name(self: @dojo::world::IWorldDispatcher, key: PlayerKeyType) -> felt252;

    fn get_name_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252;

    fn update_name(self: dojo::world::IWorldDispatcher, key: PlayerKeyType, value: felt252);

    fn update_name_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: felt252);


}
pub trait IPlayerDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Player);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPlayerDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IPlayerDispatcherImpl of IPlayerDispatcherTrait<IPlayerDispatcher> {
    fn ensure_abi(self: IPlayerDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPlayerLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IPlayerLibraryDispatcherImpl of IPlayerDispatcherTrait<IPlayerLibraryDispatcher> {
    fn ensure_abi(self: IPlayerLibraryDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IPlayerSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Player) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPlayerSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IPlayerSafeLibraryDispatcherImpl of IPlayerSafeDispatcherTrait<IPlayerSafeLibraryDispatcher> {
    fn ensure_abi(self: IPlayerSafeLibraryDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IPlayerSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IPlayerSafeDispatcherImpl of IPlayerSafeDispatcherTrait<IPlayerSafeDispatcher> {
    fn ensure_abi(self: IPlayerSafeDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithSimpleArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType) -> u16;

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType, value: u16);

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16);

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType) -> Array<u8>;

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8>;

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithSimpleArrayKeyType, value: Array<u8>);

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Array<u8>);


}
pub trait IModelWithSimpleArrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithSimpleArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithSimpleArrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithSimpleArrayDispatcherImpl of IModelWithSimpleArrayDispatcherTrait<IModelWithSimpleArrayDispatcher> {
    fn ensure_abi(self: IModelWithSimpleArrayDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithSimpleArrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithSimpleArrayLibraryDispatcherImpl of IModelWithSimpleArrayDispatcherTrait<IModelWithSimpleArrayLibraryDispatcher> {
    fn ensure_abi(self: IModelWithSimpleArrayLibraryDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithSimpleArraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithSimpleArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithSimpleArraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithSimpleArraySafeLibraryDispatcherImpl of IModelWithSimpleArraySafeDispatcherTrait<IModelWithSimpleArraySafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithSimpleArraySafeLibraryDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithSimpleArraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithSimpleArraySafeDispatcherImpl of IModelWithSimpleArraySafeDispatcherTrait<IModelWithSimpleArraySafeDispatcher> {
    fn ensure_abi(self: IModelWithSimpleArraySafeDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithByteArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType) -> u16;

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType, value: u16);

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16);

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType) -> ByteArray;

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray;

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithByteArrayKeyType, value: ByteArray);

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: ByteArray);


}
pub trait IModelWithByteArrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithByteArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithByteArrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithByteArrayDispatcherImpl of IModelWithByteArrayDispatcherTrait<IModelWithByteArrayDispatcher> {
    fn ensure_abi(self: IModelWithByteArrayDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithByteArrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithByteArrayLibraryDispatcherImpl of IModelWithByteArrayDispatcherTrait<IModelWithByteArrayLibraryDispatcher> {
    fn ensure_abi(self: IModelWithByteArrayLibraryDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithByteArraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithByteArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithByteArraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithByteArraySafeLibraryDispatcherImpl of IModelWithByteArraySafeDispatcherTrait<IModelWithByteArraySafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithByteArraySafeLibraryDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithByteArraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithByteArraySafeDispatcherImpl of IModelWithByteArraySafeDispatcherTrait<IModelWithByteArraySafeDispatcher> {
    fn ensure_abi(self: IModelWithByteArraySafeDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithComplexArrayMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType) -> u16;

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType, value: u16);

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16);

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType) -> Array<Vec3>;

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3>;

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithComplexArrayKeyType, value: Array<Vec3>);

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: Array<Vec3>);


}
pub trait IModelWithComplexArrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithComplexArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithComplexArrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithComplexArrayDispatcherImpl of IModelWithComplexArrayDispatcherTrait<IModelWithComplexArrayDispatcher> {
    fn ensure_abi(self: IModelWithComplexArrayDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithComplexArrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithComplexArrayLibraryDispatcherImpl of IModelWithComplexArrayDispatcherTrait<IModelWithComplexArrayLibraryDispatcher> {
    fn ensure_abi(self: IModelWithComplexArrayLibraryDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithComplexArraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithComplexArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithComplexArraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithComplexArraySafeLibraryDispatcherImpl of IModelWithComplexArraySafeDispatcherTrait<IModelWithComplexArraySafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithComplexArraySafeLibraryDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithComplexArraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithComplexArraySafeDispatcherImpl of IModelWithComplexArraySafeDispatcherTrait<IModelWithComplexArraySafeDispatcher> {
    fn ensure_abi(self: IModelWithComplexArraySafeDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithTupleMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType) -> u16;

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType, value: u16);

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16);

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType) -> (u8, u16, u32);

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32);

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithTupleKeyType, value: (u8, u16, u32));

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: (u8, u16, u32));


}
pub trait IModelWithTupleDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTuple);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithTupleDispatcherImpl of IModelWithTupleDispatcherTrait<IModelWithTupleDispatcher> {
    fn ensure_abi(self: IModelWithTupleDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithTupleLibraryDispatcherImpl of IModelWithTupleDispatcherTrait<IModelWithTupleLibraryDispatcher> {
    fn ensure_abi(self: IModelWithTupleLibraryDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithTupleSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTuple) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithTupleSafeLibraryDispatcherImpl of IModelWithTupleSafeDispatcherTrait<IModelWithTupleSafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithTupleSafeLibraryDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithTupleSafeDispatcherImpl of IModelWithTupleSafeDispatcherTrait<IModelWithTupleSafeDispatcher> {
    fn ensure_abi(self: IModelWithTupleSafeDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
pub trait ModelWithTupleNoPrimitivesMembersStore {
    fn get_x(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType) -> u16;

    fn get_x_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn update_x(self: dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType, value: u16);

    fn update_x_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: u16);

    fn get_y(self: @dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType) -> (u8, Vec3, u32);

    fn get_y_from_id(self: @dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32);

    fn update_y(self: dojo::world::IWorldDispatcher, key: ModelWithTupleNoPrimitivesKeyType, value: (u8, Vec3, u32));

    fn update_y_from_id(self: dojo::world::IWorldDispatcher, entity_id: felt252, value: (u8, Vec3, u32));


}
pub trait IModelWithTupleNoPrimitivesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleNoPrimitivesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithTupleNoPrimitivesDispatcherImpl of IModelWithTupleNoPrimitivesDispatcherTrait<IModelWithTupleNoPrimitivesDispatcher> {
    fn ensure_abi(self: IModelWithTupleNoPrimitivesDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleNoPrimitivesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithTupleNoPrimitivesLibraryDispatcherImpl of IModelWithTupleNoPrimitivesDispatcherTrait<IModelWithTupleNoPrimitivesLibraryDispatcher> {
    fn ensure_abi(self: IModelWithTupleNoPrimitivesLibraryDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IModelWithTupleNoPrimitivesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleNoPrimitivesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherImpl of IModelWithTupleNoPrimitivesSafeDispatcherTrait<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
    fn ensure_abi(self: IModelWithTupleNoPrimitivesSafeLibraryDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IModelWithTupleNoPrimitivesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IModelWithTupleNoPrimitivesSafeDispatcherImpl of IModelWithTupleNoPrimitivesSafeDispatcherTrait<IModelWithTupleNoPrimitivesSafeDispatcher> {
    fn ensure_abi(self: IModelWithTupleNoPrimitivesSafeDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl IModelv0DispatcherCopy of core::traits::Copy::<IModelv0Dispatcher>;
impl IModelv0DispatcherDrop of core::traits::Drop::<IModelv0Dispatcher>;
impl IModelv0DispatcherSerde of core::serde::Serde::<IModelv0Dispatcher> {
    fn serialize(self: @IModelv0Dispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelv0Dispatcher> {
        core::option::Option::Some(IModelv0Dispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelv0Dispatcher of starknet::Store::<IModelv0Dispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelv0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelv0Dispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelv0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelv0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelv0Dispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelv0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelv0DispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelv0DispatcherSubPointersImpl of starknet::storage::SubPointers<IModelv0Dispatcher> {
    type SubPointersType = IModelv0DispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelv0Dispatcher>) -> IModelv0DispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0DispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelv0DispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelv0DispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelv0Dispatcher> {
    type SubPointersType = IModelv0DispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelv0Dispatcher>>) -> IModelv0DispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0DispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelv0LibraryDispatcherCopy of core::traits::Copy::<IModelv0LibraryDispatcher>;
impl IModelv0LibraryDispatcherDrop of core::traits::Drop::<IModelv0LibraryDispatcher>;
impl IModelv0LibraryDispatcherSerde of core::serde::Serde::<IModelv0LibraryDispatcher> {
    fn serialize(self: @IModelv0LibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelv0LibraryDispatcher> {
        core::option::Option::Some(IModelv0LibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelv0LibraryDispatcher of starknet::Store::<IModelv0LibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelv0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelv0LibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelv0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelv0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelv0LibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelv0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelv0LibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelv0LibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelv0LibraryDispatcher> {
    type SubPointersType = IModelv0LibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelv0LibraryDispatcher>) -> IModelv0LibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0LibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelv0LibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelv0LibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelv0LibraryDispatcher> {
    type SubPointersType = IModelv0LibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelv0LibraryDispatcher>>) -> IModelv0LibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0LibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelv0SafeLibraryDispatcherCopy of core::traits::Copy::<IModelv0SafeLibraryDispatcher>;
impl IModelv0SafeLibraryDispatcherDrop of core::traits::Drop::<IModelv0SafeLibraryDispatcher>;
impl IModelv0SafeLibraryDispatcherSerde of core::serde::Serde::<IModelv0SafeLibraryDispatcher> {
    fn serialize(self: @IModelv0SafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelv0SafeLibraryDispatcher> {
        core::option::Option::Some(IModelv0SafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelv0SafeLibraryDispatcher of starknet::Store::<IModelv0SafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelv0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelv0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelv0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelv0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelv0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelv0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelv0SafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelv0SafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelv0SafeLibraryDispatcher> {
    type SubPointersType = IModelv0SafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelv0SafeLibraryDispatcher>) -> IModelv0SafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0SafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelv0SafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelv0SafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelv0SafeLibraryDispatcher> {
    type SubPointersType = IModelv0SafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelv0SafeLibraryDispatcher>>) -> IModelv0SafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0SafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelv0SafeDispatcherCopy of core::traits::Copy::<IModelv0SafeDispatcher>;
impl IModelv0SafeDispatcherDrop of core::traits::Drop::<IModelv0SafeDispatcher>;
impl IModelv0SafeDispatcherSerde of core::serde::Serde::<IModelv0SafeDispatcher> {
    fn serialize(self: @IModelv0SafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelv0SafeDispatcher> {
        core::option::Option::Some(IModelv0SafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelv0SafeDispatcher of starknet::Store::<IModelv0SafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelv0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelv0SafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelv0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelv0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelv0SafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelv0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelv0SafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelv0SafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelv0SafeDispatcher> {
    type SubPointersType = IModelv0SafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelv0SafeDispatcher>) -> IModelv0SafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0SafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelv0SafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelv0SafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelv0SafeDispatcher> {
    type SubPointersType = IModelv0SafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelv0SafeDispatcher>>) -> IModelv0SafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelv0SafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithBadNamespaceFormatDispatcherCopy of core::traits::Copy::<IModelWithBadNamespaceFormatDispatcher>;
impl IModelWithBadNamespaceFormatDispatcherDrop of core::traits::Drop::<IModelWithBadNamespaceFormatDispatcher>;
impl IModelWithBadNamespaceFormatDispatcherSerde of core::serde::Serde::<IModelWithBadNamespaceFormatDispatcher> {
    fn serialize(self: @IModelWithBadNamespaceFormatDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithBadNamespaceFormatDispatcher> {
        core::option::Option::Some(IModelWithBadNamespaceFormatDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithBadNamespaceFormatDispatcher of starknet::Store::<IModelWithBadNamespaceFormatDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithBadNamespaceFormatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithBadNamespaceFormatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithBadNamespaceFormatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithBadNamespaceFormatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithBadNamespaceFormatDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithBadNamespaceFormatDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithBadNamespaceFormatDispatcher>) -> IModelWithBadNamespaceFormatDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithBadNamespaceFormatDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithBadNamespaceFormatDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithBadNamespaceFormatDispatcher>>) -> IModelWithBadNamespaceFormatDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithBadNamespaceFormatLibraryDispatcherCopy of core::traits::Copy::<IModelWithBadNamespaceFormatLibraryDispatcher>;
impl IModelWithBadNamespaceFormatLibraryDispatcherDrop of core::traits::Drop::<IModelWithBadNamespaceFormatLibraryDispatcher>;
impl IModelWithBadNamespaceFormatLibraryDispatcherSerde of core::serde::Serde::<IModelWithBadNamespaceFormatLibraryDispatcher> {
    fn serialize(self: @IModelWithBadNamespaceFormatLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithBadNamespaceFormatLibraryDispatcher> {
        core::option::Option::Some(IModelWithBadNamespaceFormatLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithBadNamespaceFormatLibraryDispatcher of starknet::Store::<IModelWithBadNamespaceFormatLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithBadNamespaceFormatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithBadNamespaceFormatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithBadNamespaceFormatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithBadNamespaceFormatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithBadNamespaceFormatLibraryDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithBadNamespaceFormatLibraryDispatcher>) -> IModelWithBadNamespaceFormatLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithBadNamespaceFormatLibraryDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithBadNamespaceFormatLibraryDispatcher>>) -> IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeLibraryDispatcher>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeLibraryDispatcher>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
    fn serialize(self: @IModelWithBadNamespaceFormatSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithBadNamespaceFormatSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithBadNamespaceFormatSafeLibraryDispatcher of starknet::Store::<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithBadNamespaceFormatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithBadNamespaceFormatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithBadNamespaceFormatSafeLibraryDispatcher>) -> IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithBadNamespaceFormatSafeLibraryDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithBadNamespaceFormatSafeLibraryDispatcher>>) -> IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithBadNamespaceFormatSafeDispatcherCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeDispatcher>;
impl IModelWithBadNamespaceFormatSafeDispatcherDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeDispatcher>;
impl IModelWithBadNamespaceFormatSafeDispatcherSerde of core::serde::Serde::<IModelWithBadNamespaceFormatSafeDispatcher> {
    fn serialize(self: @IModelWithBadNamespaceFormatSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithBadNamespaceFormatSafeDispatcher> {
        core::option::Option::Some(IModelWithBadNamespaceFormatSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithBadNamespaceFormatSafeDispatcher of starknet::Store::<IModelWithBadNamespaceFormatSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithBadNamespaceFormatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithBadNamespaceFormatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithBadNamespaceFormatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithBadNamespaceFormatSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithBadNamespaceFormatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithBadNamespaceFormatSafeDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithBadNamespaceFormatSafeDispatcher>) -> IModelWithBadNamespaceFormatSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithBadNamespaceFormatSafeDispatcher> {
    type SubPointersType = IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithBadNamespaceFormatSafeDispatcher>>) -> IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithShortStringNamespaceDispatcherCopy of core::traits::Copy::<IModelWithShortStringNamespaceDispatcher>;
impl IModelWithShortStringNamespaceDispatcherDrop of core::traits::Drop::<IModelWithShortStringNamespaceDispatcher>;
impl IModelWithShortStringNamespaceDispatcherSerde of core::serde::Serde::<IModelWithShortStringNamespaceDispatcher> {
    fn serialize(self: @IModelWithShortStringNamespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithShortStringNamespaceDispatcher> {
        core::option::Option::Some(IModelWithShortStringNamespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithShortStringNamespaceDispatcher of starknet::Store::<IModelWithShortStringNamespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithShortStringNamespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithShortStringNamespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithShortStringNamespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithShortStringNamespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithShortStringNamespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithShortStringNamespaceDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithShortStringNamespaceDispatcher>) -> IModelWithShortStringNamespaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithShortStringNamespaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithShortStringNamespaceDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithShortStringNamespaceDispatcher>>) -> IModelWithShortStringNamespaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithShortStringNamespaceLibraryDispatcherCopy of core::traits::Copy::<IModelWithShortStringNamespaceLibraryDispatcher>;
impl IModelWithShortStringNamespaceLibraryDispatcherDrop of core::traits::Drop::<IModelWithShortStringNamespaceLibraryDispatcher>;
impl IModelWithShortStringNamespaceLibraryDispatcherSerde of core::serde::Serde::<IModelWithShortStringNamespaceLibraryDispatcher> {
    fn serialize(self: @IModelWithShortStringNamespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithShortStringNamespaceLibraryDispatcher> {
        core::option::Option::Some(IModelWithShortStringNamespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithShortStringNamespaceLibraryDispatcher of starknet::Store::<IModelWithShortStringNamespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithShortStringNamespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithShortStringNamespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithShortStringNamespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithShortStringNamespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithShortStringNamespaceLibraryDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithShortStringNamespaceLibraryDispatcher>) -> IModelWithShortStringNamespaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithShortStringNamespaceLibraryDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithShortStringNamespaceLibraryDispatcher>>) -> IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithShortStringNamespaceSafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeLibraryDispatcher>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeLibraryDispatcher>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
    fn serialize(self: @IModelWithShortStringNamespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithShortStringNamespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithShortStringNamespaceSafeLibraryDispatcher of starknet::Store::<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithShortStringNamespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithShortStringNamespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithShortStringNamespaceSafeLibraryDispatcher>) -> IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithShortStringNamespaceSafeLibraryDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithShortStringNamespaceSafeLibraryDispatcher>>) -> IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithShortStringNamespaceSafeDispatcherCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeDispatcher>;
impl IModelWithShortStringNamespaceSafeDispatcherDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeDispatcher>;
impl IModelWithShortStringNamespaceSafeDispatcherSerde of core::serde::Serde::<IModelWithShortStringNamespaceSafeDispatcher> {
    fn serialize(self: @IModelWithShortStringNamespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithShortStringNamespaceSafeDispatcher> {
        core::option::Option::Some(IModelWithShortStringNamespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithShortStringNamespaceSafeDispatcher of starknet::Store::<IModelWithShortStringNamespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithShortStringNamespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithShortStringNamespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithShortStringNamespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithShortStringNamespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithShortStringNamespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithShortStringNamespaceSafeDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithShortStringNamespaceSafeDispatcher>) -> IModelWithShortStringNamespaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithShortStringNamespaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithShortStringNamespaceSafeDispatcher> {
    type SubPointersType = IModelWithShortStringNamespaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithShortStringNamespaceSafeDispatcher>>) -> IModelWithShortStringNamespaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithShortStringNamespaceSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithStringNamespaceDispatcherCopy of core::traits::Copy::<IModelWithStringNamespaceDispatcher>;
impl IModelWithStringNamespaceDispatcherDrop of core::traits::Drop::<IModelWithStringNamespaceDispatcher>;
impl IModelWithStringNamespaceDispatcherSerde of core::serde::Serde::<IModelWithStringNamespaceDispatcher> {
    fn serialize(self: @IModelWithStringNamespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithStringNamespaceDispatcher> {
        core::option::Option::Some(IModelWithStringNamespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithStringNamespaceDispatcher of starknet::Store::<IModelWithStringNamespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithStringNamespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithStringNamespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithStringNamespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithStringNamespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithStringNamespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithStringNamespaceDispatcher> {
    type SubPointersType = IModelWithStringNamespaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithStringNamespaceDispatcher>) -> IModelWithStringNamespaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithStringNamespaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithStringNamespaceDispatcher> {
    type SubPointersType = IModelWithStringNamespaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithStringNamespaceDispatcher>>) -> IModelWithStringNamespaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithStringNamespaceLibraryDispatcherCopy of core::traits::Copy::<IModelWithStringNamespaceLibraryDispatcher>;
impl IModelWithStringNamespaceLibraryDispatcherDrop of core::traits::Drop::<IModelWithStringNamespaceLibraryDispatcher>;
impl IModelWithStringNamespaceLibraryDispatcherSerde of core::serde::Serde::<IModelWithStringNamespaceLibraryDispatcher> {
    fn serialize(self: @IModelWithStringNamespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithStringNamespaceLibraryDispatcher> {
        core::option::Option::Some(IModelWithStringNamespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithStringNamespaceLibraryDispatcher of starknet::Store::<IModelWithStringNamespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithStringNamespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithStringNamespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithStringNamespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithStringNamespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithStringNamespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithStringNamespaceLibraryDispatcher> {
    type SubPointersType = IModelWithStringNamespaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithStringNamespaceLibraryDispatcher>) -> IModelWithStringNamespaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithStringNamespaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithStringNamespaceLibraryDispatcher> {
    type SubPointersType = IModelWithStringNamespaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithStringNamespaceLibraryDispatcher>>) -> IModelWithStringNamespaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithStringNamespaceSafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithStringNamespaceSafeLibraryDispatcher>;
impl IModelWithStringNamespaceSafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithStringNamespaceSafeLibraryDispatcher>;
impl IModelWithStringNamespaceSafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithStringNamespaceSafeLibraryDispatcher> {
    fn serialize(self: @IModelWithStringNamespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithStringNamespaceSafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithStringNamespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithStringNamespaceSafeLibraryDispatcher of starknet::Store::<IModelWithStringNamespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithStringNamespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithStringNamespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithStringNamespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithStringNamespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithStringNamespaceSafeLibraryDispatcher> {
    type SubPointersType = IModelWithStringNamespaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithStringNamespaceSafeLibraryDispatcher>) -> IModelWithStringNamespaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithStringNamespaceSafeLibraryDispatcher> {
    type SubPointersType = IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithStringNamespaceSafeLibraryDispatcher>>) -> IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithStringNamespaceSafeDispatcherCopy of core::traits::Copy::<IModelWithStringNamespaceSafeDispatcher>;
impl IModelWithStringNamespaceSafeDispatcherDrop of core::traits::Drop::<IModelWithStringNamespaceSafeDispatcher>;
impl IModelWithStringNamespaceSafeDispatcherSerde of core::serde::Serde::<IModelWithStringNamespaceSafeDispatcher> {
    fn serialize(self: @IModelWithStringNamespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithStringNamespaceSafeDispatcher> {
        core::option::Option::Some(IModelWithStringNamespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithStringNamespaceSafeDispatcher of starknet::Store::<IModelWithStringNamespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithStringNamespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithStringNamespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithStringNamespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithStringNamespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithStringNamespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithStringNamespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithStringNamespaceSafeDispatcher> {
    type SubPointersType = IModelWithStringNamespaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithStringNamespaceSafeDispatcher>) -> IModelWithStringNamespaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithStringNamespaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithStringNamespaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithStringNamespaceSafeDispatcher> {
    type SubPointersType = IModelWithStringNamespaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithStringNamespaceSafeDispatcher>>) -> IModelWithStringNamespaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithStringNamespaceSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IPositionDispatcherCopy of core::traits::Copy::<IPositionDispatcher>;
impl IPositionDispatcherDrop of core::traits::Drop::<IPositionDispatcher>;
impl IPositionDispatcherSerde of core::serde::Serde::<IPositionDispatcher> {
    fn serialize(self: @IPositionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPositionDispatcher> {
        core::option::Option::Some(IPositionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPositionDispatcher of starknet::Store::<IPositionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPositionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPositionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPositionDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IPositionDispatcherSubPointersImpl of starknet::storage::SubPointers<IPositionDispatcher> {
    type SubPointersType = IPositionDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPositionDispatcher>) -> IPositionDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPositionDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IPositionDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPositionDispatcher> {
    type SubPointersType = IPositionDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPositionDispatcher>>) -> IPositionDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IPositionLibraryDispatcherCopy of core::traits::Copy::<IPositionLibraryDispatcher>;
impl IPositionLibraryDispatcherDrop of core::traits::Drop::<IPositionLibraryDispatcher>;
impl IPositionLibraryDispatcherSerde of core::serde::Serde::<IPositionLibraryDispatcher> {
    fn serialize(self: @IPositionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPositionLibraryDispatcher> {
        core::option::Option::Some(IPositionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPositionLibraryDispatcher of starknet::Store::<IPositionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPositionLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IPositionLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IPositionLibraryDispatcher> {
    type SubPointersType = IPositionLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPositionLibraryDispatcher>) -> IPositionLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPositionLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IPositionLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPositionLibraryDispatcher> {
    type SubPointersType = IPositionLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPositionLibraryDispatcher>>) -> IPositionLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IPositionSafeLibraryDispatcherCopy of core::traits::Copy::<IPositionSafeLibraryDispatcher>;
impl IPositionSafeLibraryDispatcherDrop of core::traits::Drop::<IPositionSafeLibraryDispatcher>;
impl IPositionSafeLibraryDispatcherSerde of core::serde::Serde::<IPositionSafeLibraryDispatcher> {
    fn serialize(self: @IPositionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPositionSafeLibraryDispatcher> {
        core::option::Option::Some(IPositionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPositionSafeLibraryDispatcher of starknet::Store::<IPositionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPositionSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IPositionSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IPositionSafeLibraryDispatcher> {
    type SubPointersType = IPositionSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPositionSafeLibraryDispatcher>) -> IPositionSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPositionSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IPositionSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPositionSafeLibraryDispatcher> {
    type SubPointersType = IPositionSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPositionSafeLibraryDispatcher>>) -> IPositionSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IPositionSafeDispatcherCopy of core::traits::Copy::<IPositionSafeDispatcher>;
impl IPositionSafeDispatcherDrop of core::traits::Drop::<IPositionSafeDispatcher>;
impl IPositionSafeDispatcherSerde of core::serde::Serde::<IPositionSafeDispatcher> {
    fn serialize(self: @IPositionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPositionSafeDispatcher> {
        core::option::Option::Some(IPositionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPositionSafeDispatcher of starknet::Store::<IPositionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPositionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPositionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPositionSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IPositionSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IPositionSafeDispatcher> {
    type SubPointersType = IPositionSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPositionSafeDispatcher>) -> IPositionSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPositionSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IPositionSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPositionSafeDispatcher> {
    type SubPointersType = IPositionSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPositionSafeDispatcher>>) -> IPositionSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPositionSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IPlayerDispatcherCopy of core::traits::Copy::<IPlayerDispatcher>;
impl IPlayerDispatcherDrop of core::traits::Drop::<IPlayerDispatcher>;
impl IPlayerDispatcherSerde of core::serde::Serde::<IPlayerDispatcher> {
    fn serialize(self: @IPlayerDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPlayerDispatcher> {
        core::option::Option::Some(IPlayerDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPlayerDispatcher of starknet::Store::<IPlayerDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPlayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPlayerDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPlayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPlayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPlayerDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPlayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPlayerDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IPlayerDispatcherSubPointersImpl of starknet::storage::SubPointers<IPlayerDispatcher> {
    type SubPointersType = IPlayerDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPlayerDispatcher>) -> IPlayerDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPlayerDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IPlayerDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPlayerDispatcher> {
    type SubPointersType = IPlayerDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPlayerDispatcher>>) -> IPlayerDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IPlayerLibraryDispatcherCopy of core::traits::Copy::<IPlayerLibraryDispatcher>;
impl IPlayerLibraryDispatcherDrop of core::traits::Drop::<IPlayerLibraryDispatcher>;
impl IPlayerLibraryDispatcherSerde of core::serde::Serde::<IPlayerLibraryDispatcher> {
    fn serialize(self: @IPlayerLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPlayerLibraryDispatcher> {
        core::option::Option::Some(IPlayerLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPlayerLibraryDispatcher of starknet::Store::<IPlayerLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPlayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPlayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPlayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPlayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPlayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPlayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPlayerLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IPlayerLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IPlayerLibraryDispatcher> {
    type SubPointersType = IPlayerLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPlayerLibraryDispatcher>) -> IPlayerLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPlayerLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IPlayerLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPlayerLibraryDispatcher> {
    type SubPointersType = IPlayerLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPlayerLibraryDispatcher>>) -> IPlayerLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IPlayerSafeLibraryDispatcherCopy of core::traits::Copy::<IPlayerSafeLibraryDispatcher>;
impl IPlayerSafeLibraryDispatcherDrop of core::traits::Drop::<IPlayerSafeLibraryDispatcher>;
impl IPlayerSafeLibraryDispatcherSerde of core::serde::Serde::<IPlayerSafeLibraryDispatcher> {
    fn serialize(self: @IPlayerSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPlayerSafeLibraryDispatcher> {
        core::option::Option::Some(IPlayerSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPlayerSafeLibraryDispatcher of starknet::Store::<IPlayerSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPlayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPlayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPlayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPlayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPlayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPlayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPlayerSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IPlayerSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IPlayerSafeLibraryDispatcher> {
    type SubPointersType = IPlayerSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPlayerSafeLibraryDispatcher>) -> IPlayerSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPlayerSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IPlayerSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPlayerSafeLibraryDispatcher> {
    type SubPointersType = IPlayerSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPlayerSafeLibraryDispatcher>>) -> IPlayerSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IPlayerSafeDispatcherCopy of core::traits::Copy::<IPlayerSafeDispatcher>;
impl IPlayerSafeDispatcherDrop of core::traits::Drop::<IPlayerSafeDispatcher>;
impl IPlayerSafeDispatcherSerde of core::serde::Serde::<IPlayerSafeDispatcher> {
    fn serialize(self: @IPlayerSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IPlayerSafeDispatcher> {
        core::option::Option::Some(IPlayerSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIPlayerSafeDispatcher of starknet::Store::<IPlayerSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IPlayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IPlayerSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IPlayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IPlayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IPlayerSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IPlayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IPlayerSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IPlayerSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IPlayerSafeDispatcher> {
    type SubPointersType = IPlayerSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IPlayerSafeDispatcher>) -> IPlayerSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IPlayerSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IPlayerSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IPlayerSafeDispatcher> {
    type SubPointersType = IPlayerSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IPlayerSafeDispatcher>>) -> IPlayerSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IPlayerSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithSimpleArrayDispatcherCopy of core::traits::Copy::<IModelWithSimpleArrayDispatcher>;
impl IModelWithSimpleArrayDispatcherDrop of core::traits::Drop::<IModelWithSimpleArrayDispatcher>;
impl IModelWithSimpleArrayDispatcherSerde of core::serde::Serde::<IModelWithSimpleArrayDispatcher> {
    fn serialize(self: @IModelWithSimpleArrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithSimpleArrayDispatcher> {
        core::option::Option::Some(IModelWithSimpleArrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithSimpleArrayDispatcher of starknet::Store::<IModelWithSimpleArrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithSimpleArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithSimpleArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithSimpleArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithSimpleArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithSimpleArrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithSimpleArrayDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithSimpleArrayDispatcher> {
    type SubPointersType = IModelWithSimpleArrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithSimpleArrayDispatcher>) -> IModelWithSimpleArrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArrayDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithSimpleArrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithSimpleArrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithSimpleArrayDispatcher> {
    type SubPointersType = IModelWithSimpleArrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithSimpleArrayDispatcher>>) -> IModelWithSimpleArrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArrayDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithSimpleArrayLibraryDispatcherCopy of core::traits::Copy::<IModelWithSimpleArrayLibraryDispatcher>;
impl IModelWithSimpleArrayLibraryDispatcherDrop of core::traits::Drop::<IModelWithSimpleArrayLibraryDispatcher>;
impl IModelWithSimpleArrayLibraryDispatcherSerde of core::serde::Serde::<IModelWithSimpleArrayLibraryDispatcher> {
    fn serialize(self: @IModelWithSimpleArrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithSimpleArrayLibraryDispatcher> {
        core::option::Option::Some(IModelWithSimpleArrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithSimpleArrayLibraryDispatcher of starknet::Store::<IModelWithSimpleArrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithSimpleArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithSimpleArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithSimpleArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithSimpleArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithSimpleArrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithSimpleArrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithSimpleArrayLibraryDispatcher> {
    type SubPointersType = IModelWithSimpleArrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithSimpleArrayLibraryDispatcher>) -> IModelWithSimpleArrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArrayLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithSimpleArrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithSimpleArrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithSimpleArrayLibraryDispatcher> {
    type SubPointersType = IModelWithSimpleArrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithSimpleArrayLibraryDispatcher>>) -> IModelWithSimpleArrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArrayLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithSimpleArraySafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithSimpleArraySafeLibraryDispatcher>;
impl IModelWithSimpleArraySafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithSimpleArraySafeLibraryDispatcher>;
impl IModelWithSimpleArraySafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithSimpleArraySafeLibraryDispatcher> {
    fn serialize(self: @IModelWithSimpleArraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithSimpleArraySafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithSimpleArraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithSimpleArraySafeLibraryDispatcher of starknet::Store::<IModelWithSimpleArraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithSimpleArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithSimpleArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithSimpleArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithSimpleArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithSimpleArraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithSimpleArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithSimpleArraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithSimpleArraySafeLibraryDispatcher>) -> IModelWithSimpleArraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArraySafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithSimpleArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithSimpleArraySafeLibraryDispatcher>>) -> IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithSimpleArraySafeDispatcherCopy of core::traits::Copy::<IModelWithSimpleArraySafeDispatcher>;
impl IModelWithSimpleArraySafeDispatcherDrop of core::traits::Drop::<IModelWithSimpleArraySafeDispatcher>;
impl IModelWithSimpleArraySafeDispatcherSerde of core::serde::Serde::<IModelWithSimpleArraySafeDispatcher> {
    fn serialize(self: @IModelWithSimpleArraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithSimpleArraySafeDispatcher> {
        core::option::Option::Some(IModelWithSimpleArraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithSimpleArraySafeDispatcher of starknet::Store::<IModelWithSimpleArraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithSimpleArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithSimpleArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithSimpleArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithSimpleArraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithSimpleArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithSimpleArraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithSimpleArraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithSimpleArraySafeDispatcher> {
    type SubPointersType = IModelWithSimpleArraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithSimpleArraySafeDispatcher>) -> IModelWithSimpleArraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArraySafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithSimpleArraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithSimpleArraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithSimpleArraySafeDispatcher> {
    type SubPointersType = IModelWithSimpleArraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithSimpleArraySafeDispatcher>>) -> IModelWithSimpleArraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithSimpleArraySafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithByteArrayDispatcherCopy of core::traits::Copy::<IModelWithByteArrayDispatcher>;
impl IModelWithByteArrayDispatcherDrop of core::traits::Drop::<IModelWithByteArrayDispatcher>;
impl IModelWithByteArrayDispatcherSerde of core::serde::Serde::<IModelWithByteArrayDispatcher> {
    fn serialize(self: @IModelWithByteArrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithByteArrayDispatcher> {
        core::option::Option::Some(IModelWithByteArrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithByteArrayDispatcher of starknet::Store::<IModelWithByteArrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithByteArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithByteArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithByteArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithByteArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithByteArrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithByteArrayDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithByteArrayDispatcher> {
    type SubPointersType = IModelWithByteArrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithByteArrayDispatcher>) -> IModelWithByteArrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArrayDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithByteArrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithByteArrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithByteArrayDispatcher> {
    type SubPointersType = IModelWithByteArrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithByteArrayDispatcher>>) -> IModelWithByteArrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArrayDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithByteArrayLibraryDispatcherCopy of core::traits::Copy::<IModelWithByteArrayLibraryDispatcher>;
impl IModelWithByteArrayLibraryDispatcherDrop of core::traits::Drop::<IModelWithByteArrayLibraryDispatcher>;
impl IModelWithByteArrayLibraryDispatcherSerde of core::serde::Serde::<IModelWithByteArrayLibraryDispatcher> {
    fn serialize(self: @IModelWithByteArrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithByteArrayLibraryDispatcher> {
        core::option::Option::Some(IModelWithByteArrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithByteArrayLibraryDispatcher of starknet::Store::<IModelWithByteArrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithByteArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithByteArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithByteArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithByteArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithByteArrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithByteArrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithByteArrayLibraryDispatcher> {
    type SubPointersType = IModelWithByteArrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithByteArrayLibraryDispatcher>) -> IModelWithByteArrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArrayLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithByteArrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithByteArrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithByteArrayLibraryDispatcher> {
    type SubPointersType = IModelWithByteArrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithByteArrayLibraryDispatcher>>) -> IModelWithByteArrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArrayLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithByteArraySafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithByteArraySafeLibraryDispatcher>;
impl IModelWithByteArraySafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithByteArraySafeLibraryDispatcher>;
impl IModelWithByteArraySafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithByteArraySafeLibraryDispatcher> {
    fn serialize(self: @IModelWithByteArraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithByteArraySafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithByteArraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithByteArraySafeLibraryDispatcher of starknet::Store::<IModelWithByteArraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithByteArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithByteArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithByteArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithByteArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithByteArraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithByteArraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithByteArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithByteArraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithByteArraySafeLibraryDispatcher>) -> IModelWithByteArraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArraySafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithByteArraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithByteArraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithByteArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithByteArraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithByteArraySafeLibraryDispatcher>>) -> IModelWithByteArraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArraySafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithByteArraySafeDispatcherCopy of core::traits::Copy::<IModelWithByteArraySafeDispatcher>;
impl IModelWithByteArraySafeDispatcherDrop of core::traits::Drop::<IModelWithByteArraySafeDispatcher>;
impl IModelWithByteArraySafeDispatcherSerde of core::serde::Serde::<IModelWithByteArraySafeDispatcher> {
    fn serialize(self: @IModelWithByteArraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithByteArraySafeDispatcher> {
        core::option::Option::Some(IModelWithByteArraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithByteArraySafeDispatcher of starknet::Store::<IModelWithByteArraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithByteArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithByteArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithByteArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithByteArraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithByteArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithByteArraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithByteArraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithByteArraySafeDispatcher> {
    type SubPointersType = IModelWithByteArraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithByteArraySafeDispatcher>) -> IModelWithByteArraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArraySafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithByteArraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithByteArraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithByteArraySafeDispatcher> {
    type SubPointersType = IModelWithByteArraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithByteArraySafeDispatcher>>) -> IModelWithByteArraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithByteArraySafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithComplexArrayDispatcherCopy of core::traits::Copy::<IModelWithComplexArrayDispatcher>;
impl IModelWithComplexArrayDispatcherDrop of core::traits::Drop::<IModelWithComplexArrayDispatcher>;
impl IModelWithComplexArrayDispatcherSerde of core::serde::Serde::<IModelWithComplexArrayDispatcher> {
    fn serialize(self: @IModelWithComplexArrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithComplexArrayDispatcher> {
        core::option::Option::Some(IModelWithComplexArrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithComplexArrayDispatcher of starknet::Store::<IModelWithComplexArrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithComplexArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithComplexArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithComplexArrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithComplexArrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithComplexArrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithComplexArrayDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithComplexArrayDispatcher> {
    type SubPointersType = IModelWithComplexArrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithComplexArrayDispatcher>) -> IModelWithComplexArrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArrayDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithComplexArrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithComplexArrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithComplexArrayDispatcher> {
    type SubPointersType = IModelWithComplexArrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithComplexArrayDispatcher>>) -> IModelWithComplexArrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArrayDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithComplexArrayLibraryDispatcherCopy of core::traits::Copy::<IModelWithComplexArrayLibraryDispatcher>;
impl IModelWithComplexArrayLibraryDispatcherDrop of core::traits::Drop::<IModelWithComplexArrayLibraryDispatcher>;
impl IModelWithComplexArrayLibraryDispatcherSerde of core::serde::Serde::<IModelWithComplexArrayLibraryDispatcher> {
    fn serialize(self: @IModelWithComplexArrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithComplexArrayLibraryDispatcher> {
        core::option::Option::Some(IModelWithComplexArrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithComplexArrayLibraryDispatcher of starknet::Store::<IModelWithComplexArrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithComplexArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithComplexArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithComplexArrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithComplexArrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithComplexArrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithComplexArrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithComplexArrayLibraryDispatcher> {
    type SubPointersType = IModelWithComplexArrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithComplexArrayLibraryDispatcher>) -> IModelWithComplexArrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArrayLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithComplexArrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithComplexArrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithComplexArrayLibraryDispatcher> {
    type SubPointersType = IModelWithComplexArrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithComplexArrayLibraryDispatcher>>) -> IModelWithComplexArrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArrayLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithComplexArraySafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithComplexArraySafeLibraryDispatcher>;
impl IModelWithComplexArraySafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithComplexArraySafeLibraryDispatcher>;
impl IModelWithComplexArraySafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithComplexArraySafeLibraryDispatcher> {
    fn serialize(self: @IModelWithComplexArraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithComplexArraySafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithComplexArraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithComplexArraySafeLibraryDispatcher of starknet::Store::<IModelWithComplexArraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithComplexArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithComplexArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithComplexArraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithComplexArraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithComplexArraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithComplexArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithComplexArraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithComplexArraySafeLibraryDispatcher>) -> IModelWithComplexArraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArraySafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithComplexArraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithComplexArraySafeLibraryDispatcher> {
    type SubPointersType = IModelWithComplexArraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithComplexArraySafeLibraryDispatcher>>) -> IModelWithComplexArraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArraySafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithComplexArraySafeDispatcherCopy of core::traits::Copy::<IModelWithComplexArraySafeDispatcher>;
impl IModelWithComplexArraySafeDispatcherDrop of core::traits::Drop::<IModelWithComplexArraySafeDispatcher>;
impl IModelWithComplexArraySafeDispatcherSerde of core::serde::Serde::<IModelWithComplexArraySafeDispatcher> {
    fn serialize(self: @IModelWithComplexArraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithComplexArraySafeDispatcher> {
        core::option::Option::Some(IModelWithComplexArraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithComplexArraySafeDispatcher of starknet::Store::<IModelWithComplexArraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithComplexArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithComplexArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithComplexArraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithComplexArraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithComplexArraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithComplexArraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithComplexArraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithComplexArraySafeDispatcher> {
    type SubPointersType = IModelWithComplexArraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithComplexArraySafeDispatcher>) -> IModelWithComplexArraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArraySafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithComplexArraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithComplexArraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithComplexArraySafeDispatcher> {
    type SubPointersType = IModelWithComplexArraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithComplexArraySafeDispatcher>>) -> IModelWithComplexArraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithComplexArraySafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithTupleDispatcherCopy of core::traits::Copy::<IModelWithTupleDispatcher>;
impl IModelWithTupleDispatcherDrop of core::traits::Drop::<IModelWithTupleDispatcher>;
impl IModelWithTupleDispatcherSerde of core::serde::Serde::<IModelWithTupleDispatcher> {
    fn serialize(self: @IModelWithTupleDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleDispatcher> {
        core::option::Option::Some(IModelWithTupleDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleDispatcher of starknet::Store::<IModelWithTupleDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithTupleDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleDispatcher> {
    type SubPointersType = IModelWithTupleDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleDispatcher>) -> IModelWithTupleDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithTupleDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleDispatcher> {
    type SubPointersType = IModelWithTupleDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleDispatcher>>) -> IModelWithTupleDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithTupleLibraryDispatcherCopy of core::traits::Copy::<IModelWithTupleLibraryDispatcher>;
impl IModelWithTupleLibraryDispatcherDrop of core::traits::Drop::<IModelWithTupleLibraryDispatcher>;
impl IModelWithTupleLibraryDispatcherSerde of core::serde::Serde::<IModelWithTupleLibraryDispatcher> {
    fn serialize(self: @IModelWithTupleLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleLibraryDispatcher> {
        core::option::Option::Some(IModelWithTupleLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleLibraryDispatcher of starknet::Store::<IModelWithTupleLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithTupleLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleLibraryDispatcher> {
    type SubPointersType = IModelWithTupleLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleLibraryDispatcher>) -> IModelWithTupleLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithTupleLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleLibraryDispatcher> {
    type SubPointersType = IModelWithTupleLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleLibraryDispatcher>>) -> IModelWithTupleLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithTupleSafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithTupleSafeLibraryDispatcher>;
impl IModelWithTupleSafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithTupleSafeLibraryDispatcher>;
impl IModelWithTupleSafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithTupleSafeLibraryDispatcher> {
    fn serialize(self: @IModelWithTupleSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleSafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithTupleSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleSafeLibraryDispatcher of starknet::Store::<IModelWithTupleSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithTupleSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleSafeLibraryDispatcher> {
    type SubPointersType = IModelWithTupleSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleSafeLibraryDispatcher>) -> IModelWithTupleSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithTupleSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleSafeLibraryDispatcher> {
    type SubPointersType = IModelWithTupleSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleSafeLibraryDispatcher>>) -> IModelWithTupleSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithTupleSafeDispatcherCopy of core::traits::Copy::<IModelWithTupleSafeDispatcher>;
impl IModelWithTupleSafeDispatcherDrop of core::traits::Drop::<IModelWithTupleSafeDispatcher>;
impl IModelWithTupleSafeDispatcherSerde of core::serde::Serde::<IModelWithTupleSafeDispatcher> {
    fn serialize(self: @IModelWithTupleSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleSafeDispatcher> {
        core::option::Option::Some(IModelWithTupleSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleSafeDispatcher of starknet::Store::<IModelWithTupleSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithTupleSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleSafeDispatcher> {
    type SubPointersType = IModelWithTupleSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleSafeDispatcher>) -> IModelWithTupleSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithTupleSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleSafeDispatcher> {
    type SubPointersType = IModelWithTupleSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleSafeDispatcher>>) -> IModelWithTupleSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithTupleNoPrimitivesDispatcherCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesDispatcher>;
impl IModelWithTupleNoPrimitivesDispatcherDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesDispatcher>;
impl IModelWithTupleNoPrimitivesDispatcherSerde of core::serde::Serde::<IModelWithTupleNoPrimitivesDispatcher> {
    fn serialize(self: @IModelWithTupleNoPrimitivesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleNoPrimitivesDispatcher> {
        core::option::Option::Some(IModelWithTupleNoPrimitivesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleNoPrimitivesDispatcher of starknet::Store::<IModelWithTupleNoPrimitivesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleNoPrimitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleNoPrimitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithTupleNoPrimitivesDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleNoPrimitivesDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleNoPrimitivesDispatcher>) -> IModelWithTupleNoPrimitivesDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithTupleNoPrimitivesDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleNoPrimitivesDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleNoPrimitivesDispatcher>>) -> IModelWithTupleNoPrimitivesDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelWithTupleNoPrimitivesLibraryDispatcherCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesLibraryDispatcher>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesLibraryDispatcher>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherSerde of core::serde::Serde::<IModelWithTupleNoPrimitivesLibraryDispatcher> {
    fn serialize(self: @IModelWithTupleNoPrimitivesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleNoPrimitivesLibraryDispatcher> {
        core::option::Option::Some(IModelWithTupleNoPrimitivesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleNoPrimitivesLibraryDispatcher of starknet::Store::<IModelWithTupleNoPrimitivesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleNoPrimitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleNoPrimitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleNoPrimitivesLibraryDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleNoPrimitivesLibraryDispatcher>) -> IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleNoPrimitivesLibraryDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleNoPrimitivesLibraryDispatcher>>) -> IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeLibraryDispatcher>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeLibraryDispatcher>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSerde of core::serde::Serde::<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
    fn serialize(self: @IModelWithTupleNoPrimitivesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
        core::option::Option::Some(IModelWithTupleNoPrimitivesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleNoPrimitivesSafeLibraryDispatcher of starknet::Store::<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleNoPrimitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleNoPrimitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleNoPrimitivesSafeLibraryDispatcher>) -> IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers {
           class_hash: __class_hash_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleNoPrimitivesSafeLibraryDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleNoPrimitivesSafeLibraryDispatcher>>) -> IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __class_hash_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut {
           class_hash: __class_hash_value__,
        }
    }
}
impl IModelWithTupleNoPrimitivesSafeDispatcherCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeDispatcher>;
impl IModelWithTupleNoPrimitivesSafeDispatcherDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeDispatcher>;
impl IModelWithTupleNoPrimitivesSafeDispatcherSerde of core::serde::Serde::<IModelWithTupleNoPrimitivesSafeDispatcher> {
    fn serialize(self: @IModelWithTupleNoPrimitivesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IModelWithTupleNoPrimitivesSafeDispatcher> {
        core::option::Option::Some(IModelWithTupleNoPrimitivesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIModelWithTupleNoPrimitivesSafeDispatcher of starknet::Store::<IModelWithTupleNoPrimitivesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IModelWithTupleNoPrimitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IModelWithTupleNoPrimitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IModelWithTupleNoPrimitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IModelWithTupleNoPrimitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IModelWithTupleNoPrimitivesSafeDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IModelWithTupleNoPrimitivesSafeDispatcher>) -> IModelWithTupleNoPrimitivesSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesSafeDispatcherSubPointers {
           contract_address: __contract_address_value__,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IModelWithTupleNoPrimitivesSafeDispatcher> {
    type SubPointersType = IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IModelWithTupleNoPrimitivesSafeDispatcher>>) -> IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let __contract_address_value__ = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut {
           contract_address: __contract_address_value__,
        }
    }
}
impl IModelv0DispatcherSubPointersDrop of core::traits::Drop::<IModelv0DispatcherSubPointers>;
impl IModelv0DispatcherSubPointersCopy of core::traits::Copy::<IModelv0DispatcherSubPointers>;
impl IModelv0DispatcherSubPointersMutDrop of core::traits::Drop::<IModelv0DispatcherSubPointersMut>;
impl IModelv0DispatcherSubPointersMutCopy of core::traits::Copy::<IModelv0DispatcherSubPointersMut>;
impl IModelv0LibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelv0LibraryDispatcherSubPointers>;
impl IModelv0LibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelv0LibraryDispatcherSubPointers>;
impl IModelv0LibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelv0LibraryDispatcherSubPointersMut>;
impl IModelv0LibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelv0LibraryDispatcherSubPointersMut>;
impl IModelv0SafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelv0SafeLibraryDispatcherSubPointers>;
impl IModelv0SafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelv0SafeLibraryDispatcherSubPointers>;
impl IModelv0SafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelv0SafeLibraryDispatcherSubPointersMut>;
impl IModelv0SafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelv0SafeLibraryDispatcherSubPointersMut>;
impl IModelv0SafeDispatcherSubPointersDrop of core::traits::Drop::<IModelv0SafeDispatcherSubPointers>;
impl IModelv0SafeDispatcherSubPointersCopy of core::traits::Copy::<IModelv0SafeDispatcherSubPointers>;
impl IModelv0SafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelv0SafeDispatcherSubPointersMut>;
impl IModelv0SafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelv0SafeDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatDispatcherSubPointersDrop of core::traits::Drop::<IModelWithBadNamespaceFormatDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatDispatcherSubPointersCopy of core::traits::Copy::<IModelWithBadNamespaceFormatDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithBadNamespaceFormatDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithBadNamespaceFormatDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithBadNamespaceFormatLibraryDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithBadNamespaceFormatLibraryDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithBadNamespaceFormatLibraryDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeLibraryDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeDispatcherSubPointers>;
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut>;
impl IModelWithBadNamespaceFormatSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithBadNamespaceFormatSafeDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceDispatcherSubPointersDrop of core::traits::Drop::<IModelWithShortStringNamespaceDispatcherSubPointers>;
impl IModelWithShortStringNamespaceDispatcherSubPointersCopy of core::traits::Copy::<IModelWithShortStringNamespaceDispatcherSubPointers>;
impl IModelWithShortStringNamespaceDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithShortStringNamespaceDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithShortStringNamespaceDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithShortStringNamespaceLibraryDispatcherSubPointers>;
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithShortStringNamespaceLibraryDispatcherSubPointers>;
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithShortStringNamespaceLibraryDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointers>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeLibraryDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeDispatcherSubPointers>;
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeDispatcherSubPointers>;
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithShortStringNamespaceSafeDispatcherSubPointersMut>;
impl IModelWithShortStringNamespaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithShortStringNamespaceSafeDispatcherSubPointersMut>;
impl IModelWithStringNamespaceDispatcherSubPointersDrop of core::traits::Drop::<IModelWithStringNamespaceDispatcherSubPointers>;
impl IModelWithStringNamespaceDispatcherSubPointersCopy of core::traits::Copy::<IModelWithStringNamespaceDispatcherSubPointers>;
impl IModelWithStringNamespaceDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithStringNamespaceDispatcherSubPointersMut>;
impl IModelWithStringNamespaceDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithStringNamespaceDispatcherSubPointersMut>;
impl IModelWithStringNamespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithStringNamespaceLibraryDispatcherSubPointers>;
impl IModelWithStringNamespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithStringNamespaceLibraryDispatcherSubPointers>;
impl IModelWithStringNamespaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithStringNamespaceLibraryDispatcherSubPointersMut>;
impl IModelWithStringNamespaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithStringNamespaceLibraryDispatcherSubPointersMut>;
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithStringNamespaceSafeLibraryDispatcherSubPointers>;
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithStringNamespaceSafeLibraryDispatcherSubPointers>;
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut>;
impl IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithStringNamespaceSafeLibraryDispatcherSubPointersMut>;
impl IModelWithStringNamespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithStringNamespaceSafeDispatcherSubPointers>;
impl IModelWithStringNamespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithStringNamespaceSafeDispatcherSubPointers>;
impl IModelWithStringNamespaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithStringNamespaceSafeDispatcherSubPointersMut>;
impl IModelWithStringNamespaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithStringNamespaceSafeDispatcherSubPointersMut>;
impl IPositionDispatcherSubPointersDrop of core::traits::Drop::<IPositionDispatcherSubPointers>;
impl IPositionDispatcherSubPointersCopy of core::traits::Copy::<IPositionDispatcherSubPointers>;
impl IPositionDispatcherSubPointersMutDrop of core::traits::Drop::<IPositionDispatcherSubPointersMut>;
impl IPositionDispatcherSubPointersMutCopy of core::traits::Copy::<IPositionDispatcherSubPointersMut>;
impl IPositionLibraryDispatcherSubPointersDrop of core::traits::Drop::<IPositionLibraryDispatcherSubPointers>;
impl IPositionLibraryDispatcherSubPointersCopy of core::traits::Copy::<IPositionLibraryDispatcherSubPointers>;
impl IPositionLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IPositionLibraryDispatcherSubPointersMut>;
impl IPositionLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IPositionLibraryDispatcherSubPointersMut>;
impl IPositionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IPositionSafeLibraryDispatcherSubPointers>;
impl IPositionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IPositionSafeLibraryDispatcherSubPointers>;
impl IPositionSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IPositionSafeLibraryDispatcherSubPointersMut>;
impl IPositionSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IPositionSafeLibraryDispatcherSubPointersMut>;
impl IPositionSafeDispatcherSubPointersDrop of core::traits::Drop::<IPositionSafeDispatcherSubPointers>;
impl IPositionSafeDispatcherSubPointersCopy of core::traits::Copy::<IPositionSafeDispatcherSubPointers>;
impl IPositionSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IPositionSafeDispatcherSubPointersMut>;
impl IPositionSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IPositionSafeDispatcherSubPointersMut>;
impl IPlayerDispatcherSubPointersDrop of core::traits::Drop::<IPlayerDispatcherSubPointers>;
impl IPlayerDispatcherSubPointersCopy of core::traits::Copy::<IPlayerDispatcherSubPointers>;
impl IPlayerDispatcherSubPointersMutDrop of core::traits::Drop::<IPlayerDispatcherSubPointersMut>;
impl IPlayerDispatcherSubPointersMutCopy of core::traits::Copy::<IPlayerDispatcherSubPointersMut>;
impl IPlayerLibraryDispatcherSubPointersDrop of core::traits::Drop::<IPlayerLibraryDispatcherSubPointers>;
impl IPlayerLibraryDispatcherSubPointersCopy of core::traits::Copy::<IPlayerLibraryDispatcherSubPointers>;
impl IPlayerLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IPlayerLibraryDispatcherSubPointersMut>;
impl IPlayerLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IPlayerLibraryDispatcherSubPointersMut>;
impl IPlayerSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IPlayerSafeLibraryDispatcherSubPointers>;
impl IPlayerSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IPlayerSafeLibraryDispatcherSubPointers>;
impl IPlayerSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IPlayerSafeLibraryDispatcherSubPointersMut>;
impl IPlayerSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IPlayerSafeLibraryDispatcherSubPointersMut>;
impl IPlayerSafeDispatcherSubPointersDrop of core::traits::Drop::<IPlayerSafeDispatcherSubPointers>;
impl IPlayerSafeDispatcherSubPointersCopy of core::traits::Copy::<IPlayerSafeDispatcherSubPointers>;
impl IPlayerSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IPlayerSafeDispatcherSubPointersMut>;
impl IPlayerSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IPlayerSafeDispatcherSubPointersMut>;
impl IModelWithSimpleArrayDispatcherSubPointersDrop of core::traits::Drop::<IModelWithSimpleArrayDispatcherSubPointers>;
impl IModelWithSimpleArrayDispatcherSubPointersCopy of core::traits::Copy::<IModelWithSimpleArrayDispatcherSubPointers>;
impl IModelWithSimpleArrayDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithSimpleArrayDispatcherSubPointersMut>;
impl IModelWithSimpleArrayDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithSimpleArrayDispatcherSubPointersMut>;
impl IModelWithSimpleArrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithSimpleArrayLibraryDispatcherSubPointers>;
impl IModelWithSimpleArrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithSimpleArrayLibraryDispatcherSubPointers>;
impl IModelWithSimpleArrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithSimpleArrayLibraryDispatcherSubPointersMut>;
impl IModelWithSimpleArrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithSimpleArrayLibraryDispatcherSubPointersMut>;
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithSimpleArraySafeLibraryDispatcherSubPointers>;
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithSimpleArraySafeLibraryDispatcherSubPointers>;
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithSimpleArraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithSimpleArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithSimpleArraySafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithSimpleArraySafeDispatcherSubPointers>;
impl IModelWithSimpleArraySafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithSimpleArraySafeDispatcherSubPointers>;
impl IModelWithSimpleArraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithSimpleArraySafeDispatcherSubPointersMut>;
impl IModelWithSimpleArraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithSimpleArraySafeDispatcherSubPointersMut>;
impl IModelWithByteArrayDispatcherSubPointersDrop of core::traits::Drop::<IModelWithByteArrayDispatcherSubPointers>;
impl IModelWithByteArrayDispatcherSubPointersCopy of core::traits::Copy::<IModelWithByteArrayDispatcherSubPointers>;
impl IModelWithByteArrayDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithByteArrayDispatcherSubPointersMut>;
impl IModelWithByteArrayDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithByteArrayDispatcherSubPointersMut>;
impl IModelWithByteArrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithByteArrayLibraryDispatcherSubPointers>;
impl IModelWithByteArrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithByteArrayLibraryDispatcherSubPointers>;
impl IModelWithByteArrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithByteArrayLibraryDispatcherSubPointersMut>;
impl IModelWithByteArrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithByteArrayLibraryDispatcherSubPointersMut>;
impl IModelWithByteArraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithByteArraySafeLibraryDispatcherSubPointers>;
impl IModelWithByteArraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithByteArraySafeLibraryDispatcherSubPointers>;
impl IModelWithByteArraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithByteArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithByteArraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithByteArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithByteArraySafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithByteArraySafeDispatcherSubPointers>;
impl IModelWithByteArraySafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithByteArraySafeDispatcherSubPointers>;
impl IModelWithByteArraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithByteArraySafeDispatcherSubPointersMut>;
impl IModelWithByteArraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithByteArraySafeDispatcherSubPointersMut>;
impl IModelWithComplexArrayDispatcherSubPointersDrop of core::traits::Drop::<IModelWithComplexArrayDispatcherSubPointers>;
impl IModelWithComplexArrayDispatcherSubPointersCopy of core::traits::Copy::<IModelWithComplexArrayDispatcherSubPointers>;
impl IModelWithComplexArrayDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithComplexArrayDispatcherSubPointersMut>;
impl IModelWithComplexArrayDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithComplexArrayDispatcherSubPointersMut>;
impl IModelWithComplexArrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithComplexArrayLibraryDispatcherSubPointers>;
impl IModelWithComplexArrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithComplexArrayLibraryDispatcherSubPointers>;
impl IModelWithComplexArrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithComplexArrayLibraryDispatcherSubPointersMut>;
impl IModelWithComplexArrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithComplexArrayLibraryDispatcherSubPointersMut>;
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithComplexArraySafeLibraryDispatcherSubPointers>;
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithComplexArraySafeLibraryDispatcherSubPointers>;
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithComplexArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithComplexArraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithComplexArraySafeLibraryDispatcherSubPointersMut>;
impl IModelWithComplexArraySafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithComplexArraySafeDispatcherSubPointers>;
impl IModelWithComplexArraySafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithComplexArraySafeDispatcherSubPointers>;
impl IModelWithComplexArraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithComplexArraySafeDispatcherSubPointersMut>;
impl IModelWithComplexArraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithComplexArraySafeDispatcherSubPointersMut>;
impl IModelWithTupleDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleDispatcherSubPointers>;
impl IModelWithTupleDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleDispatcherSubPointers>;
impl IModelWithTupleDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleDispatcherSubPointersMut>;
impl IModelWithTupleDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleDispatcherSubPointersMut>;
impl IModelWithTupleLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleLibraryDispatcherSubPointers>;
impl IModelWithTupleLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleLibraryDispatcherSubPointers>;
impl IModelWithTupleLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleLibraryDispatcherSubPointersMut>;
impl IModelWithTupleLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleLibraryDispatcherSubPointersMut>;
impl IModelWithTupleSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleSafeLibraryDispatcherSubPointers>;
impl IModelWithTupleSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleSafeLibraryDispatcherSubPointers>;
impl IModelWithTupleSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleSafeLibraryDispatcherSubPointersMut>;
impl IModelWithTupleSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleSafeLibraryDispatcherSubPointersMut>;
impl IModelWithTupleSafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleSafeDispatcherSubPointers>;
impl IModelWithTupleSafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleSafeDispatcherSubPointers>;
impl IModelWithTupleSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleSafeDispatcherSubPointersMut>;
impl IModelWithTupleSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleSafeDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesLibraryDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesLibraryDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeLibraryDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeDispatcherSubPointers>;
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut>;
impl IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IModelWithTupleNoPrimitivesSafeDispatcherSubPointersMut>;

//! > expected_diagnostics
error: Too many 'version' attributes for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> /tmp/plugin_test/model/src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> /tmp/plugin_test/model/src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> /tmp/plugin_test/model/src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> /tmp/plugin_test/model/src/lib.cairo:100:5
    id: u256
    ^^

error: Model must define at least one #[key] attribute
 --> /tmp/plugin_test/model/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:79:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:79:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:103:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:103:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:115:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:115:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:123:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:123:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:131:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:131:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:139:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:139:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:147:1
#[dojo::model]
^************^

error: Expected args.
 --> /tmp/plugin_test/model/src/lib.cairo:147:1
#[dojo::model]
^************^
