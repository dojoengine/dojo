use std::collections::{HashMap, HashSet};
use std::path::PathBuf;

use async_trait::async_trait;
use cainome::parser::tokens::{Composite, CompositeType, FunctionOutputKind, Token};
use dojo_world::contracts::naming::{get_name_from_tag, get_namespace_from_tag};

use crate::error::BindgenResult;
use crate::plugins::BuiltinPlugin;
use crate::{compare_tokens_by_type_name, DojoContract, DojoData, DojoModel};

#[derive(Debug)]
pub struct UnrealEnginePlugin {}

impl UnrealEnginePlugin {
    pub fn new() -> Self {
        Self {}
    }

    // Maps cairo types to cpp/UnrealEngine SDK defined types
    fn map_type(token: &Token) -> String {
        match token.type_name().as_str() {
            "i8" => "int".to_string(),
            "i16" => "int".to_string(),
            "i32" => "int".to_string(),
            "i64" => "long".to_string(),
            "i128" => "FString".to_string(),
            "u8" => "int".to_string(),
            "u16" => "int".to_string(),
            "u32" => "int".to_string(),
            "u64" => "long".to_string(),
            "u128" => "FString".to_string(),
            "u256" => "FString".to_string(),
            "usize" => "long".to_string(),
            "bool" => "bool".to_string(),
            "felt252" => "FString".to_string(),
            "bytes31" => "FString".to_string(),
            "ClassHash" => "FString".to_string(),
            "ContractAddress" => "FString".to_string(),
            "ByteArray" => "FString".to_string(),
            "Option" => {
                // TODO: TOptional is not handled in blueprints so we can't really use that
                panic!("Option type not handled");
            }
            "array" => {
                if let Token::Array(array) = token {
                    let mapped = UnrealEnginePlugin::map_type(&array.inner);
                    format!("TArray<{}>", mapped)
                } else {
                    panic!("Invalid array token: {:?}", token);
                }
            }
            "tuple" => {
                panic!("Tuple type not handled");
            }
            "generic_arg" => {
                if let Token::GenericArg(g) = &token {
                    g.clone()
                } else {
                    panic!("Invalid generic arg token: {:?}", token);
                }
            }
            _ => {
                let mut type_name = token.type_name().to_string();

                if let Token::Composite(composite) = token {
                    if !composite.generic_args.is_empty() {
                        type_name += &format!(
                            "<{}>",
                            composite
                                .generic_args
                                .iter()
                                .map(|(_, t)| UnrealEnginePlugin::map_type(t))
                                .collect::<Vec<_>>()
                                .join(", ")
                        )
                    }

                    let type_str = match composite.r#type {
                        CompositeType::Struct => "F".to_owned() + &type_name,
                        CompositeType::Enum => "ED".to_owned() + &type_name,
                        _ => type_name,
                    };
                    return type_str;
                }
                type_name
            }
        }
    }

    fn generated_header() -> String {
        format!(
            "// Generated by dojo-bindgen on {}. Do not modify this file manually.\n",
            chrono::Utc::now().to_rfc2822()
        )
    }

    fn header_imports() -> String {
        r#"
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "DojoModule.h"
#include "Account.h"
#include "DojoHelpers.generated.h"

UCLASS(BlueprintType)
class UDojoModel : public UObject
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString DojoModelType;
};

    "#
        .to_string()
    }

    fn cppfile_imports() -> String {
        r#"
#include "DojoHelpers.h"
#include <string>
#include <iomanip>
#include <sstream>
#include <memory>
#include "Async/Async.h"

"#
        .to_string()
    }

    // Token should be a struct
    // This will be formatted into a C# struct
    // using cpp and UnrealEngine SDK types
    fn format_struct(token: &Composite) -> String {
        let fields = token
            .inners
            .iter()
            .map(|field| {
                format!(
                    "UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    {} {};",
                    UnrealEnginePlugin::map_type(&field.token),
                    Self::to_pascal_case(&field.name)
                )
            })
            .collect::<Vec<String>>()
            .join("\n\n    ");

        format!(
            "
// Type definition for `{}` struct
USTRUCT(BlueprintType)
struct F{}
{{
    GENERATED_BODY()

    {}
}};
",
            token.type_path,
            token.type_name(),
            fields
        )
    }

    // Token should be an enum
    // This will be formatted into a C# enum
    // Enum is mapped using index of cairo enum
    fn format_enum(token: &Composite) -> String {
        let name = token.type_name();

        // Start with the UENUM declaration
        let mut result = format!("\nUENUM(BlueprintType)\nenum class ED{} : uint8\n{{\n", name);

        // Add enum values
        // Start from 0 and explicitly set values
        for (index, field) in token.inners.iter().enumerate() {
            result += &format!("    {} = {},\n", field.name, index);
        }

        // Close the enum
        result += "};\n";

        result
    }

    fn to_pascal_case(input: &str) -> String {
        let mut result = String::new();
        let mut capitalize_next = true;

        for c in input.chars() {
            if c == '_' {
                capitalize_next = true;
            } else if capitalize_next {
                result.push(c.to_ascii_uppercase());
                capitalize_next = false;
            } else {
                result.push(c.to_ascii_lowercase());
            }
        }

        result
    }

    fn format_model(namespace: &str, model: &Composite) -> String {
        let fields = model
            .inners
            .iter()
            .map(|field| {
                format!(
                    "UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    {} {};",
                    UnrealEnginePlugin::map_type(&field.token),
                    Self::to_pascal_case(&field.name),
                )
            })
            .collect::<Vec<String>>()
            .join("\n\n    ");

        format!(
            "
// Model definition for `{}` model
UCLASS(BlueprintType)
class UDojoModel{}{} : public UDojoModel
{{
    GENERATED_BODY()

public:
    {}
}};

",
            model.type_path,
            Self::to_pascal_case(namespace),
            model.type_name(),
            fields
        )
    }

    fn handle_header(
        &self,
        models: &Vec<(&String, &DojoModel)>,
        contracts: &Vec<(&String, &DojoContract)>,
    ) -> String {
        let mut out = String::new();
        out += UnrealEnginePlugin::generated_header().as_str();
        out += UnrealEnginePlugin::header_imports().as_str();
        let mut defined_enums = HashSet::<String>::new();
        let mut handled_tokens = HashMap::<String, Composite>::new();

        for (_, model) in models {
            let mut model_struct: Option<&Composite> = None;

            let tokens = &model.tokens;

            let mut sorted_structs = tokens.structs.clone();
            sorted_structs.sort_by(compare_tokens_by_type_name);

            let mut sorted_enums = tokens.enums.clone();
            sorted_enums.sort_by(compare_tokens_by_type_name);

            // Process structs first
            for token in &sorted_structs {
                if handled_tokens.contains_key(&token.type_path()) {
                    continue;
                }
                handled_tokens.insert(token.type_path(), token.to_composite().unwrap().to_owned());
                if token.type_name() == get_name_from_tag(&model.tag) {
                    model_struct = Some(token.to_composite().unwrap());
                    continue;
                }
            }

            // Process enums
            for token in &sorted_enums {
                if handled_tokens.contains_key(&token.type_path()) {
                    continue;
                }
                handled_tokens.insert(token.type_path(), token.to_composite().unwrap().to_owned());
            }

            let model_struct = model_struct.expect("model struct not found");

            // Handle struct dependencies
            let struct_keys: Vec<String> = handled_tokens
                .iter()
                .filter(|(_, s)| {
                    model_struct.inners.iter().any(|inner| {
                        s.r#type == CompositeType::Struct
                            && check_token_in_recursively(&inner.token, &s.type_name())
                            && inner.token.type_name() != "ByteArray"
                    })
                })
                .map(|(k, _)| k.clone())
                .collect();

            for key in struct_keys {
                if let Some(s) = handled_tokens.remove(&key) {
                    out += UnrealEnginePlugin::format_struct(&s).as_str();
                }
            }

            // Handle enum dependencies
            let enum_keys: Vec<String> = handled_tokens
                .iter()
                .filter(|(_, s)| {
                    model_struct.inners.iter().any(|inner| {
                        s.r#type == CompositeType::Enum
                            && check_token_in_recursively(&inner.token, &s.type_name())
                    })
                })
                .map(|(k, _)| k.clone())
                .collect();

            for key in enum_keys {
                if let Some(s) = handled_tokens.remove(&key) {
                    if !defined_enums.contains(&s.type_name()) {
                        out += UnrealEnginePlugin::format_enum(&s).as_str();
                        defined_enums.insert(s.type_name());
                    }
                }
            }

            out += "\n";
            out +=
                UnrealEnginePlugin::format_model(&get_namespace_from_tag(&model.tag), model_struct)
                    .as_str();
        }

        let parse_models_functions = models
            .iter()
            .map(|(_, model)| {
                format!(
                    "UDojoModel* parse{}{}Model(struct Struct* model);",
                    Self::to_pascal_case(&get_namespace_from_tag(&model.tag)),
                    model
                        .tokens
                        .structs
                        .iter()
                        .find(|t| t.type_name() == get_name_from_tag(&model.tag))
                        .expect("model struct not found")
                        .type_name()
                )
            })
            .collect::<Vec<_>>()
            .join("\n    ");

        let mut functions_calls: String = String::new();
        for (_, contract) in contracts {
            for system_token in contract.systems.iter().filter(|s| {
                s.to_function().unwrap().get_output_kind() as u8
                    == FunctionOutputKind::NoOutput as u8
                    && s.to_function().unwrap().name != "upgrade"
            }) {
                let args = system_token
                    .to_function()
                    .unwrap()
                    .inputs
                    .iter()
                    .map(|arg| format!("{} {}", UnrealEnginePlugin::map_type(&arg.1), &arg.0))
                    .collect::<Vec<String>>()
                    .join(", ");

                functions_calls += &format!(
                    r#"
    UFUNCTION(BlueprintCallable, Category = "Calls")
    void Call{namespace}{system}{selector}(const FAccount& account{args});

    UFUNCTION(BlueprintCallable, Category = "Controller Calls")
    void CallController{namespace}{system}{selector}(const FControllerAccount& account{args});
"#,
                    namespace = Self::to_pascal_case(&get_namespace_from_tag(&contract.tag)),
                    system = Self::to_pascal_case(&get_name_from_tag(&contract.tag)),
                    selector = Self::to_pascal_case(&system_token.to_function().unwrap().name),
                    args = if args.is_empty() { String::from("") } else { format!(", {}", args) }
                );
            }
        }

        out.push_str(&format!(
            "UCLASS()
class ADojoHelpers : public AActor
{{
    GENERATED_BODY()

private:
    ToriiClient *toriiClient;

    // To initialize using SetContractsAddresses
    TMap<FString, FString> ContractsAddresses;

    bool subscribed;

    struct Subscription *subscription;

    static ADojoHelpers* Instance;

    void ControllerAccountCallback(ControllerAccount *account);

    static void ControllerCallbackProxy(ControllerAccount *account);

    static void CallbackProxy(struct FieldElement key, struct CArrayStruct models);

    {}

    void ParseModelsAndSend(struct CArrayStruct *models);

    void ExecuteFromOutside(const FControllerAccount& account,
                            const FString& to,
                            const FString& selector,
                            const FString& calldataParameter);

    void ExecuteRawDeprecated(const FAccount& account,
                              const FString& to,
                              const FString& selector,
                              const FString& calldataParameter);

public:
    ADojoHelpers();
    ~ADojoHelpers();

    ADojoHelpers* GetGlobalInstance();
    void SetGlobalInstance(ADojoHelpers* instance);

    UFUNCTION(BlueprintCallable)
    void Connect(const FString& torii_url, const FString& world);

    UFUNCTION(BlueprintCallable)
    void SetContractsAddresses(const TMap<FString,FString>& addresses);

    UFUNCTION(BlueprintCallable)
    void FetchExistingModels();

    UFUNCTION(BlueprintCallable)
    void SubscribeOnDojoModelUpdate();

    UFUNCTION(BlueprintCallable)
    FAccount CreateAccountDeprecated(const FString& rpc_url,
                                     const FString& address,
                                     const FString& private_key);

    UFUNCTION(BlueprintCallable)
    FAccount CreateBurnerDeprecated(const FString& rpc_url,
                                    const FString& address,
                                    const FString& private_key);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnDojoModelUpdated, UDojoModel*, Model);

    UPROPERTY(BlueprintAssignable)
    FOnDojoModelUpdated OnDojoModelUpdated;

    // CONTROLLER
    UFUNCTION(BlueprintCallable)
    void ControllerGetAccountOrConnect(const FString& rpc_url, const FString& chain_id);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnDojoControllerAccount,
                                                struct FControllerAccount,
                                                Account);

    UPROPERTY(BlueprintAssignable)
    FOnDojoControllerAccount FOnDojoControllerAccount;

    // CALLS
    {}
}};",
            parse_models_functions, functions_calls
        ));

        out
    }

    fn generate_parse_models_functions(models: &[(&String, &DojoModel)]) -> String {
        let parse_models_functions_bodies = models
            .iter()
            .map(|(_, model)| {
                let structs = model
                    .tokens
                    .structs
                    .iter()
                    .find(|t| t.type_name() == get_name_from_tag(&model.tag))
                    .expect("model struct not found");
                format!(
                    "UDojoModel* ADojoHelpers::parse{namespace}{model_name}Model(struct Struct* \
                     model)
{{
    UDojoModel{namespace}{model_name}* Model = NewObject<UDojoModel{namespace}{model_name}>();
    CArrayMember* members = &model->children;

    for (int k = 0; k < members->data_len; k++) {{
        Member* member = &members->data[k];
        {process_members}
    }}

    FDojoModule::CArrayFree(members->data, members->data_len);
    return Model;
}}
",
                    namespace = Self::to_pascal_case(&get_namespace_from_tag(&model.tag)),
                    model_name = structs.type_name(),
                    process_members = structs
                        .to_composite()
                        .unwrap()
                        .inners
                        .iter()
                        .map(|field| {
                            format!(
                                r#"ConvertTyToUnrealEngineType(member, "{}", "{}", Model->{});"#,
                                &field.name,
                                &field.token.type_name(),
                                Self::to_pascal_case(&field.name),
                            )
                        })
                        .collect::<Vec<String>>()
                        .join("\n        ")
                )
            })
            .collect::<Vec<_>>()
            .join("\n");

        let if_else_parse_models = models
            .iter()
            .enumerate()
            .map(|(i, (_, model))| {
                format!(
                    r#"
        {ifelse} (strcmp(ModelName, "{namespace}-{modelName}") == 0)
        {{
            ParsedModel = \
                     ADojoHelpers::parse{namespaceCamelCase}{modelName}Model(&\
                     models->data[Index]);
        }}"#,
                    ifelse = if i == 0 { "if" } else { "else if" },
                    namespace = get_namespace_from_tag(&model.tag),
                    modelName = model
                        .tokens
                        .structs
                        .iter()
                        .find(|t| t.type_name() == get_name_from_tag(&model.tag))
                        .expect("model struct not found")
                        .type_name(),
                    namespaceCamelCase = Self::to_pascal_case(&get_namespace_from_tag(&model.tag)),
                )
            })
            .collect::<Vec<_>>()
            .join("");

        format!(
            r#"{}
void ADojoHelpers::ParseModelsAndSend(struct CArrayStruct* models)
{{
    if (!models || !models->data)
    {{
        UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Invalid input models"));
        return;
    }}

    TArray<UDojoModel*> ParsedModels;
    ParsedModels.Reserve(models->data_len);

    for (int32 Index = 0; Index < models->data_len; ++Index)
    {{
        const char* ModelName = models->data[Index].name;
        if (!ModelName)
        {{
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: null model name (%d)"), Index);
            continue;
        }}

        UDojoModel* ParsedModel = nullptr;
        {}
        else
        {{
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Unknown model type %s"), \
             UTF8_TO_TCHAR(ModelName));
            continue;
        }}

        if (ParsedModel)
        {{
            ParsedModel->DojoModelType = ModelName;
            ParsedModels.Add(ParsedModel);
        }}
        else
        {{
            UE_LOG(LogTemp, Warning, TEXT("ParseModelsAndSend: Failed to parse model %s"), \
             UTF8_TO_TCHAR(ModelName));
        }}
    }}

    if (ParsedModels.Num() > 0)
    {{
        AsyncTask(ENamedThreads::GameThread, [this, ParsedModels = MoveTemp(ParsedModels)]()
        {{
            for (UDojoModel* Model : ParsedModels)
            {{
                if (IsValid(Model))
                {{
                    OnDojoModelUpdated.Broadcast(Model);
                }}
            }}
        }});
    }}

    // Cleanup
    if (models->data)
    {{
        FDojoModule::CArrayFree(models->data, models->data_len);
    }}
}}
"#,
            parse_models_functions_bodies, if_else_parse_models
        )
    }

    fn generate_policies(contracts: &Vec<(&String, &DojoContract)>) -> String {
        let mut policies_addresses: String = String::new();
        let mut policies: String = String::new();
        let mut nb_policies = 0;
        for (_, contract) in contracts {
            let contract_name = Self::to_pascal_case(&get_namespace_from_tag(&contract.tag))
                + &Self::to_pascal_case(&get_name_from_tag(&contract.tag));
            let raw_contract_name = &format!(
                "{}-{}",
                &get_namespace_from_tag(&contract.tag),
                &get_name_from_tag(&contract.tag)
            );
            policies_addresses += &format!(
                r#"FieldElement {name}Contract;
    FDojoModule::string_to_bytes(std::string(TCHAR_TO_UTF8(*\
    this->ContractsAddresses["{raw_contract_name}"])), {name}Contract.data, 32);"#,
                name = contract_name,
                raw_contract_name = raw_contract_name,
            );

            let filtered_systems = contract.systems.iter().filter(|s| {
                let function = s.to_function().unwrap();
                function.get_output_kind() as u8 == FunctionOutputKind::NoOutput as u8
                    && function.name != "upgrade"
            });

            for system_token in filtered_systems {
                let function = system_token.to_function().unwrap();
                nb_policies += 1;

                if !policies.is_empty() {
                    policies += ",\n        ";
                }

                policies += &format!(
                    r#"{{ {}Contract, "{}", "{}" }}"#,
                    contract_name, function.name, function.name
                );
            }
        }
        format!(
            "{}
    struct Policy policies[] = {{
        {}
    }};
    int nbPolicies = {};
",
            policies_addresses, policies, nb_policies
        )
    }

    fn generate_calls_functions(contracts: &Vec<(&String, &DojoContract)>) -> String {
        let mut calls_functions: String = String::new();
        for (_, contract) in contracts {
            for system_token in contract.systems.iter().filter(|s| {
                s.to_function().unwrap().get_output_kind() as u8
                    == FunctionOutputKind::NoOutput as u8
                    && s.to_function().unwrap().name != "upgrade"
            }) {
                let args = system_token
                    .to_function()
                    .unwrap()
                    .inputs
                    .iter()
                    .map(|arg| format!("{} {}", UnrealEnginePlugin::map_type(&arg.1), &arg.0))
                    .collect::<Vec<String>>()
                    .join(", ");
                let args_body = if system_token.to_function().unwrap().inputs.is_empty() {
                    String::new()
                } else {
                    system_token
                        .to_function()
                        .unwrap()
                        .inputs
                        .iter()
                        .map(|arg| {
                            format!(
                                r#"args.Append(ConvertToFeltHexa<{arg_type}>({name}, \
                                 "{arg_dojo_type}"));"#,
                                name = &arg.0,
                                arg_dojo_type = &arg.1.type_name().as_str(),
                                arg_type = UnrealEnginePlugin::map_type(&arg.1)
                            )
                        })
                        .collect::<Vec<String>>()
                        .join("\n    ")
                };
                calls_functions += &format!(
                    r#"
void ADojoHelpers::Call{namespace}{system}{selector}(const FAccount& account{args}) {{
    TArray<FString> args;
    {args_body}
    this->ExecuteRawDeprecated(account, this->ContractsAddresses["{contract_name}"], \
                     TEXT("{selector_raw}"), FString::Join(args, TEXT(",")));
}}

void ADojoHelpers::CallController{namespace}{system}{selector}(const FControllerAccount& \
                     account{args}) {{
    TArray<FString> args;
    {args_body}
    this->ExecuteFromOutside(account, this->ContractsAddresses["{contract_name}"], \
                     TEXT("{selector_raw}"), FString::Join(args, TEXT(",")));
}}
"#,
                    namespace = Self::to_pascal_case(&get_namespace_from_tag(&contract.tag)),
                    system = Self::to_pascal_case(&get_name_from_tag(&contract.tag)),
                    selector = Self::to_pascal_case(&system_token.to_function().unwrap().name),
                    selector_raw = system_token.to_function().unwrap().name,
                    contract_name = format!(
                        "{}-{}",
                        get_namespace_from_tag(&contract.tag),
                        get_name_from_tag(&contract.tag)
                    ),
                    args = if args.is_empty() { String::from("") } else { format!(", {}", args) },
                    args_body = args_body,
                );
            }
        }
        calls_functions
    }

    fn generate_converters(models: &Vec<(&String, &DojoModel)>) -> String {
        let mut static_converters: String = String::new();
        let mut else_if_type_converter: String = String::new();
        let mut convert_custom_types_to_felt_string: String = String::new();

        let mut defined_enums = HashSet::<String>::new();
        let mut handled_tokens = HashMap::<String, Composite>::new();

        for (_, model) in models {
            let mut model_struct: Option<&Composite> = None;

            let tokens = &model.tokens;

            let mut sorted_structs = tokens.structs.clone();
            sorted_structs.sort_by(compare_tokens_by_type_name);

            let mut sorted_enums = tokens.enums.clone();
            sorted_enums.sort_by(compare_tokens_by_type_name);

            // Process structs first
            for token in &sorted_structs {
                if handled_tokens.contains_key(&token.type_path()) {
                    continue;
                }
                handled_tokens.insert(token.type_path(), token.to_composite().unwrap().to_owned());
                if token.type_name() == get_name_from_tag(&model.tag) {
                    model_struct = Some(token.to_composite().unwrap());
                }
            }

            // Process enums
            for token in &sorted_enums {
                if handled_tokens.contains_key(&token.type_path()) {
                    continue;
                }
                handled_tokens.insert(token.type_path(), token.to_composite().unwrap().to_owned());
            }

            let model_struct = model_struct.expect("model struct not found");

            // Handle struct dependencies
            let struct_keys: Vec<String> = handled_tokens
                .iter()
                .filter(|(_, s)| {
                    model_struct.inners.iter().any(|inner| {
                        s.r#type == CompositeType::Struct
                            && check_token_in_recursively(&inner.token, &s.type_name())
                            && inner.token.type_name() != "ByteArray"
                    })
                })
                .map(|(k, _)| k.clone())
                .collect();

            for key in struct_keys {
                if let Some(s) = handled_tokens.remove(&key) {
                    static_converters += &format!(
                        "static F{type_name} ConvertToF{type_name}(const Member* member) {{
        F{type_name} value;
        {struct_members}
        return value;
    }}
    ",
                        type_name = s.type_name(),
                        struct_members = s
                            .inners
                            .iter()
                            .enumerate()
                            .map(|(i, field)| {
                                format!(
                                    r#"ConvertTyToUnrealEngineType(&member->ty->struct_.children.\
                                     data[{}], "{}", "{}", value.{});"#,
                                    i,
                                    &field.name,
                                    &field.token.type_name(),
                                    Self::to_pascal_case(&field.name),
                                )
                            })
                            .collect::<Vec<String>>()
                            .join("\n        ")
                    );
                    else_if_type_converter += &format!(
                        r#"else if constexpr (std::is_same_v<T, F{type_name}>) {{
        if (strcmp(expectedType, "{type_name}") == 0) {{
            output = TypeConverter::ConvertToF{type_name}(member);
        }}
    }}
    "#,
                        type_name = s.type_name()
                    );
                    convert_custom_types_to_felt_string += &format!(
                        r#"else if constexpr (std::is_same_v<T, F{type_name}>) {{
        if (strcmp(valueType, "{type_name}") == 0) {{
            TArray<FString> strings;

            {struct_members}
            return strings;
        }}
    }}
    "#,
                        type_name = s.type_name(),
                        struct_members = s
                            .inners
                            .iter()
                            .map(|field| {
                                format!(
                                    r#"strings.Append(ConvertToFeltHexa<{cpp_type}>(value.{name}, \
                                     "{type_name}"));"#,
                                    cpp_type = Self::map_type(&field.token),
                                    name = Self::to_pascal_case(&field.name),
                                    type_name = &field.token.type_name(),
                                )
                            })
                            .collect::<Vec<String>>()
                            .join("\n            ")
                    );
                }
            }

            // Handle enum dependencies
            let enum_keys: Vec<String> = handled_tokens
                .iter()
                .filter(|(_, s)| {
                    model_struct.inners.iter().any(|inner| {
                        s.r#type == CompositeType::Enum
                            && check_token_in_recursively(&inner.token, &s.type_name())
                    })
                })
                .map(|(k, _)| k.clone())
                .collect();

            for key in enum_keys {
                if let Some(s) = handled_tokens.remove(&key) {
                    if !defined_enums.contains(&s.type_name()) {
                        static_converters += &format!(
                            "static ED{type_name} ConvertToED{type_name}(const Member* member) {{
        return static_cast<ED{type_name}>(member->ty->primitive.u8);
    }}

    ",
                            type_name = s.type_name()
                        );
                        else_if_type_converter += &format!(
                            r#"else if constexpr (std::is_same_v<T, ED{type_name}>) {{
        if (strcmp(expectedType, "{type_name}") == 0) {{
            output = TypeConverter::ConvertToED{type_name}(member);
        }}
    }}
    "#,
                            type_name = s.type_name()
                        );

                        convert_custom_types_to_felt_string += &format!(
                            r#"else if constexpr (std::is_same_v<T, {cpp_type}>) {{
        if (strcmp(valueType, "{type_name}") == 0) {{
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int>(value));
            while (hexValue.Len() < 64) {{
                hexValue = TEXT("0") + hexValue;
            }}
            return TArray<FString>{{TEXT("0x") + hexValue}};
        }}
    }}
    "#,
                            cpp_type = "ED".to_owned() + &s.type_name(),
                            type_name = s.type_name()
                        );
                        defined_enums.insert(s.type_name());
                    }
                }
            }
        }

        format!(
            r#"class TypeConverter {{
public:
    static FString ConvertToFString(const Member* member) {{
        switch (member->ty->primitive.tag) {{
            case Primitive_Tag::ContractAddress:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.contract_address.data, \
             32);
            case Primitive_Tag::I128:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.i128, 16);
            case Primitive_Tag::U128:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.u128, 16);
            case Primitive_Tag::Felt252:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.felt252.data, 32);
            case Primitive_Tag::ClassHash:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.class_hash.data, 32);
            case Primitive_Tag::EthAddress:
                return FDojoModule::bytes_to_fstring(member->ty->primitive.eth_address.data, 32);
            default:
                return FString();
        }}
    }}

    static int ConvertToInt(const Member* member) {{
        switch(member->ty->primitive.tag) {{
            case Primitive_Tag::I8:  return member->ty->primitive.i8;
            case Primitive_Tag::I16: return member->ty->primitive.i16;
            case Primitive_Tag::I32: return member->ty->primitive.i32;
            case Primitive_Tag::U8:  return member->ty->primitive.u8;
            case Primitive_Tag::U16: return member->ty->primitive.u16;
            case Primitive_Tag::U32: return member->ty->primitive.u32;
            default: return 0;
        }}
    }}

    static long ConvertToLong(const Member* member) {{
        switch(member->ty->primitive.tag) {{
            case Primitive_Tag::I64: return member->ty->primitive.i64;
            case Primitive_Tag::U64: return member->ty->primitive.u64;
            default: return 0;
        }}
    }}

    static bool ConvertToBool(const Member* member) {{
        if (member->ty->primitive.tag == Primitive_Tag::Bool) {{
            return member->ty->primitive.bool_;
        }}
        return false;
    }}

    template<typename T>
    static TArray<T> ConvertToArray(const Member* member) {{
        TArray<T> result;
        if (member->ty->tag == Ty_Tag::Array_) {{
            // Implémenter la logique de conversion d'array
            // Accéder à member->ty->array pour les données
        }}
        return result;
    }}

    {static_converters}
}};

template<typename T>
static TArray<FString> ConvertToFeltHexa(const T& value, const char* valueType) {{
    if constexpr (std::is_same_v<T, FString>) {{
        if (strcmp(valueType, "i128") == 0 ||
            strcmp(valueType, "u128") == 0 ||
            strcmp(valueType, "u256") == 0 ||
            strcmp(valueType, "felt252") == 0 ||
            strcmp(valueType, "bytes31") == 0 ||
            strcmp(valueType, "ClassHash") == 0 ||
            strcmp(valueType, "ContractAddress") == 0 ||
            strcmp(valueType, "ByteArray") == 0) {{

            // Remove "0x" if present
            FString hexValue = value;
            if (hexValue.StartsWith(TEXT("0x"))) {{
                hexValue.RightChopInline(2);
            }}

            // Pad with leading zeros to make it 64 characters
            while (hexValue.Len() < 64) {{
                hexValue = TEXT("0") + hexValue;
            }}

            // Truncate if longer than 64 characters
            if (hexValue.Len() > 64) {{
                hexValue = hexValue.Right(64);
            }}

            return TArray<FString>{{TEXT("0x") + hexValue}};
        }}
    }}
    else if constexpr (std::is_same_v<T, int>) {{
        if (strcmp(valueType, "i8") == 0 ||
            strcmp(valueType, "i16") == 0 ||
            strcmp(valueType, "i32") == 0 ||
            strcmp(valueType, "u8") == 0 ||
            strcmp(valueType, "u16") == 0 ||
            strcmp(valueType, "u32") == 0) {{
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int>(value));
            while (hexValue.Len() < 64) {{
                hexValue = TEXT("0") + hexValue;
            }}
            return TArray<FString>{{TEXT("0x") + hexValue}};
        }}
    }}
    else if constexpr (std::is_same_v<T, bool>) {{
        if (strcmp(valueType, "bool") == 0) {{
            FString hexValue = FString::Printf(TEXT("%X"), value ? 1 : 0);
            while (hexValue.Len() < 64) {{
                hexValue = TEXT("0") + hexValue;
            }}
            return TArray<FString>{{TEXT("0x") + hexValue}};
        }}
    }}
    else if constexpr (std::is_same_v<T, TArray<int>>) {{
        if (strcmp(valueType, "array") == 0) {{
            TArray<FString> strings;
            FString hexValue = FString::Printf(TEXT("%X"), static_cast<int>(value.Num()));
            while (hexValue.Len() < 64) {{
                hexValue = TEXT("0") + hexValue;
            }}
            strings.Add(TEXT("0x") + hexValue);

            // Add array elements
            for (const int& element : value) {{
                FString elementHexValue = FString::Printf(TEXT("%X"), element);
                while (elementHexValue.Len() < 64) {{
                    elementHexValue = TEXT("0") + elementHexValue;
                }}
                strings.Add(TEXT("0x") + elementHexValue);
            }}

            return strings;
        }}
    }}
    {convert_custom_types_to_felt_string}
    // Default return value padded to 64 characters
    return TArray<FString>{{TEXT("0x") + FString::ChrN(64, TEXT('0'))}};
}}

template<typename T>
static void ConvertTyToUnrealEngineType(const Member* member, const char* expectedName, const \
             char* expectedType, T& output) {{
    if (strcmp(member->name, expectedName) != 0) {{
        return;
    }}

    if constexpr (std::is_same_v<T, FString>) {{
        if (strcmp(expectedType, "i128") == 0 ||
            strcmp(expectedType, "u128") == 0 ||
            strcmp(expectedType, "u256") == 0 ||
            strcmp(expectedType, "felt252") == 0 ||
            strcmp(expectedType, "bytes31") == 0 ||
            strcmp(expectedType, "ClassHash") == 0 ||
            strcmp(expectedType, "ContractAddress") == 0 ||
            strcmp(expectedType, "ByteArray") == 0) {{
            output = TypeConverter::ConvertToFString(member);
        }}
    }}
    else if constexpr (std::is_same_v<T, int>) {{
        if (strcmp(expectedType, "i8") == 0 ||
        strcmp(expectedType, "i16") == 0 ||
        strcmp(expectedType, "i32") == 0 ||
        strcmp(expectedType, "u8") == 0 ||
        strcmp(expectedType, "u16") == 0 ||
        strcmp(expectedType, "u32") == 0) {{
            output = TypeConverter::ConvertToInt(member);
        }}
    }}
    else if constexpr (std::is_same_v<T, long>) {{
        if (strcmp(expectedType, "i64") == 0 ||
        strcmp(expectedType, "u64") == 0 ||
        strcmp(expectedType, "usize") == 0) {{
            output = TypeConverter::ConvertToLong(member);
        }}
    }}
    else if constexpr (std::is_same_v<T, bool>) {{
        if (strcmp(expectedType, "bool") == 0) {{
            output = TypeConverter::ConvertToBool(member);
        }}
    }}
    {else_if_type_converter}
}}

"#,
            static_converters = static_converters,
            else_if_type_converter = else_if_type_converter,
            convert_custom_types_to_felt_string = convert_custom_types_to_felt_string
        )
    }

    fn handle_cppfile(
        &self,
        models: &Vec<(&String, &DojoModel)>,
        contracts: &Vec<(&String, &DojoContract)>,
    ) -> String {
        let mut out = String::new();
        out += UnrealEnginePlugin::generated_header().as_str();
        out += UnrealEnginePlugin::cppfile_imports().as_str();

        let class_types_converter = Self::generate_converters(models);
        let function_parse_models = Self::generate_parse_models_functions(models);
        let policies = Self::generate_policies(contracts);
        let calls_functions_bodies = Self::generate_calls_functions(contracts);

        out += &format!(
            r#"
ADojoHelpers* ADojoHelpers::Instance = nullptr;

ADojoHelpers::ADojoHelpers()
{{
    Instance = this;
    subscribed = false;
}}

ADojoHelpers::~ADojoHelpers()
{{
    if (subscribed) {{
        FDojoModule::SubscriptionCancel(subscription);
    }}
}}

void ADojoHelpers::Connect(const FString& torii_url, const FString& world)
{{
    std::string torii_url_string = std::string(TCHAR_TO_UTF8(*torii_url));
    std::string world_string = std::string(TCHAR_TO_UTF8(*world));
    toriiClient = FDojoModule::CreateToriiClient(torii_url_string.c_str(), world_string.c_str());
    UE_LOG(LogTemp, Log, TEXT("Torii Client initialized."));
}}

void ADojoHelpers::SetContractsAddresses(const TMap<FString,FString>& addresses)
{{
    ContractsAddresses = addresses;
}}

FAccount ADojoHelpers::CreateAccountDeprecated(const FString& rpc_url, const FString& \
             address, const FString& private_key)
{{
    FAccount account;

    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string address_string = std::string(TCHAR_TO_UTF8(*address));
    std::string private_key_string = std::string(TCHAR_TO_UTF8(*private_key));
    account.account = FDojoModule::CreateAccount(rpc_url_string.c_str(), address_string.c_str(), \
             private_key_string.c_str());
    account.Address = address;
    return account;
}}

FAccount ADojoHelpers::CreateBurnerDeprecated(const FString& rpc_url, const FString& address, \
             const FString& private_key)
{{
    FAccount account;

    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string address_string = std::string(TCHAR_TO_UTF8(*address));
    std::string private_key_string = std::string(TCHAR_TO_UTF8(*private_key));
    Account *master_account = FDojoModule::CreateAccount(rpc_url_string.c_str(), \
             address_string.c_str(), private_key_string.c_str());
    if (master_account == nullptr) {{
        account.Address = UTF8_TO_TCHAR("0x0");
        return account;
    }}
    account.account = FDojoModule::CreateBurner(rpc_url_string.c_str(), master_account);
    if (account.account == nullptr) {{
        account.Address = UTF8_TO_TCHAR("0x0");
        return account;
    }}
    account.Address = FDojoModule::AccountAddress(account.account);
    return account;
}}

void ADojoHelpers::ControllerGetAccountOrConnect(const FString& rpc_url, const FString& \
             chain_id)
{{
    std::string rpc_url_string = std::string(TCHAR_TO_UTF8(*rpc_url));
    std::string chain_id_string = std::string(TCHAR_TO_UTF8(*chain_id));

    {policies}

    FDojoModule::ControllerGetAccountOrConnect(rpc_url_string.c_str(), chain_id_string.c_str(), \
             policies, nbPolicies, ControllerCallbackProxy);
}}

void ADojoHelpers::ControllerCallbackProxy(ControllerAccount *account)
{{
    if (!Instance) return;
    Instance->ControllerAccountCallback(account);
}}

void ADojoHelpers::ControllerAccountCallback(ControllerAccount *account)
{{
    // Going back to Blueprint thread to broadcast the account
    Async(EAsyncExecution::TaskGraphMainThread, [this, account]() {{
        FControllerAccount controllerAccount;
        controllerAccount.account = account;
        controllerAccount.Address = FDojoModule::ControllerAccountAddress(account);
        FOnDojoControllerAccount.Broadcast(controllerAccount);
    }});
}}

void ADojoHelpers::ExecuteRawDeprecated(const FAccount& account, const FString& to, const \
             FString& selector, const FString& calldataParameter)
{{
    Async(EAsyncExecution::Thread, [this, account, to, selector, calldataParameter]()
    {{
        std::vector<std::string> felts;
        if (strcmp(TCHAR_TO_UTF8(*calldataParameter), "") != 0) {{
            TArray<FString> Out;
            calldataParameter.ParseIntoArray(Out,TEXT(","),true);
            for (int i = 0; i < Out.Num(); i++) {{
                std::string felt = TCHAR_TO_UTF8(*Out[i]);
                felts.push_back(felt);
            }}
        }}
        FDojoModule::ExecuteRaw(account.account, TCHAR_TO_UTF8(*to), TCHAR_TO_UTF8(*selector), \
             felts);
    }});
}}

void ADojoHelpers::ExecuteFromOutside(const FControllerAccount& account, const FString& to, \
             const FString& selector, const FString& calldataParameter)
{{
    Async(EAsyncExecution::Thread, [this, account, to, selector, calldataParameter]()
    {{
        std::vector<std::string> felts;
        if (strcmp(TCHAR_TO_UTF8(*calldataParameter), "") != 0) {{
            TArray<FString> Out;
            calldataParameter.ParseIntoArray(Out,TEXT(","),true);
            for (int i = 0; i < Out.Num(); i++) {{
                std::string felt = TCHAR_TO_UTF8(*Out[i]);
                felts.push_back(felt);
            }}
        }}
        FDojoModule::ExecuteFromOutside(account.account, TCHAR_TO_UTF8(*to), \
             TCHAR_TO_UTF8(*selector), felts);
    }});
}}

void ADojoHelpers::FetchExistingModels()
{{
    Async(EAsyncExecution::Thread, [this]()
            {{
        ResultCArrayEntity resEntities =
            FDojoModule::GetEntities(toriiClient, "{{ not used }}");
        if (resEntities.tag == ErrCArrayEntity) {{
            UE_LOG(LogTemp, Log, TEXT("Failed to fetch entities: %hs"), \
             resEntities.err.message);
            return;
        }}
        CArrayEntity *entities = &resEntities.ok;

        for (int i = 0; i < entities->data_len; i++) {{
            CArrayStruct* models = &entities->data[i].models;
            this->ParseModelsAndSend(models);
        }}
        FDojoModule::CArrayFree(entities->data, entities->data_len);
    }});
    }}

void ADojoHelpers::SubscribeOnDojoModelUpdate()
{{
    UE_LOG(LogTemp, Log, TEXT("Subscribing to entity update."));
    if (subscribed) {{
        UE_LOG(LogTemp, Log, TEXT("Warning: cancelled, already subscribed."));
        return;
    }}
    if (toriiClient == nullptr) {{
        UE_LOG(LogTemp, Log, TEXT("Error: Torii Client is not initialized."));
        return;
    }}
    subscribed = true;
    struct ResultSubscription res =
        FDojoModule::OnEntityUpdate(toriiClient, "{{}}", nullptr, CallbackProxy);
    subscription = res.ok;
}}

void ADojoHelpers::CallbackProxy(struct FieldElement key, struct CArrayStruct models)
{{
    if (!Instance) return;
    Instance->ParseModelsAndSend(&models);
}}

template<typename T>
static void ConvertTyToUnrealEngineType(const Member* member, const char* expectedName, const \
             char* expectedType, T& output);

{class_types_converter}

{function_parse_models}
{calls_functions_bodies}
"#,
            policies = policies,
            class_types_converter = class_types_converter,
            function_parse_models = function_parse_models,
            calls_functions_bodies = calls_functions_bodies
        );

        out
    }
}

fn check_token_in_recursively(token: &Token, type_name: &str) -> bool {
    match token {
        Token::Composite(composite) => {
            if composite.type_name() == type_name {
                return true;
            }
            composite.inners.iter().any(|inner| check_token_in_recursively(&inner.token, type_name))
        }
        Token::Array(array) => check_token_in_recursively(&array.inner, type_name),
        Token::Tuple(tuple) => {
            tuple.inners.iter().any(|inner| check_token_in_recursively(inner, type_name))
        }
        _ => token.type_name() == type_name,
    }
}

#[async_trait]
impl BuiltinPlugin for UnrealEnginePlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut out: HashMap<PathBuf, Vec<u8>> = HashMap::new();

        let mut models = data.models.iter().collect::<Vec<_>>();
        // Sort models based on their tag to ensure deterministic output.
        models.sort_by(|(_, a), (_, b)| a.tag.cmp(&b.tag));

        let mut contracts = data.contracts.iter().collect::<Vec<_>>();
        // Sort contracts based on their tag to ensure deterministic output.
        contracts.sort_by(|(_, a), (_, b)| a.tag.cmp(&b.tag));

        println!("Generating header: DojoHelpers.h");
        let code = self.handle_header(&models, &contracts);
        out.insert("DojoHelpers.h".into(), code.as_bytes().to_vec());

        println!("Generating cpp file: DojoHelpers.cpp");
        let code = self.handle_cppfile(&models, &contracts);
        out.insert("DojoHelpers.cpp".into(), code.as_bytes().to_vec());

        Ok(out)
    }
}
