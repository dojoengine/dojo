// Mostly generated by Claude 3.5 Sonnet based on `alloy`'s `anvil` node binding <https://github.com/alloy-rs/alloy/blob/main/crates/node-bindings/src/anvil.rs> to adapt it to `katana`'s CLI arguments.

#![cfg_attr(not(test), warn(unused_crate_dependencies))]

//! Utilities for launching a Katana instance.

mod json;

use std::io::{BufRead, BufReader};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::process::{Child, Command};
use std::str::FromStr;
use std::time::{Duration, Instant};

use starknet::core::types::{FieldElement, FromStrError};
use starknet::macros::short_string;
use starknet::signers::SigningKey;
use thiserror::Error;
use tracing::trace;
use url::Url;

use crate::json::{JsonLogMessage, KatanaInfo};

/// How long we will wait for katana to indicate that it is ready.
const KATANA_STARTUP_TIMEOUT_MILLIS: u64 = 10_000;

/// Genesis accounts created by Katana
#[derive(Debug, Clone)]
pub struct Account {
    /// The account contract address
    pub address: FieldElement,
    /// The private key, if any
    pub private_key: Option<SigningKey>,
}

/// A katana CLI instance. Will close the instance when dropped.
///
/// Construct this using [`Katana`].
#[derive(Debug)]
pub struct KatanaInstance {
    port: u16,
    child: Child,
    accounts: Vec<Account>,
    chain_id: FieldElement,
}

impl KatanaInstance {
    /// Returns a reference to the child process.
    pub const fn child(&self) -> &Child {
        &self.child
    }

    /// Returns a mutable reference to the child process.
    pub fn child_mut(&mut self) -> &mut Child {
        &mut self.child
    }

    /// Returns the port of this instance
    pub const fn port(&self) -> u16 {
        self.port
    }

    /// Returns the chain of the katana instance
    pub fn chain_id(&self) -> FieldElement {
        self.chain_id
    }

    /// Returns the list of accounts created by this katana instance
    pub fn accounts(&self) -> &[Account] {
        &self.accounts
    }

    /// Returns the HTTP endpoint of this instance
    #[doc(alias = "http_endpoint")]
    pub fn endpoint(&self) -> String {
        format!("http://localhost:{}", self.port)
    }

    /// Returns the HTTP endpoint [`Url`] of this instance
    #[doc(alias = "http_endpoint_url")]
    pub fn endpoint_url(&self) -> Url {
        Url::parse(&self.endpoint()).unwrap()
    }
}

impl Drop for KatanaInstance {
    fn drop(&mut self) {
        self.child.kill().expect("could not kill katana");
    }
}

/// Errors that can occur when working with the [`Katana`].
#[derive(Debug, Error)]
pub enum Error {
    /// Spawning the katana process failed.
    #[error("could not start katana: {0}")]
    SpawnError(std::io::Error),

    /// Timed out waiting for a message from katana's stderr.
    #[error("timed out waiting for katana to spawn; is katana installed?")]
    Timeout,

    /// Unable to parse felt value from katana's stdout.
    #[error("failed to parse felt value from katana's stdout")]
    ParseFelt(#[from] FromStrError),

    /// A line could not be read from the katana stderr.
    #[error("could not read line from katana stderr: {0}")]
    ReadLineError(std::io::Error),

    /// The child katana process's stderr was not captured.
    #[error("could not get stderr for katana child process")]
    NoStderr,

    #[error("failed to parse instance address: {0}")]
    AddrParse(#[from] std::net::AddrParseError),

    /// A line indicating the account address was found but the actual value was not.
    #[error("missing account address")]
    MissingAccountAddress,

    /// A line indicating the private key was found but the actual value was not.
    #[error("missing account private key")]
    MissingAccountPrivateKey,

    /// A line indicating the instance address was found but the actual value was not.
    #[error("missing account private key")]
    MissingSocketAddr,

    #[error("encountered unexpected format: {0}")]
    UnexpectedFormat(String),
}

/// Builder for launching `katana`.
///
/// # Panics
///
/// If `spawn` is called without `katana` being available in the user's $PATH
///
/// # Example
///
/// ```no_run
/// use katana_node_bindings::Katana;
///
/// let port = 5050u16;
/// let url = format!("http://localhost:{}", port).to_string();
///
/// let katana = Katana::new().port(port).spawn();
///
/// drop(katana); // this will kill the instance
/// ```
#[derive(Clone, Debug, Default)]
#[must_use = "This Builder struct does nothing unless it is `spawn`ed"]
pub struct Katana {
    // General options
    dev: bool,
    no_mining: bool,
    json_log: bool,
    block_time: Option<u64>,
    db_dir: Option<PathBuf>,
    rpc_url: Option<String>,
    fork_block_number: Option<u64>,
    messaging: Option<PathBuf>,

    // Metrics options
    metrics: Option<String>,

    // Server options
    port: Option<u16>,
    host: Option<String>,
    max_connections: Option<u64>,
    allowed_origins: Option<String>,

    // Starknet options
    seed: Option<u64>,
    accounts: Option<u16>,
    disable_fee: bool,
    disable_validate: bool,

    // Environment options
    chain_id: Option<FieldElement>,
    validate_max_steps: Option<u64>,
    invoke_max_steps: Option<u64>,
    eth_gas_price: Option<u64>,
    strk_gas_price: Option<u64>,
    genesis: Option<PathBuf>,

    // Others
    timeout: Option<u64>,
    program: Option<PathBuf>,
}

impl Katana {
    /// Creates an empty Katana builder.
    /// The default port is 5050.
    ///
    /// # Example
    ///
    /// ```
    /// # use katana_node_bindings::Katana;
    /// fn a() {
    ///  let katana = Katana::default().spawn();
    ///
    ///  println!("Katana running at `{}`", katana.endpoint());
    /// # }
    /// ```
    pub fn new() -> Self {
        Self::default()
    }

    /// Creates a Katana builder which will execute `katana` at the given path.
    ///
    /// # Example
    ///
    /// ```
    /// # use katana_node_bindings::Katana;
    /// fn a() {
    ///  let katana = Katana::at("~/.katana/bin/katana").spawn();
    ///
    ///  println!("Katana running at `{}`", katana.endpoint());
    /// # }
    /// ```
    pub fn at(path: impl Into<PathBuf>) -> Self {
        Self::new().path(path)
    }

    /// Sets the `path` to the `katana` cli
    ///
    /// By default, it's expected that `katana` is in `$PATH`, see also
    /// [`std::process::Command::new()`]
    pub fn path<T: Into<PathBuf>>(mut self, path: T) -> Self {
        self.program = Some(path.into());
        self
    }

    /// Sets the port which will be used when the `katana` instance is launched.
    pub fn port<T: Into<u16>>(mut self, port: T) -> Self {
        self.port = Some(port.into());
        self
    }

    /// Sets the block-time in milliseconds which will be used when the `katana` instance is
    /// launched.
    pub const fn block_time(mut self, block_time: u64) -> Self {
        self.block_time = Some(block_time);
        self
    }

    /// Sets the database directory path which will be used when the `katana` instance is launched.
    pub fn db_dir<T: Into<PathBuf>>(mut self, db_dir: T) -> Self {
        self.db_dir = Some(db_dir.into());
        self
    }

    /// Sets the RPC URL to fork the network from.
    pub fn rpc_url<T: Into<String>>(mut self, rpc_url: T) -> Self {
        self.rpc_url = Some(rpc_url.into());
        self
    }

    /// Enables the dev mode.
    pub const fn dev(mut self, dev: bool) -> Self {
        self.dev = dev;
        self
    }

    /// Enables JSON logging.
    pub const fn json_log(mut self, json_log: bool) -> Self {
        self.json_log = json_log;
        self
    }

    /// Sets the fork block number which will be used when the `katana` instance is launched.
    pub const fn fork_block_number(mut self, fork_block_number: u64) -> Self {
        self.fork_block_number = Some(fork_block_number);
        self
    }

    /// Sets the messaging configuration path which will be used when the `katana` instance is
    /// launched.
    pub fn messaging<T: Into<PathBuf>>(mut self, messaging: T) -> Self {
        self.messaging = Some(messaging.into());
        self
    }

    /// Enables Prometheus metrics and sets the socket address.
    pub fn metrics<T: Into<String>>(mut self, metrics: T) -> Self {
        self.metrics = Some(metrics.into());
        self
    }

    /// Sets the host IP address the server will listen on.
    pub fn host<T: Into<String>>(mut self, host: T) -> Self {
        self.host = Some(host.into());
        self
    }

    /// Sets the maximum number of concurrent connections allowed.
    pub const fn max_connections(mut self, max_connections: u64) -> Self {
        self.max_connections = Some(max_connections);
        self
    }

    /// Enables the CORS layer and sets the allowed origins, separated by commas.
    pub fn allowed_origins<T: Into<String>>(mut self, allowed_origins: T) -> Self {
        self.allowed_origins = Some(allowed_origins.into());
        self
    }

    /// Sets the seed for randomness of accounts to be predeployed.
    pub const fn seed(mut self, seed: u64) -> Self {
        self.seed = Some(seed);
        self
    }

    /// Sets the number of pre-funded accounts to generate.
    pub fn accounts(mut self, accounts: u16) -> Self {
        self.accounts = Some(accounts);
        self
    }

    /// Enable or disable charging fee when executing transactions.
    /// Enabled by default.
    pub const fn fee(mut self, enable: bool) -> Self {
        self.disable_fee = !enable;
        self
    }

    /// Enables or disable transaction validation.
    /// Enabled by default.
    pub const fn validate(mut self, enable: bool) -> Self {
        self.disable_validate = !enable;
        self
    }

    /// Sets the chain ID.
    pub const fn chain_id(mut self, id: FieldElement) -> Self {
        self.chain_id = Some(id);
        self
    }

    /// Sets the maximum number of steps available for the account validation logic.
    pub const fn validate_max_steps(mut self, validate_max_steps: u64) -> Self {
        self.validate_max_steps = Some(validate_max_steps);
        self
    }

    /// Sets the maximum number of steps available for the account execution logic.
    pub const fn invoke_max_steps(mut self, invoke_max_steps: u64) -> Self {
        self.invoke_max_steps = Some(invoke_max_steps);
        self
    }

    /// Sets the L1 ETH gas price (denominated in wei).
    pub const fn eth_gas_price(mut self, eth_gas_price: u64) -> Self {
        self.eth_gas_price = Some(eth_gas_price);
        self
    }

    /// Sets the L1 STRK gas price (denominated in fri).
    pub const fn strk_gas_price(mut self, strk_gas_price: u64) -> Self {
        self.strk_gas_price = Some(strk_gas_price);
        self
    }

    /// Sets the genesis configuration path.
    pub fn genesis<T: Into<PathBuf>>(mut self, genesis: T) -> Self {
        self.genesis = Some(genesis.into());
        self
    }

    /// Sets the timeout which will be used when the `katana` instance is launched.
    pub const fn timeout(mut self, timeout: u64) -> Self {
        self.timeout = Some(timeout);
        self
    }

    /// Disable auto and interval mining, and mine on demand instead via an endpoint.
    pub const fn no_mining(mut self, no_mining: bool) -> Self {
        self.no_mining = no_mining;
        self
    }

    /// Consumes the builder and spawns `katana`.
    ///
    /// # Panics
    ///
    /// If spawning the instance fails at any point.
    #[track_caller]
    pub fn spawn(self) -> KatanaInstance {
        self.try_spawn().expect("could not spawn katana")
    }

    /// Consumes the builder and spawns `katana`. If spawning fails, returns an error.
    pub fn try_spawn(self) -> Result<KatanaInstance, Error> {
        let mut cmd = self.program.as_ref().map_or_else(|| Command::new("katana"), Command::new);
        cmd.stdout(std::process::Stdio::piped()).stderr(std::process::Stdio::inherit());

        let mut port = self.port.unwrap_or(0);
        cmd.arg("--port").arg(port.to_string());

        if self.no_mining {
            cmd.arg("--no-mining");
        }

        if let Some(block_time) = self.block_time {
            cmd.arg("-b").arg(block_time.to_string());
        }

        if let Some(db_dir) = self.db_dir {
            cmd.arg("--db-dir").arg(db_dir);
        }

        if let Some(rpc_url) = self.rpc_url {
            cmd.arg("--rpc-url").arg(rpc_url);
        }

        if self.dev {
            cmd.arg("--dev");
        }

        if self.json_log {
            cmd.arg("--json-log");
        }

        if let Some(fork_block_number) = self.fork_block_number {
            cmd.arg("--fork-block-number").arg(fork_block_number.to_string());
        }

        if let Some(messaging) = self.messaging {
            cmd.arg("--messaging").arg(messaging);
        }

        if let Some(metrics) = self.metrics {
            cmd.arg("--metrics").arg(metrics);
        }

        if let Some(host) = self.host {
            cmd.arg("--host").arg(host);
        }

        if let Some(max_connections) = self.max_connections {
            cmd.arg("--max-connections").arg(max_connections.to_string());
        }

        if let Some(allowed_origins) = self.allowed_origins {
            cmd.arg("--allowed-origins").arg(allowed_origins);
        }

        if let Some(seed) = self.seed {
            cmd.arg("--seed").arg(seed.to_string());
        }

        if let Some(accounts) = self.accounts {
            cmd.arg("--accounts").arg(accounts.to_string());
        }

        if self.disable_fee {
            cmd.arg("--disable-fee");
        }

        if self.disable_validate {
            cmd.arg("--disable-validate");
        }

        if let Some(chain_id) = self.chain_id {
            // Referring to katana docs:
            // "If the `str` starts with `0x` it is parsed as a hex string, otherwise it is parsed
            // as a Cairo short string."
            cmd.arg("--chain-id").arg(format!("{chain_id:#x}"));
        }

        if let Some(validate_max_steps) = self.validate_max_steps {
            cmd.arg("--validate-max-steps").arg(validate_max_steps.to_string());
        }

        let mut child = cmd.spawn().map_err(Error::SpawnError)?;
        let stdout = child.stdout.as_mut().ok_or(Error::NoStderr)?;

        let start = Instant::now();
        let mut reader = BufReader::new(stdout);

        let mut accounts = Vec::new();
        // var to store the current account being processed
        let mut current_account: Option<Account> = None;

        // TODO: the chain id should be fetched from stdout as well but Katana doesn't display the
        // chain id atm
        let chain_id = self.chain_id.unwrap_or(short_string!("KATANA"));

        loop {
            if start + Duration::from_millis(self.timeout.unwrap_or(KATANA_STARTUP_TIMEOUT_MILLIS))
                <= Instant::now()
            {
                return Err(Error::Timeout);
            }

            let mut line = String::new();
            reader.read_line(&mut line).map_err(Error::ReadLineError)?;
            trace!(line);

            if self.json_log {
                if let Ok(log) = serde_json::from_str::<JsonLogMessage>(&line) {
                    let KatanaInfo { address, accounts: account_infos, .. } = log.fields.message;

                    let addr = SocketAddr::from_str(&address)?;
                    port = addr.port();

                    for (address, info) in account_infos {
                        let address = FieldElement::from_str(&address)?;
                        let private_key = FieldElement::from_str(&info.private_key)?;
                        let key = SigningKey::from_secret_scalar(private_key);
                        accounts.push(Account { address, private_key: Some(key) });
                    }

                    break;
                }
            } else {
                const URL_PREFIX: &str = "🚀 JSON-RPC server started:";
                if line.starts_with(URL_PREFIX) {
                    // <🚀 JSON-RPC server started: http://0.0.0.0:5050>
                    let line = line.strip_prefix(URL_PREFIX).ok_or(Error::MissingSocketAddr)?;
                    let addr = line.trim();

                    // parse the actual port
                    let addr = addr.strip_prefix("http://").unwrap_or(addr);
                    let addr = SocketAddr::from_str(addr)?;
                    port = addr.port();

                    // The address is the last thing to be displayed so we can safely break here.
                    break;
                }

                const ACC_ADDRESS_PREFIX: &str = "| Account address |";
                if line.starts_with(ACC_ADDRESS_PREFIX) {
                    // If there is currently an account being handled, but we've reached the next
                    // account line, that means the previous address didn't have
                    // a private key, so we can add it to the accounts list and
                    // start processing the next account.
                    if let Some(acc) = current_account.take() {
                        accounts.push(acc);
                    }

                    let hex = line
                        .strip_prefix(ACC_ADDRESS_PREFIX)
                        .ok_or(Error::MissingAccountAddress)?
                        .trim();

                    let address = FieldElement::from_str(hex)?;
                    let account = Account { address, private_key: None };
                    current_account = Some(account);
                }

                const ACC_PK_PREFIX: &str = "| Private key     |";
                if line.starts_with(ACC_PK_PREFIX) {
                    // the private key may or may not be present for a particular account, so we
                    // have to handle both cases properly
                    let Some(acc) = current_account.take() else {
                        let msg = "Account address not found before private key".to_string();
                        return Err(Error::UnexpectedFormat(msg));
                    };

                    let hex = line
                        .strip_prefix(ACC_PK_PREFIX)
                        .ok_or(Error::MissingAccountPrivateKey)?
                        .trim();

                    let private_key = FieldElement::from_str(hex)?;
                    let signing_key = SigningKey::from_secret_scalar(private_key);
                    accounts.push(Account { private_key: Some(signing_key), ..acc });
                }
            }
        }

        Ok(KatanaInstance { port, child, accounts, chain_id })
    }
}

#[cfg(test)]
mod tests {
    use starknet::providers::jsonrpc::HttpTransport;
    use starknet::providers::{JsonRpcClient, Provider};

    use super::*;

    #[test]
    fn can_launch_katana() {
        let katana = Katana::new().spawn();
        // assert some default values
        assert_eq!(katana.accounts().len(), 10);
        assert_eq!(katana.chain_id(), short_string!("KATANA"));
        // assert that all accounts have private key
        assert!(katana.accounts().iter().all(|a| a.private_key.is_some()));
    }

    #[test]
    fn can_launch_katana_with_json_log() {
        let katana = Katana::new().json_log(true).spawn();
        // Assert default values when using JSON logging
        assert_eq!(katana.accounts().len(), 10);
        assert_eq!(katana.chain_id(), short_string!("KATANA"));
        // assert that all accounts have private key
        assert!(katana.accounts().iter().all(|a| a.private_key.is_some()));
    }

    #[test]
    fn can_launch_katana_with_more_accounts() {
        let katana = Katana::new().accounts(20).spawn();
        assert_eq!(katana.accounts().len(), 20);
    }

    #[test]
    fn assert_block_time_is_natural_number() {
        let katana = Katana::new().block_time(12);
        assert_eq!(katana.block_time.unwrap().to_string(), "12");
        let _ = katana.spawn();
    }

    #[test]
    fn can_launch_katana_with_sub_seconds_block_time() {
        let _ = Katana::new().block_time(500).spawn();
    }

    #[test]
    fn can_launch_katana_with_specific_port() {
        let specific_port = 49999;
        let katana = Katana::new().port(specific_port).spawn();
        assert_eq!(katana.port(), specific_port);
    }

    #[tokio::test]
    async fn assert_custom_chain_id() {
        let chain_id = short_string!("SN_GOERLI");
        let katana = Katana::new().chain_id(chain_id).spawn();

        let provider = JsonRpcClient::new(HttpTransport::new(katana.endpoint_url()));
        let actual_chain_id = provider.chain_id().await.unwrap();

        assert_eq!(chain_id, actual_chain_id);
    }

    #[test]
    fn can_launch_katana_with_db_dir() {
        let temp_dir = tempfile::tempdir().expect("failed to create temp dir");
        let db_path = temp_dir.path().join("test-db");
        assert!(!db_path.exists());

        let _katana = Katana::new().db_dir(db_path.clone()).spawn();

        // Check that the db directory is created
        assert!(db_path.exists());
        assert!(db_path.is_dir());
    }
}
