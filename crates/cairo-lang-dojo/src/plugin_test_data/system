//! > Test expansion of the component contract.

//! > test_function_name
test_expand_contract

//! > cairo_code
extern type Query<T>;

#[system]
mod MoveSystem {
    fn execute_inner(query: Query::<(PositionComponent::Position, HealthComponent::Health)>) {
        return ();
    }

    fn execute(
        world: felt, query: Query::<(PositionComponent::Position, HealthComponent::Health)>
    ) {
        return ();
    }
}

//! > generated_cairo_code
extern type Query<T>;

#[abi]
trait IWorld {
    fn lookup(from: felt) -> felt;
}

#[contract]
mod MoveSystem {
    use starknet::call_contract_syscall;
    use starknet::contract_address_try_from_felt;
    use array::ArrayTrait;
    use option::OptionTrait;
    use option::OptionTraitImpl;

    struct Storage {
        world_address: felt, 
    }

    #[external]
    fn initialize(world_addr: felt) {
        let world = world_address::read();
        assert(world == 0, 'MoveSystem: Already initialized.');
        world_address::write(world_addr);
    }

    #[external]
    fn execute() {
        let world = world_address::read();
        assert(world != 0, 'MoveSystem: Not initialized.');

        let position_ids = super::IWorldDispatcher::lookup(
            world, 0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897
        );
        let health_ids = super::IWorldDispatcher::lookup(
            world, 0x1690bb282da6a011c52715e2188378c769966964ca2332dccad8d7542983bc2
        );

        return ();
    }
}

//! > expected_diagnostics
