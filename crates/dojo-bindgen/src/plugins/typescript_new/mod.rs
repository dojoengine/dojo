use std::collections::HashMap;
use std::path::{Path, PathBuf};

use async_trait::async_trait;
use cainome::parser::tokens::{Composite, CompositeType, Function};
use convert_case::Casing;

use crate::error::BindgenResult;
use crate::plugins::BuiltinPlugin;
use crate::{DojoContract, DojoData, DojoModel};

pub struct TypescriptNewPlugin {}

impl TypescriptNewPlugin {
    pub fn new() -> Self {
        Self {}
    }

    // Maps cairo types to TypeScript defined types
    fn map_type(type_name: &str) -> String {
        match type_name {
            "bool" => "boolean".to_string(),
            "u8" => "number".to_string(),
            "u16" => "number".to_string(),
            "u32" => "number".to_string(),
            "u64" => "bigint".to_string(),
            "u128" => "bigint".to_string(),
            "u256" => "bigint".to_string(),
            "usize" => "number".to_string(),
            "felt252" => "string".to_string(),
            "ClassHash" => "string".to_string(),
            "ContractAddress" => "string".to_string(),

            _ => type_name.to_string(),
        }
    }

    fn pascal_to_camel(input: &str) -> String {
        let mut output = String::new();
        let mut chars = input.chars().peekable();

        while let Some(c) = chars.next() {
            if c.is_ascii_uppercase() {
                // Convert uppercase to lowercase, except for the first character
                if !output.is_empty() {
                    output.push(c.to_ascii_lowercase());
                } else {
                    output.push(c);
                }
            } else {
                output.push(c);
            }
        }

        output
    }

    fn generate_header() -> String {
        format!(
            "// Generated by dojo-bindgen on {}. Do not modify this file manually.\n",
            chrono::Utc::now().to_rfc2822()
        )
    }

    fn generate_imports() -> String {
        "import { Account } from \"starknet\";
import {
    Clause,
    Client,
    ComparisonOperator,
    ValueType,
    createClient,
} from \"@dojoengine/torii-client\";\n"
            .to_string()
    }

    fn generate_utitlity_functions() -> String {
        "//
//
// Utility types and functions
//
//

interface NumberFilter {
    eq?: number;
    neq?: number;
    gt?: number;
    gte?: number;
    lt?: number;
    lte?: number;
}

const filterMapping: Record<keyof NumberFilter, ComparisonOperator> = {
    eq: \"Eq\",
    neq: \"Neq\",
    gt: \"Gt\",
    gte: \"Gte\",
    lt: \"Lt\",
    lte: \"Lte\",
};

type ConvertNumberToFilter<T> = {
    [K in keyof T]: T[K] extends number ? NumberFilter | number : T[K];
};

type ModelClause<T> = {
    OR?: ModelClause<T>[];
    AND?: ModelClause<T>[];
} & Partial<ConvertNumberToFilter<T>>;

function valueToValueType(value: any): ValueType {
    if (typeof value === \"number\") {
        return { Int: value };
    }
    if (typeof value === \"string\") {
        return { String: value };
    }
    if (typeof value === \"boolean\") {
        return { VBool: value };
    }
    if (Array.isArray(value) && value.every((v) => typeof v === \"number\")) {
        return { Bytes: value };
    }

    throw new Error(\"Unsupported value type\");
}

function valueToToriiValueAndOperator(
    value: NumberFilter | number | bigint | string | boolean
): {
    operator: ComparisonOperator;
    value: {
        primitive_type: { Felt252: \"\" };
        value_type: ValueType;
    };
} {
    if (typeof value === \"object\") {
        const key = Object.keys(value)[0] as keyof NumberFilter;
        const operator = filterMapping[key];
        const val = value[key];
        const valueType = valueToValueType(val);
        return {
            operator,
            value: {
                primitive_type: { Felt252: \"\" },
                value_type: valueType,
            },
        };
    }

    const valueType = valueToValueType(value);
    return {
        operator: \"Eq\",
        value: {
            primitive_type: { Felt252: \"\" },
            value_type: valueType,
        },
    };
}

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model: nameMap[model as keyof typeof nameMap],
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}

function extractQueryFromResult(
    query: Query,
    result: { [key: string]: any }
): { [key: string]: any } {
    return Object.keys(query).reduce(
        (acc, key) => {
            const resultKey = Object.keys(result).find(
                (k) => k.toLowerCase() === key.toLowerCase()
            );

            if (resultKey) {
                acc[key] = result[resultKey];
            }

            return acc;
        },
        {} as { [key: string]: any }
    );
}"
        .to_string()
    }

    fn generate_query_types(models: &[&DojoModel]) -> String {
        let mut query_fields = Vec::new();
        let mut result_mapping = Vec::new();
        let mut name_map = Vec::new();

        for model in models {
            query_fields.push(format!(
                "{}: ModelClause<{}>;",
                model.name.to_case(convert_case::Case::Camel),
                model.name
            ));

            result_mapping.push(format!(
                "{}: {};",
                model.name.to_case(convert_case::Case::Camel),
                model.name
            ));

            name_map.push(format!(
                "{}: \"{}\"",
                model.name.to_case(convert_case::Case::Camel),
                model.name
            ));
        }

        format!(
            "type Query = Partial<{{
    {query_fields}
}}>;

type ResultMapping = {{
    {result_mapping}
}};

const nameMap = {{
    {name_map}
}};

type QueryResult<T extends Query> = {{
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
}};",
            query_fields = query_fields.join("\n    "),
            result_mapping = result_mapping.join("\n    "),
            name_map = name_map.join(",\n    ")
        )
    }

    // Token should be a struct
    // This will be formatted into a TypeScript interface
    // using TypeScript defined types
    fn format_struct(token: &Composite, handled_tokens: &[Composite]) -> String {
        let mut native_fields = String::new();

        for field in &token.inners {
            let mapped = TypescriptNewPlugin::map_type(field.token.type_name().as_str());
            if mapped == field.token.type_name() {
                let token = handled_tokens
                    .iter()
                    .find(|t| t.type_name() == field.token.type_name())
                    .unwrap_or_else(|| panic!("Token not found: {}", field.token.type_name()));
                if token.r#type == CompositeType::Enum {
                    native_fields += format!("{}: {};\n    ", field.name, mapped).as_str();
                } else {
                    native_fields +=
                        format!("{}: {};\n    ", field.name, field.token.type_name()).as_str();
                }
            } else {
                native_fields += format!("{}: {};\n    ", field.name, mapped).as_str();
            }
        }

        format!(
            "
// Type definition for `{path}` struct
export interface {name} {{
    {native_fields}
}}
",
            path = token.type_path,
            name = token.type_name(),
            native_fields = native_fields
        )
    }

    // Token should be an enum
    // This will be formatted into a C# enum
    // Enum is mapped using index of cairo enum
    fn format_enum(token: &Composite) -> String {
        let fields = token
            .inners
            .iter()
            .map(|field| format!("{},", field.name,))
            .collect::<Vec<String>>()
            .join("\n    ");

        format!(
            "
// Type definition for `{}` enum
export enum {} {{
    {}
}}
",
            token.type_path,
            token.type_name(),
            fields
        )
    }

    // Handles a model definition and its referenced tokens
    // Will map all structs and enums to TS types
    // Will format the models into a object
    fn handle_model(&self, models: &[&DojoModel], handled_tokens: &mut Vec<Composite>) -> String {
        let mut out = String::new();
        out += TypescriptNewPlugin::generate_header().as_str();
        out += TypescriptNewPlugin::generate_imports().as_str();
        out += "\n";
        out += TypescriptNewPlugin::generate_utitlity_functions().as_str();
        out += "\n";

        let mut models_structs = Vec::new();
        for model in models {
            let tokens = &model.tokens;

            for token in &tokens.enums {
                handled_tokens.push(token.to_composite().unwrap().to_owned());
            }
            for token in &tokens.structs {
                handled_tokens.push(token.to_composite().unwrap().to_owned());
            }

            let mut structs = tokens.structs.to_owned();
            structs.sort_by(|a, b| {
                if a.to_composite()
                    .unwrap()
                    .inners
                    .iter()
                    .any(|field| field.token.type_name() == b.type_name())
                {
                    std::cmp::Ordering::Greater
                } else {
                    std::cmp::Ordering::Less
                }
            });

            for token in &structs {
                // first index is our model struct
                if token.type_name() == model.name {
                    models_structs.push(token.to_composite().unwrap().clone());
                }

                out += TypescriptNewPlugin::format_struct(
                    token.to_composite().unwrap(),
                    handled_tokens,
                )
                .as_str();
            }

            for token in &tokens.enums {
                out += TypescriptNewPlugin::format_enum(token.to_composite().unwrap()).as_str();
            }

            out += "\n";
        }

        out += TypescriptNewPlugin::generate_query_types(models).as_str();

        out
    }

    // Formats a system into a C# method used by the contract class
    // Handled tokens should be a list of all structs and enums used by the contract
    // Such as a set of referenced tokens from a model
    fn format_system(system: &Function, handled_tokens: &[Composite]) -> String {
        let args = system
            .inputs
            .iter()
            .map(|arg| {
                format!(
                    "{}: {}",
                    arg.0,
                    if TypescriptNewPlugin::map_type(&arg.1.type_name()) == arg.1.type_name() {
                        format!("models.{}", arg.1.type_name())
                    } else {
                        TypescriptNewPlugin::map_type(&arg.1.type_name())
                    }
                )
            })
            .collect::<Vec<String>>()
            .join(", ");

        let calldata = system
            .inputs
            .iter()
            .map(|arg| {
                let token = &arg.1;
                let type_name = &arg.0;

                match handled_tokens.iter().find(|t| t.type_name() == token.type_name()) {
                    Some(t) => {
                        // Need to flatten the struct members.
                        match t.r#type {
                            CompositeType::Struct => t
                                .inners
                                .iter()
                                .map(|field| format!("props.{}.{}", type_name, field.name))
                                .collect::<Vec<String>>()
                                .join(",\n                    "),
                            _ => {
                                format!("props.{}", type_name)
                            }
                        }
                    }
                    None => format!("props.{}", type_name),
                }
            })
            .collect::<Vec<String>>()
            .join(",\n                ");

        format!(
            "
        // Call the `{system_name}` system with the specified Account and calldata
        const {pretty_system_name} = async (props: {{ account: Account{arg_sep}{args} }}) => {{
            try {{
                return await provider.execute(
                    props.account,
                    contract_name,
                    \"{system_name}\",
                    [{calldata}]
                );
            }} catch (error) {{
                console.error(\"Error executing spawn:\", error);
                throw error;
            }}
        }};
            ",
            // selector for execute
            system_name = system.name,
            // pretty system name
            // snake case to camel case
            // move_to -> moveTo
            pretty_system_name = system.name.to_case(convert_case::Case::Camel),
            // add comma if we have args
            arg_sep = if !args.is_empty() { ", " } else { "" },
            // formatted args to use our mapped types
            args = args,
            // calldata for execute
            calldata = calldata
        )
    }

    // Formats a contract file path into a pretty contract name
    // eg. dojo_examples::actions::actions.json -> Actions
    fn formatted_contract_name(contract_file_name: &str) -> String {
        let contract_name =
            contract_file_name.split("::").last().unwrap().trim_end_matches(".json");
        contract_name.to_string()
    }

    // Handles a contract definition and its underlying systems
    // Will format the contract into a C# class and
    // all systems into C# methods
    // Handled tokens should be a list of all structs and enums used by the contract
    fn handle_contracts(
        &self,
        contracts: &[&DojoContract],
        handled_tokens: &[Composite],
    ) -> String {
        let mut out = String::new();
        out += TypescriptNewPlugin::generate_header().as_str();
        out += "import { Account } from \"starknet\";\n";
        out += "import { DojoProvider } from \"@dojoengine/core\";\n";
        out += "import * as models from \"./models.gen\";\n";
        out += "\n";
        out += "export type IWorld = Awaited<ReturnType<typeof setupWorld>>;";

        out += "\n\n";

        out += "export async function setupWorld(provider: DojoProvider) {";

        for contract in contracts {
            let systems = contract
                .systems
                .iter()
                .map(|system| {
                    TypescriptNewPlugin::format_system(
                        system.to_function().unwrap(),
                        handled_tokens,
                    )
                })
                .collect::<Vec<String>>()
                .join("\n\n    ");

            out += &format!(
                "
    // System definitions for `{}` contract
    function {}() {{
        const contract_name = \"{}\";

        {}

        return {{
            {}
        }};
    }}
",
                contract.contract_file_name,
                // capitalize contract name
                TypescriptNewPlugin::formatted_contract_name(&contract.contract_file_name),
                TypescriptNewPlugin::formatted_contract_name(&contract.contract_file_name),
                systems,
                contract
                    .systems
                    .iter()
                    .map(|system| {
                        system.to_function().unwrap().name.to_case(convert_case::Case::Camel)
                    })
                    .collect::<Vec<String>>()
                    .join(", ")
            );
        }

        out += "
    return {
        ";

        out += &contracts
            .iter()
            .map(|c| {
                format!(
                    "{}: {}()",
                    TypescriptNewPlugin::formatted_contract_name(&c.contract_file_name),
                    TypescriptNewPlugin::formatted_contract_name(&c.contract_file_name)
                )
            })
            .collect::<Vec<String>>()
            .join(",\n        ");

        out += "
    };
}\n";

        out
    }
}

#[async_trait]
impl BuiltinPlugin for TypescriptNewPlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut out: HashMap<PathBuf, Vec<u8>> = HashMap::new();
        let mut handled_tokens = Vec::<Composite>::new();

        // Handle codegen for models
        let models_path = Path::new("models.gen.ts").to_owned();
        let models = data.models.values().collect::<Vec<_>>();
        let code = self.handle_model(models.as_slice(), &mut handled_tokens);

        out.insert(models_path, code.as_bytes().to_vec());

        // Handle codegen for contracts & systems
        let contracts_path = Path::new("contracts.gen.ts").to_owned();
        let contracts = data.contracts.values().collect::<Vec<_>>();
        let code = self.handle_contracts(contracts.as_slice(), &handled_tokens);

        out.insert(contracts_path, code.as_bytes().to_vec());

        Ok(out)
    }
}
