//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

impl BadModelMultipleVersionsModel of dojo::model::Model<BadModelMultipleVersions> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelMultipleVersions {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, "BadModelMultipleVersions", keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        dojo::model::Model::<BadModelMultipleVersions>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelMultipleVersions>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelMultipleVersions>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelMultipleVersions>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
}

impl BadModelBadVersionTypeModel of dojo::model::Model<BadModelBadVersionType> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelBadVersionType {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 537246025350462187868458942885902086202425585541495898150877285881426926523, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        537246025350462187868458942885902086202425585541495898150877285881426926523
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        dojo::model::Model::<BadModelBadVersionType>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelBadVersionType>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelBadVersionType>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelBadVersionType>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
}

impl BadModelNoVersionValueModel of dojo::model::Model<BadModelNoVersionValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNoVersionValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 510884764440804248641145470106421715520498065640762121627610646122289418442, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        510884764440804248641145470106421715520498065640762121627610646122289418442
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        dojo::model::Model::<BadModelNoVersionValue>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelNoVersionValue>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNoVersionValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNoVersionValue>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
}

impl BadModelUnexpectedArgWithValueModel of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArgWithValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 609798817400410974332175542242790740792842310475593325422194044359199941027, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        609798817400410974332175542242790740792842310475593325422194044359199941027
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
}

impl BadModelUnexpectedArgModel of dojo::model::Model<BadModelUnexpectedArg> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArg {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 949097735839867165379372628344008784789919991740118948112868710933218930849, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        949097735839867165379372628344008784789919991740118948112868710933218930849
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        dojo::model::Model::<BadModelUnexpectedArg>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelUnexpectedArg>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArg>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArg>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
}

impl BadModelNotSupportedVersionModel of dojo::model::Model<BadModelNotSupportedVersion> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNotSupportedVersion {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 1024306429832444281478160321067399481685861686361100808176928576017034183663, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1024306429832444281478160321067399481685861686361100808176928576017034183663
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        dojo::model::Model::<BadModelNotSupportedVersion>::selector()
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::database::introspect::Layout {
        dojo::model::Model::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<BadModelNotSupportedVersion>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNotSupportedVersion>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNotSupportedVersion>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
}

impl Modelv0Model of dojo::model::Model<Modelv0> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Modelv0 {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, "Modelv0", keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        dojo::model::Model::<Modelv0>::selector()
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::database::introspect::Layout {
        dojo::model::Model::<Modelv0>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<Modelv0>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Modelv0>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Modelv0>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
}

impl PositionModel of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 71955415935911354973604243446792437686714331401564029050333759332065302780, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        71955415935911354973604243446792437686714331401564029050333759332065302780
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        dojo::model::Model::<Position>::selector()
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::database::introspect::Layout {
        dojo::model::Model::<Position>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<Position>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Position>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Position>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
}

impl RolesModel of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 419336544500304321788712222515554985736095774968511843121228046452992595089, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        419336544500304321788712222515554985736095774968511843121228046452992595089
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        dojo::model::Model::<Roles>::selector()
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::database::introspect::Layout {
        dojo::model::Model::<Roles>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<Roles>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Roles>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Roles>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
}

impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 95348903287879133251404472882179060573633188436503276991594023731017124802, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        95348903287879133251404472882179060573633188436503276991594023731017124802
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        dojo::model::Model::<OnlyKeyModel>::selector()
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::database::introspect::Layout {
        dojo::model::Model::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<OnlyKeyModel>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<OnlyKeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<OnlyKeyModel>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
}

impl U256KeyModelModel of dojo::model::Model<U256KeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> U256KeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 1012572617804599336461526165833773117831255507291742736404237332578427043161, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1012572617804599336461526165833773117831255507291742736404237332578427043161
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        dojo::model::Model::<U256KeyModel>::selector()
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::database::introspect::Layout {
        dojo::model::Model::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<U256KeyModel>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<U256KeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<U256KeyModel>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
}

impl PlayerModel of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 711011379911436309259372467342761500657237775100998141763491044473508065524, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        711011379911436309259372467342761500657237775100998141763491044473508065524
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        dojo::model::Model::<Player>::selector()
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::database::introspect::Layout {
        dojo::model::Model::<Player>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<Player>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Player>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Player>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
}

impl ModelWithSimpleArrayModel of dojo::model::Model<ModelWithSimpleArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithSimpleArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 1666797686724122591687516812540504658474050953055875240069335038116740262482, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1666797686724122591687516812540504658474050953055875240069335038116740262482
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        dojo::model::Model::<ModelWithSimpleArray>::selector()
    }

    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::database::introspect::Layout {
        dojo::model::Model::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<ModelWithSimpleArray>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithSimpleArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithSimpleArray>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
}

impl ModelWithByteArrayModel of dojo::model::Model<ModelWithByteArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithByteArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 141311514815198970479576122039175676312992855455532566618126930677198428029, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        141311514815198970479576122039175676312992855455532566618126930677198428029
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        dojo::model::Model::<ModelWithByteArray>::selector()
    }

    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::database::introspect::Layout {
        dojo::model::Model::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<ModelWithByteArray>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithByteArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithByteArray>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
}

impl ModelWithComplexArrayModel of dojo::model::Model<ModelWithComplexArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithComplexArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 897000934674353152443993618748644314791405506479389733109858158050692281536, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        897000934674353152443993618748644314791405506479389733109858158050692281536
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        dojo::model::Model::<ModelWithComplexArray>::selector()
    }

    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::database::introspect::Layout {
        dojo::model::Model::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<ModelWithComplexArray>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithComplexArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithComplexArray>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
}

impl ModelWithTupleModel of dojo::model::Model<ModelWithTuple> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTuple {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 337716500732518130569836528184281758241439084973964029720107667501574962806, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        337716500732518130569836528184281758241439084973964029720107667501574962806
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        dojo::model::Model::<ModelWithTuple>::selector()
    }

    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::database::introspect::Layout {
        dojo::model::Model::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<ModelWithTuple>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTuple>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTuple>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
}

impl ModelWithTupleNoPrimitivesModel of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTupleNoPrimitives {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, 1607855252168926989989190762728138559179794826576658643328244347189144524311, keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1607855252168926989989190762728138559179794826576658643328244347189144524311
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
    }

    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::database::introspect::Layout {
        dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = dojo::model::Model::<ModelWithTupleNoPrimitives>::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::version()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
}

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> test_src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> test_src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> test_src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> test_src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:66:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:71:8
struct OnlyKeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:77:8
struct U256KeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> test_src/lib.cairo:77:8
struct U256KeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:70:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:76:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:82:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:94:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:102:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:110:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:118:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:126:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:70:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:70:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:70:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:76:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:76:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:76:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:82:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:82:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:82:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:94:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:94:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:94:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:102:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:102:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:102:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:110:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:110:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:110:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:118:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:118:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:118:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:126:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:126:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:126:1
#[dojo::model]
^************^
