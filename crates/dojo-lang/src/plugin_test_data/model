//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

impl BadModelMultipleAttrIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleAttr<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleAttr',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl BadModelMultipleVersionsIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleVersions<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleVersions',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelMultipleVersionsValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelMultipleVersionsModel of BadModelMultipleVersionsTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelMultipleVersions>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        )
    }

    fn set(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelMultipleVersions>::set_entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::keys(self),
            dojo::model::Model::<BadModelMultipleVersions>::values(self),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        )
    }
}

impl BadModelMultipleVersionsModelValues of dojo::model::ModelValues<BadModelMultipleVersionsValues> {
    fn values(self: @BadModelMultipleVersionsValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelMultipleVersionsValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelMultipleVersionsValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersionsValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelMultipleVersionsValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersionsValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersionsValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            id,
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelMultipleVersionsValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
    }
}

impl BadModelMultipleVersionsImpl of dojo::model::Model<BadModelMultipleVersions> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelMultipleVersions {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelMultipleVersions"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelMultipleVersions) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelMultipleVersions>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelMultipleVersions>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelMultipleVersions>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
}

impl BadModelBadVersionTypeIntrospect<> of dojo::database::introspect::Introspect<BadModelBadVersionType<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelBadVersionType',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelBadVersionTypeValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelBadVersionTypeModel of BadModelBadVersionTypeTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelBadVersionType>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        )
    }

    fn set(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelBadVersionType>::set_entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::keys(self),
            dojo::model::Model::<BadModelBadVersionType>::values(self),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        )
    }
}

impl BadModelBadVersionTypeModelValues of dojo::model::ModelValues<BadModelBadVersionTypeValues> {
    fn values(self: @BadModelBadVersionTypeValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelBadVersionTypeValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelBadVersionTypeValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionTypeValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelBadVersionTypeValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionTypeValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionTypeValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            id,
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelBadVersionTypeValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
    }
}

impl BadModelBadVersionTypeImpl of dojo::model::Model<BadModelBadVersionType> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelBadVersionType {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1257444965375069225632929782137899434201314657712945575000402601057577969467
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelBadVersionType"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelBadVersionType) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelBadVersionType>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelBadVersionType>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelBadVersionType>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
}

impl BadModelNoVersionValueIntrospect<> of dojo::database::introspect::Introspect<BadModelNoVersionValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNoVersionValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNoVersionValueValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelNoVersionValueModel of BadModelNoVersionValueTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNoVersionValue>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        )
    }

    fn set(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNoVersionValue>::set_entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::keys(self),
            dojo::model::Model::<BadModelNoVersionValue>::values(self),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        )
    }
}

impl BadModelNoVersionValueModelValues of dojo::model::ModelValues<BadModelNoVersionValueValues> {
    fn values(self: @BadModelNoVersionValueValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelNoVersionValueValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelNoVersionValueValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValueValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelNoVersionValueValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValueValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValueValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            id,
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelNoVersionValueValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
    }
}

impl BadModelNoVersionValueImpl of dojo::model::Model<BadModelNoVersionValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNoVersionValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3373097771824053354196231469173076752789704424742154674493295341772858104830
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelNoVersionValue"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelNoVersionValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNoVersionValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNoVersionValue>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNoVersionValue>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
}

impl BadModelUnexpectedArgWithValueIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArgWithValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArgWithValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgWithValueValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelUnexpectedArgWithValueModel of BadModelUnexpectedArgWithValueTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArgWithValue>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        )
    }

    fn set(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArgWithValue>::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::keys(self),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::values(self),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        )
    }
}

impl BadModelUnexpectedArgWithValueModelValues of dojo::model::ModelValues<BadModelUnexpectedArgWithValueValues> {
    fn values(self: @BadModelUnexpectedArgWithValueValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelUnexpectedArgWithValueValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelUnexpectedArgWithValueValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValueValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelUnexpectedArgWithValueValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValueValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValueValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            id,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelUnexpectedArgWithValueValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
    }
}

impl BadModelUnexpectedArgWithValueImpl of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArgWithValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3590405629214068034212593672218295377527112441964389853941077460616482660871
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelUnexpectedArgWithValue"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
}

impl BadModelUnexpectedArgIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArg<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArg',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelUnexpectedArgModel of BadModelUnexpectedArgTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArg>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        )
    }

    fn set(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArg>::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::keys(self),
            dojo::model::Model::<BadModelUnexpectedArg>::values(self),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        )
    }
}

impl BadModelUnexpectedArgModelValues of dojo::model::ModelValues<BadModelUnexpectedArgValues> {
    fn values(self: @BadModelUnexpectedArgValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelUnexpectedArgValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelUnexpectedArgValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelUnexpectedArgValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            id,
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelUnexpectedArgValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
    }
}

impl BadModelUnexpectedArgImpl of dojo::model::Model<BadModelUnexpectedArg> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArg {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1096230073778795894347893795076822536130165745015118585791241737691598280119
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelUnexpectedArg"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArg) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArg>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArg>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArg>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
}

impl BadModelNotSupportedVersionIntrospect<> of dojo::database::introspect::Introspect<BadModelNotSupportedVersion<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNotSupportedVersion',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNotSupportedVersionValues {
    v: Vec3,

}

#[generate_trait]
impl BadModelNotSupportedVersionModel of BadModelNotSupportedVersionTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNotSupportedVersion>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        )
    }

    fn set(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNotSupportedVersion>::set_entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::keys(self),
            dojo::model::Model::<BadModelNotSupportedVersion>::values(self),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        )
    }
}

impl BadModelNotSupportedVersionModelValues of dojo::model::ModelValues<BadModelNotSupportedVersionValues> {
    fn values(self: @BadModelNotSupportedVersionValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> BadModelNotSupportedVersionValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<BadModelNotSupportedVersionValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersionValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `BadModelNotSupportedVersionValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersionValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersionValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            id,
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @BadModelNotSupportedVersionValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            id,
            self.values(),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
    }
}

impl BadModelNotSupportedVersionImpl of dojo::model::Model<BadModelNotSupportedVersion> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNotSupportedVersion {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2618259498257511987977711074037130039442899457131070784132500210658539158686
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-BadModelNotSupportedVersion"
    }
    
    #[inline(always)]
    fn entity_id(self: @BadModelNotSupportedVersion) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNotSupportedVersion>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNotSupportedVersion>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNotSupportedVersion>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
}

impl Modelv0Introspect<> of dojo::database::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct Modelv0Values {
    v: Vec3,

}

#[generate_trait]
impl Modelv0Model of Modelv0Trait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Modelv0>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<Modelv0>::layout()
        )
    }

    fn set(self: @Modelv0, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Modelv0>::set_entity(
            world,
            dojo::model::Model::<Modelv0>::keys(self),
            dojo::model::Model::<Modelv0>::values(self),
            dojo::model::Model::<Modelv0>::layout()
        )
    }
}

impl Modelv0ModelValues of dojo::model::ModelValues<Modelv0Values> {
    fn values(self: @Modelv0Values) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> Modelv0Values {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<Modelv0Values>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0Values>::is_none(@entity_values) {
            panic!(
                "ModelValues `Modelv0Values`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Modelv0Values>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0Values {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            id,
            dojo::model::Model::<Modelv0>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @Modelv0Values, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            id,
            self.values(),
            dojo::model::Model::<Modelv0>::layout()
        );
    }
}

impl Modelv0Impl of dojo::model::Model<Modelv0> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Modelv0 {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-Modelv0"
    }
    
    #[inline(always)]
    fn entity_id(self: @Modelv0) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Modelv0>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Modelv0>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Modelv0>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::database::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithBadNamespaceFormatValues {
    v: Vec3,

}

#[generate_trait]
impl ModelWithBadNamespaceFormatModel of ModelWithBadNamespaceFormatTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithBadNamespaceFormat>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        )
    }

    fn set(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithBadNamespaceFormat>::set_entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::keys(self),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::values(self),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        )
    }
}

impl ModelWithBadNamespaceFormatModelValues of dojo::model::ModelValues<ModelWithBadNamespaceFormatValues> {
    fn values(self: @ModelWithBadNamespaceFormatValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithBadNamespaceFormatValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithBadNamespaceFormatValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithBadNamespaceFormatValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithBadNamespaceFormatValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithBadNamespaceFormatValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormatValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            id,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithBadNamespaceFormatValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
    }
}

impl ModelWithBadNamespaceFormatImpl of dojo::model::Model<ModelWithBadNamespaceFormat> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithBadNamespaceFormat {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithBadNamespaceFormat>::is_none(@entity) {
            panic!(
                "Model `ModelWithBadNamespaceFormat`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithBadNamespaceFormat>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3498075185010572568869958326439183660947774785526793544998939163671395407352
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithBadNamespaceFormat) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "MyNamespace"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        2518247443458975119180817677753479732439290689944304814934908400279022945373
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "MyNamespace-ModelWithBadNamespaceFormat"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithBadNamespaceFormat) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithBadNamespaceFormat) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_bad_namespace_format<T> {
    fn ensure_abi(self: @T, model: ModelWithBadNamespaceFormat);
}

#[starknet::contract]
mod model_with_bad_namespace_format {
    use super::ModelWithBadNamespaceFormat;
    use super::Imodel_with_bad_namespace_format;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_bad_namespace_formatImpl of Imodel_with_bad_namespace_format<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithBadNamespaceFormat) {
        }
    }
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithShortStringNamespaceValues {
    v: Vec3,

}

#[generate_trait]
impl ModelWithShortStringNamespaceModel of ModelWithShortStringNamespaceTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithShortStringNamespace>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        )
    }

    fn set(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithShortStringNamespace>::set_entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::keys(self),
            dojo::model::Model::<ModelWithShortStringNamespace>::values(self),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        )
    }
}

impl ModelWithShortStringNamespaceModelValues of dojo::model::ModelValues<ModelWithShortStringNamespaceValues> {
    fn values(self: @ModelWithShortStringNamespaceValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithShortStringNamespaceValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithShortStringNamespaceValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespaceValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithShortStringNamespaceValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespaceValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespaceValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            id,
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithShortStringNamespaceValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
    }
}

impl ModelWithShortStringNamespaceImpl of dojo::model::Model<ModelWithShortStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithShortStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithShortStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespace>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        643350075018191729855964658181798951445581630505240307235771395728709379388
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithShortStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "my_namespace"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        1685136890688416384941629523783652800960468745356230625531475538826800548713
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "my_namespace-ModelWithShortStringNamespace"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithShortStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithShortStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_short_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::Imodel_with_short_string_namespace;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithShortStringNamespace>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithShortStringNamespace>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithShortStringNamespace>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithShortStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_short_string_namespaceImpl of Imodel_with_short_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
}

impl ModelWithStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithStringNamespaceValues {
    v: Vec3,

}

#[generate_trait]
impl ModelWithStringNamespaceModel of ModelWithStringNamespaceTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithStringNamespace>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        )
    }

    fn set(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithStringNamespace>::set_entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::keys(self),
            dojo::model::Model::<ModelWithStringNamespace>::values(self),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        )
    }
}

impl ModelWithStringNamespaceModelValues of dojo::model::ModelValues<ModelWithStringNamespaceValues> {
    fn values(self: @ModelWithStringNamespaceValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithStringNamespaceValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithStringNamespaceValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespaceValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithStringNamespaceValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespaceValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespaceValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            id,
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithStringNamespaceValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
    }
}

impl ModelWithStringNamespaceImpl of dojo::model::Model<ModelWithStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespace>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2567055065785696374111447326195815858786390804996225951953791904194802101726
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "my_namespace"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        1685136890688416384941629523783652800960468745356230625531475538826800548713
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "my_namespace-ModelWithStringNamespace"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::Imodel_with_string_namespace;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithStringNamespace>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithStringNamespace>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithStringNamespace>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_string_namespaceImpl of Imodel_with_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
}

impl PositionIntrospect<> of dojo::database::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PositionValues {
    v: Vec3,

}

#[generate_trait]
impl PositionModel of PositionTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Position>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<Position>::layout()
        )
    }

    fn set(self: @Position, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Position>::set_entity(
            world,
            dojo::model::Model::<Position>::keys(self),
            dojo::model::Model::<Position>::values(self),
            dojo::model::Model::<Position>::layout()
        )
    }
}

impl PositionModelValues of dojo::model::ModelValues<PositionValues> {
    fn values(self: @PositionValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> PositionValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<PositionValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<PositionValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `PositionValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<PositionValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> PositionValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<Position>::selector(),
            id,
            dojo::model::Model::<Position>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @PositionValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<Position>::selector(),
            id,
            self.values(),
            dojo::model::Model::<Position>::layout()
        );
    }
}

impl PositionImpl of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2479520712854223096864276571913189358268637670027015185814050381675363770524
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-Position"
    }
    
    #[inline(always)]
    fn entity_id(self: @Position) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Position>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Position>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Position>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
}

impl RolesIntrospect<> of dojo::database::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 387776731289756409274549987067854286905927440612427426920343953432870065647,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'role_ids',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct RolesValues {
    role_ids: Array<u8>,

}

#[generate_trait]
impl RolesModel of RolesTrait {
    fn entity_id_from_keys() -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles {
        let mut serialized = core::array::ArrayTrait::new();
        

        dojo::model::Model::<Roles>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<Roles>::layout()
        )
    }

    fn set(self: @Roles, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Roles>::set_entity(
            world,
            dojo::model::Model::<Roles>::keys(self),
            dojo::model::Model::<Roles>::values(self),
            dojo::model::Model::<Roles>::layout()
        )
    }
}

impl RolesModelValues of dojo::model::ModelValues<RolesValues> {
    fn values(self: @RolesValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> RolesValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<RolesValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<RolesValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `RolesValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<RolesValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> RolesValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<Roles>::selector(),
            id,
            dojo::model::Model::<Roles>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @RolesValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<Roles>::selector(),
            id,
            self.values(),
            dojo::model::Model::<Roles>::layout()
        );
    }
}

impl RolesImpl of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        855657559905271410348750655782338503830053919297069309307754778237415879343
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-Roles"
    }
    
    #[inline(always)]
    fn entity_id(self: @Roles) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Roles>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Roles>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Roles>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
}

impl OnlyKeyModelIntrospect<> of dojo::database::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'OnlyKeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct OnlyKeyModelValues {
    
}

#[generate_trait]
impl OnlyKeyModelModel of OnlyKeyModelTrait {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<OnlyKeyModel>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<OnlyKeyModel>::layout()
        )
    }

    fn set(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<OnlyKeyModel>::set_entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::keys(self),
            dojo::model::Model::<OnlyKeyModel>::values(self),
            dojo::model::Model::<OnlyKeyModel>::layout()
        )
    }
}

impl OnlyKeyModelModelValues of dojo::model::ModelValues<OnlyKeyModelValues> {
    fn values(self: @OnlyKeyModelValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> OnlyKeyModelValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<OnlyKeyModelValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModelValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `OnlyKeyModelValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<OnlyKeyModelValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModelValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            id,
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @OnlyKeyModelValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            id,
            self.values(),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
    }
}

impl OnlyKeyModelImpl of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        185833973124429845784881936399707635120594083624714634478397191250435112638
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-OnlyKeyModel"
    }
    
    #[inline(always)]
    fn entity_id(self: @OnlyKeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<OnlyKeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<OnlyKeyModel>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<OnlyKeyModel>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
}

impl U256KeyModelIntrospect<> of dojo::database::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'U256KeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<u256>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct U256KeyModelValues {
    
}

#[generate_trait]
impl U256KeyModelModel of U256KeyModelTrait {
    fn entity_id_from_keys(id: u256) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);


        dojo::model::Model::<U256KeyModel>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<U256KeyModel>::layout()
        )
    }

    fn set(self: @U256KeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<U256KeyModel>::set_entity(
            world,
            dojo::model::Model::<U256KeyModel>::keys(self),
            dojo::model::Model::<U256KeyModel>::values(self),
            dojo::model::Model::<U256KeyModel>::layout()
        )
    }
}

impl U256KeyModelModelValues of dojo::model::ModelValues<U256KeyModelValues> {
    fn values(self: @U256KeyModelValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> U256KeyModelValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<U256KeyModelValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModelValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `U256KeyModelValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<U256KeyModelValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> U256KeyModelValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            id,
            dojo::model::Model::<U256KeyModel>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @U256KeyModelValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            id,
            self.values(),
            dojo::model::Model::<U256KeyModel>::layout()
        );
    }
}

impl U256KeyModelImpl of dojo::model::Model<U256KeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> U256KeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        313949624866121544885414428820758126526635902180652023772135974434319323806
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-U256KeyModel"
    }
    
    #[inline(always)]
    fn entity_id(self: @U256KeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<U256KeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<U256KeyModel>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<U256KeyModel>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
}

impl PlayerIntrospect<> of dojo::database::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::database::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PlayerValues {
    name: felt252,

}

#[generate_trait]
impl PlayerModel of PlayerTrait {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<Player>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<Player>::layout()
        )
    }

    fn set(self: @Player, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Player>::set_entity(
            world,
            dojo::model::Model::<Player>::keys(self),
            dojo::model::Model::<Player>::values(self),
            dojo::model::Model::<Player>::layout()
        )
    }
}

impl PlayerModelValues of dojo::model::ModelValues<PlayerValues> {
    fn values(self: @PlayerValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> PlayerValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<PlayerValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<PlayerValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `PlayerValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<PlayerValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> PlayerValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<Player>::selector(),
            id,
            dojo::model::Model::<Player>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @PlayerValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<Player>::selector(),
            id,
            self.values(),
            dojo::model::Model::<Player>::layout()
        );
    }
}

impl PlayerImpl of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3236595220905041720254406300307550499454912078227837571413280031443759061272
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-Player"
    }
    
    #[inline(always)]
    fn entity_id(self: @Player) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);
core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Player>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Player>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Player>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
}

impl ModelWithSimpleArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithSimpleArrayValues {
    x: u16,
y: Array<u8>,

}

#[generate_trait]
impl ModelWithSimpleArrayModel of ModelWithSimpleArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithSimpleArray>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        )
    }

    fn set(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithSimpleArray>::set_entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::keys(self),
            dojo::model::Model::<ModelWithSimpleArray>::values(self),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        )
    }
}

impl ModelWithSimpleArrayModelValues of dojo::model::ModelValues<ModelWithSimpleArrayValues> {
    fn values(self: @ModelWithSimpleArrayValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithSimpleArrayValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithSimpleArrayValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArrayValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithSimpleArrayValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArrayValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithSimpleArrayValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            id,
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithSimpleArrayValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
    }
}

impl ModelWithSimpleArrayImpl of dojo::model::Model<ModelWithSimpleArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithSimpleArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3015573168128997707047545520976347917082964620628387533056114714397499472255
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-ModelWithSimpleArray"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithSimpleArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithSimpleArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithSimpleArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithSimpleArray>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
}

impl ModelWithByteArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithByteArrayValues {
    x: u16,
y: ByteArray,

}

#[generate_trait]
impl ModelWithByteArrayModel of ModelWithByteArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithByteArray>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithByteArray>::layout()
        )
    }

    fn set(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithByteArray>::set_entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::keys(self),
            dojo::model::Model::<ModelWithByteArray>::values(self),
            dojo::model::Model::<ModelWithByteArray>::layout()
        )
    }
}

impl ModelWithByteArrayModelValues of dojo::model::ModelValues<ModelWithByteArrayValues> {
    fn values(self: @ModelWithByteArrayValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithByteArrayValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithByteArrayValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArrayValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithByteArrayValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithByteArrayValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithByteArrayValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            id,
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithByteArrayValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
    }
}

impl ModelWithByteArrayImpl of dojo::model::Model<ModelWithByteArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithByteArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1495813766814131974177657304275361143893541941399872042870855060582891570868
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-ModelWithByteArray"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithByteArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithByteArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithByteArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithByteArray>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
}

impl ModelWithComplexArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithComplexArrayValues {
    x: u16,
y: Array<Vec3>,

}

#[generate_trait]
impl ModelWithComplexArrayModel of ModelWithComplexArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithComplexArray>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        )
    }

    fn set(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithComplexArray>::set_entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::keys(self),
            dojo::model::Model::<ModelWithComplexArray>::values(self),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        )
    }
}

impl ModelWithComplexArrayModelValues of dojo::model::ModelValues<ModelWithComplexArrayValues> {
    fn values(self: @ModelWithComplexArrayValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithComplexArrayValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithComplexArrayValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArrayValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithComplexArrayValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArrayValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithComplexArrayValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            id,
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithComplexArrayValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
    }
}

impl ModelWithComplexArrayImpl of dojo::model::Model<ModelWithComplexArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithComplexArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        36330270687495804813979499325154873801411429162367231362587376627277795482
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-ModelWithComplexArray"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithComplexArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithComplexArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithComplexArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithComplexArray>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
}

impl ModelWithTupleIntrospect<> of dojo::database::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<u16>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<u16>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleValues {
    x: u16,
y: (u8, u16, u32),

}

#[generate_trait]
impl ModelWithTupleModel of ModelWithTupleTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTuple>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithTuple>::layout()
        )
    }

    fn set(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTuple>::set_entity(
            world,
            dojo::model::Model::<ModelWithTuple>::keys(self),
            dojo::model::Model::<ModelWithTuple>::values(self),
            dojo::model::Model::<ModelWithTuple>::layout()
        )
    }
}

impl ModelWithTupleModelValues of dojo::model::ModelValues<ModelWithTupleValues> {
    fn values(self: @ModelWithTupleValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithTupleValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithTupleValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithTupleValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithTupleValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithTupleValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            id,
            dojo::model::Model::<ModelWithTuple>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithTupleValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
    }
}

impl ModelWithTupleImpl of dojo::model::Model<ModelWithTuple> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTuple {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2968932965114787437968555813812827702683268243780347884633996291362924490633
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-ModelWithTuple"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithTuple) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTuple>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTuple>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTuple>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::database::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::database::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::database::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::database::utils::sum(sizes))
                
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<Vec3>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<Vec3>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleNoPrimitivesValues {
    x: u16,
y: (u8, Vec3, u32),

}

#[generate_trait]
impl ModelWithTupleNoPrimitivesModel of ModelWithTupleNoPrimitivesTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTupleNoPrimitives>::entity(
            world,
            serialized.span(),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        )
    }

    fn set(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTupleNoPrimitives>::set_entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::keys(self),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::values(self),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        )
    }
}

impl ModelWithTupleNoPrimitivesModelValues of dojo::model::ModelValues<ModelWithTupleNoPrimitivesValues> {
    fn values(self: @ModelWithTupleNoPrimitivesValues) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(values: Span<felt252>) -> ModelWithTupleNoPrimitivesValues {
        let mut serialized = values;
        let entity_values = core::serde::Serde::<ModelWithTupleNoPrimitivesValues>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitivesValues>::is_none(@entity_values) {
            panic!(
                "ModelValues `ModelWithTupleNoPrimitivesValues`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitivesValues>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithTupleNoPrimitivesValues {
        let values = dojo::world::IWorldDispatcherTrait::entity_by_id(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            id,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
        Self::from_values(values)
    }

    fn set(self: @ModelWithTupleNoPrimitivesValues, world: dojo::world::IWorldDispatcher, id: felt252) {
        dojo::world::IWorldDispatcherTrait::set_entity_by_id(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            id,
            self.values(),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
    }
}

impl ModelWithTupleNoPrimitivesImpl of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTupleNoPrimitives {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    fn set_entity(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        values: Span<felt252>,
        layout: dojo::database::introspect::Layout
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            keys,
            values,
            layout
        );
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1303002480984182254910512996281734914702552284127358821084351389028444664680
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_plugin-ModelWithTupleNoPrimitives"
    }
    
    #[inline(always)]
    fn entity_id(self: @ModelWithTupleNoPrimitives) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace_selector()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::tag()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
}
impl BadModelMultipleVersionsValuesDrop of core::traits::Drop::<BadModelMultipleVersionsValues>;
impl BadModelMultipleVersionsValuesSerde of core::serde::Serde::<BadModelMultipleVersionsValues> {
    fn serialize(self: @BadModelMultipleVersionsValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelMultipleVersionsValues> {
        core::option::Option::Some(BadModelMultipleVersionsValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelMultipleVersionsTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions;

    fn set(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher);
}
impl BadModelBadVersionTypeValuesDrop of core::traits::Drop::<BadModelBadVersionTypeValues>;
impl BadModelBadVersionTypeValuesSerde of core::serde::Serde::<BadModelBadVersionTypeValues> {
    fn serialize(self: @BadModelBadVersionTypeValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelBadVersionTypeValues> {
        core::option::Option::Some(BadModelBadVersionTypeValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelBadVersionTypeTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType;

    fn set(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher);
}
impl BadModelNoVersionValueValuesDrop of core::traits::Drop::<BadModelNoVersionValueValues>;
impl BadModelNoVersionValueValuesSerde of core::serde::Serde::<BadModelNoVersionValueValues> {
    fn serialize(self: @BadModelNoVersionValueValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNoVersionValueValues> {
        core::option::Option::Some(BadModelNoVersionValueValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelNoVersionValueTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue;

    fn set(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher);
}
impl BadModelUnexpectedArgWithValueValuesDrop of core::traits::Drop::<BadModelUnexpectedArgWithValueValues>;
impl BadModelUnexpectedArgWithValueValuesSerde of core::serde::Serde::<BadModelUnexpectedArgWithValueValues> {
    fn serialize(self: @BadModelUnexpectedArgWithValueValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgWithValueValues> {
        core::option::Option::Some(BadModelUnexpectedArgWithValueValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelUnexpectedArgWithValueTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue;

    fn set(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher);
}
impl BadModelUnexpectedArgValuesDrop of core::traits::Drop::<BadModelUnexpectedArgValues>;
impl BadModelUnexpectedArgValuesSerde of core::serde::Serde::<BadModelUnexpectedArgValues> {
    fn serialize(self: @BadModelUnexpectedArgValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgValues> {
        core::option::Option::Some(BadModelUnexpectedArgValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelUnexpectedArgTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg;

    fn set(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher);
}
impl BadModelNotSupportedVersionValuesDrop of core::traits::Drop::<BadModelNotSupportedVersionValues>;
impl BadModelNotSupportedVersionValuesSerde of core::serde::Serde::<BadModelNotSupportedVersionValues> {
    fn serialize(self: @BadModelNotSupportedVersionValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNotSupportedVersionValues> {
        core::option::Option::Some(BadModelNotSupportedVersionValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait BadModelNotSupportedVersionTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion;

    fn set(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher);
}
impl Modelv0ValuesDrop of core::traits::Drop::<Modelv0Values>;
impl Modelv0ValuesSerde of core::serde::Serde::<Modelv0Values> {
    fn serialize(self: @Modelv0Values, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Modelv0Values> {
        core::option::Option::Some(Modelv0Values {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait Modelv0Trait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0;

    fn set(self: @Modelv0, world: dojo::world::IWorldDispatcher);
}
impl ModelWithBadNamespaceFormatValuesDrop of core::traits::Drop::<ModelWithBadNamespaceFormatValues>;
impl ModelWithBadNamespaceFormatValuesSerde of core::serde::Serde::<ModelWithBadNamespaceFormatValues> {
    fn serialize(self: @ModelWithBadNamespaceFormatValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithBadNamespaceFormatValues> {
        core::option::Option::Some(ModelWithBadNamespaceFormatValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithBadNamespaceFormatTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat;

    fn set(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher);
}
impl ModelWithShortStringNamespaceValuesDrop of core::traits::Drop::<ModelWithShortStringNamespaceValues>;
impl ModelWithShortStringNamespaceValuesSerde of core::serde::Serde::<ModelWithShortStringNamespaceValues> {
    fn serialize(self: @ModelWithShortStringNamespaceValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithShortStringNamespaceValues> {
        core::option::Option::Some(ModelWithShortStringNamespaceValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithShortStringNamespaceTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace;

    fn set(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher);
}
impl ModelWithStringNamespaceValuesDrop of core::traits::Drop::<ModelWithStringNamespaceValues>;
impl ModelWithStringNamespaceValuesSerde of core::serde::Serde::<ModelWithStringNamespaceValues> {
    fn serialize(self: @ModelWithStringNamespaceValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithStringNamespaceValues> {
        core::option::Option::Some(ModelWithStringNamespaceValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithStringNamespaceTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace;

    fn set(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher);
}
impl PositionValuesDrop of core::traits::Drop::<PositionValues>;
impl PositionValuesSerde of core::serde::Serde::<PositionValues> {
    fn serialize(self: @PositionValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PositionValues> {
        core::option::Option::Some(PositionValues {
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait PositionTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position;

    fn set(self: @Position, world: dojo::world::IWorldDispatcher);
}
impl RolesValuesDrop of core::traits::Drop::<RolesValues>;
impl RolesValuesSerde of core::serde::Serde::<RolesValues> {
    fn serialize(self: @RolesValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.role_ids, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<RolesValues> {
        core::option::Option::Some(RolesValues {
            role_ids: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait RolesTrait {
    fn entity_id_from_keys() -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles;

    fn set(self: @Roles, world: dojo::world::IWorldDispatcher);
}
impl OnlyKeyModelValuesDrop of core::traits::Drop::<OnlyKeyModelValues>;
impl OnlyKeyModelValuesSerde of core::serde::Serde::<OnlyKeyModelValues> {
    fn serialize(self: @OnlyKeyModelValues, ref output: core::array::Array<felt252>) {
        
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<OnlyKeyModelValues> {
        core::option::Option::Some(OnlyKeyModelValues {
            
        })
    }
}
trait OnlyKeyModelTrait {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel;

    fn set(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher);
}
impl U256KeyModelValuesDrop of core::traits::Drop::<U256KeyModelValues>;
impl U256KeyModelValuesSerde of core::serde::Serde::<U256KeyModelValues> {
    fn serialize(self: @U256KeyModelValues, ref output: core::array::Array<felt252>) {
        
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<U256KeyModelValues> {
        core::option::Option::Some(U256KeyModelValues {
            
        })
    }
}
trait U256KeyModelTrait {
    fn entity_id_from_keys(id: u256) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel;

    fn set(self: @U256KeyModel, world: dojo::world::IWorldDispatcher);
}
impl PlayerValuesDrop of core::traits::Drop::<PlayerValues>;
impl PlayerValuesSerde of core::serde::Serde::<PlayerValues> {
    fn serialize(self: @PlayerValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.name, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PlayerValues> {
        core::option::Option::Some(PlayerValues {
            name: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait PlayerTrait {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player;

    fn set(self: @Player, world: dojo::world::IWorldDispatcher);
}
impl ModelWithSimpleArrayValuesDrop of core::traits::Drop::<ModelWithSimpleArrayValues>;
impl ModelWithSimpleArrayValuesSerde of core::serde::Serde::<ModelWithSimpleArrayValues> {
    fn serialize(self: @ModelWithSimpleArrayValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithSimpleArrayValues> {
        core::option::Option::Some(ModelWithSimpleArrayValues {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithSimpleArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray;

    fn set(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher);
}
impl ModelWithByteArrayValuesDrop of core::traits::Drop::<ModelWithByteArrayValues>;
impl ModelWithByteArrayValuesSerde of core::serde::Serde::<ModelWithByteArrayValues> {
    fn serialize(self: @ModelWithByteArrayValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithByteArrayValues> {
        core::option::Option::Some(ModelWithByteArrayValues {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithByteArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray;

    fn set(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher);
}
impl ModelWithComplexArrayValuesDrop of core::traits::Drop::<ModelWithComplexArrayValues>;
impl ModelWithComplexArrayValuesSerde of core::serde::Serde::<ModelWithComplexArrayValues> {
    fn serialize(self: @ModelWithComplexArrayValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithComplexArrayValues> {
        core::option::Option::Some(ModelWithComplexArrayValues {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithComplexArrayTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray;

    fn set(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher);
}
impl ModelWithTupleValuesDrop of core::traits::Drop::<ModelWithTupleValues>;
impl ModelWithTupleValuesSerde of core::serde::Serde::<ModelWithTupleValues> {
    fn serialize(self: @ModelWithTupleValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleValues> {
        core::option::Option::Some(ModelWithTupleValues {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithTupleTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple;

    fn set(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher);
}
impl ModelWithTupleNoPrimitivesValuesDrop of core::traits::Drop::<ModelWithTupleNoPrimitivesValues>;
impl ModelWithTupleNoPrimitivesValuesSerde of core::serde::Serde::<ModelWithTupleNoPrimitivesValues> {
    fn serialize(self: @ModelWithTupleNoPrimitivesValues, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleNoPrimitivesValues> {
        core::option::Option::Some(ModelWithTupleNoPrimitivesValues {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
trait ModelWithTupleNoPrimitivesTrait {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives;

    fn set(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher);
}

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> test_src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> test_src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> test_src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> test_src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> test_src/lib.cairo:100:5
    id: u256
    ^^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[dojo::model(namespace: 'MyNamespace')]
^**************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^
