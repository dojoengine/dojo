//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}
impl BadModelMultipleAttrIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleAttr<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleAttr',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl BadModelMultipleVersionsIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleVersions<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleVersions',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelMultipleVersionsModel of dojo::model::Model<BadModelMultipleVersions> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelMultipleVersions {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3538888628466873673221842373412072042558277047191927145880480325050722136660
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelMultipleVersions>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelMultipleVersions>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelMultipleVersions>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_multiple_versionsImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_multiple_versionsImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_multiple_versionsImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelBadVersionTypeIntrospect<> of dojo::database::introspect::Introspect<BadModelBadVersionType<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelBadVersionType',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelBadVersionTypeModel of dojo::model::Model<BadModelBadVersionType> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelBadVersionType {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3424346430891629531332762252537876298286978002978132542474104837759156545171
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        760683829940564015458541272487101565210915690045377810379189532484191344547
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelBadVersionType>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelBadVersionType>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelBadVersionType>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_bad_version_typeImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelBadVersionType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_bad_version_typeImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_bad_version_typeImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelNoVersionValueIntrospect<> of dojo::database::introspect::Introspect<BadModelNoVersionValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNoVersionValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelNoVersionValueModel of dojo::model::Model<BadModelNoVersionValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNoVersionValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3137507464979648719446085887369604472442296862296217793557428940425307809922
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2459365230136118590954025890011480023818926626380754992635699340900694864996
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNoVersionValue>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNoVersionValue>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNoVersionValue>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_no_version_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_no_version_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_no_version_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelUnexpectedArgWithValueIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArgWithValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArgWithValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelUnexpectedArgWithValueModel of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArgWithValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3162902274274075293574414479899149167035238805798288683939511839395372839584
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3586339245084542986020591057627093254376225984628310828088084183494435682971
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_arg_with_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelUnexpectedArgIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArg<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArg',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelUnexpectedArgModel of dojo::model::Model<BadModelUnexpectedArg> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArg {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2062327100205703339988289387876316143748074129748784084948535166252334131324
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        246403407829267991441535935236143476032296881039254363860883767387993960270
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArg>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArg>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArg>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_argImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_argImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_argImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelNotSupportedVersionIntrospect<> of dojo::database::introspect::Introspect<BadModelNotSupportedVersion<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNotSupportedVersion',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelNotSupportedVersionModel of dojo::model::Model<BadModelNotSupportedVersion> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNotSupportedVersion {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2399868061331388591523307843619168972583102717296603562171130686072940081207
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1812257929012908024237871796629728977392496349235879470060252299886369485820
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNotSupportedVersion>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNotSupportedVersion>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNotSupportedVersion>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__bad_model_not_supported_versionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_not_supported_versionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_not_supported_versionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl Modelv0Introspect<> of dojo::database::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl Modelv0Model of dojo::model::Model<Modelv0> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Modelv0 {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2212879130471315306779111820244908968466545702031328551192231795237740448313
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Modelv0>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Modelv0>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Modelv0>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__modelv_0Impl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Modelv0>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    modelv_0Impl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__modelv_0Impl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::database::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithBadNamespaceFormatModel of dojo::model::Model<ModelWithBadNamespaceFormat> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithBadNamespaceFormat {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithBadNamespaceFormat>::is_none(@entity) {
            panic!(
                "Model `ModelWithBadNamespaceFormat`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithBadNamespaceFormat>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3059539413433693207383279334860020534329215374860715071558931541261069058621
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithBadNamespaceFormat) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        513559242384681567568052881519197161166285694153303371154270254637843894159
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithBadNamespaceFormat) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_bad_namespace_format<T> {
    fn ensure_abi(self: @T, model: ModelWithBadNamespaceFormat);
}

#[starknet::contract]
mod model_with_bad_namespace_format {
    use super::ModelWithBadNamespaceFormat;
    use super::Imodel_with_bad_namespace_format;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithBadNamespaceFormat>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_bad_namespace_formatImpl of Imodel_with_bad_namespace_format<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithBadNamespaceFormat) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_bad_namespace_formatImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_bad_namespace_formatImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_bad_namespace_formatImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithShortStringNamespaceModel of dojo::model::Model<ModelWithShortStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithShortStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithShortStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespace>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        516169310422367104631924468147010406642920381144711483043394373786075028578
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithShortStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        4646597166239297873853881466258165424425132957303541470648153031188639878
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithShortStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_short_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::Imodel_with_short_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithShortStringNamespace>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithShortStringNamespace>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithShortStringNamespace>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithShortStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_short_string_namespaceImpl of Imodel_with_short_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_short_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_short_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_short_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithStringNamespaceModel of dojo::model::Model<ModelWithStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespace>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2244952983831849087562617629161882602941157493177409459461888999685738447838
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        36187013840655350498900857372670392628596870210415176261336407419317644423
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::Imodel_with_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithStringNamespace>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithStringNamespace>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithStringNamespace>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_string_namespaceImpl of Imodel_with_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl PositionIntrospect<> of dojo::database::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl PositionModel of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2583140722357655302813194934296353271867745884944715988664292532004552033294
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2899920299641094436341712346886623904698864491830316325765258522168980161362
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Position>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Position>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Position>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__positionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Position>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    positionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__positionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl RolesIntrospect<> of dojo::database::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 387776731289756409274549987067854286905927440612427426920343953432870065647,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'role_ids',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl RolesModel of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2381319068167303801085530774544728044506110381004500761927797648058170896946
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2030971736961612564423689930729061756599290850089001157163423482274886199516
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Roles>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Roles>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Roles>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__rolesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Roles>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    rolesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__rolesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl OnlyKeyModelIntrospect<> of dojo::database::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'OnlyKeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        399971050958024375507922651483187108363916132710819632852036528607645634778
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1001826121797570811408809643478760373535949956555931325019299477987282578617
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<OnlyKeyModel>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<OnlyKeyModel>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<OnlyKeyModel>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__only_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<OnlyKeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    only_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__only_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl U256KeyModelIntrospect<> of dojo::database::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'U256KeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<u256>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl U256KeyModelModel of dojo::model::Model<U256KeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> U256KeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3403346971723769227042162502675592040860576799654783499419654467804113799823
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1848733002266458148515852001373055968326209639346734967305014900020806934517
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<U256KeyModel>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<U256KeyModel>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<U256KeyModel>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__u_256_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<U256KeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    u_256_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__u_256_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl PlayerIntrospect<> of dojo::database::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::database::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl PlayerModel of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3068209845672224878774101526910835120619854456556690065951127565061014675679
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1073075359926275415180704315933677548333097210683379121732618306925003101845
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Player>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Player>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Player>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__playerImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Player>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    playerImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__playerImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithSimpleArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithSimpleArrayModel of dojo::model::Model<ModelWithSimpleArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithSimpleArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        516248842335934132822768408262411488579427278776919857986291389606250466377
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        173141902001925402715103859951360389436088950156916962046507357841237663931
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithSimpleArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithSimpleArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithSimpleArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_simple_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_simple_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_simple_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithByteArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithByteArrayModel of dojo::model::Model<ModelWithByteArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithByteArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        858867864009207556499907034628308336720989886132468668210801974294049151990
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2176409715042145900636260236501596599545103472111273072320531220776338338674
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithByteArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithByteArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithByteArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_byte_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithByteArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_byte_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_byte_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithComplexArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithComplexArrayModel of dojo::model::Model<ModelWithComplexArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithComplexArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        298653312264896693167501639402458085580783343254117966446641652721994965516
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2866472224509756243720005045848892642397514372569303051745174230372637769655
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithComplexArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithComplexArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithComplexArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_complex_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithComplexArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_complex_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_complex_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithTupleIntrospect<> of dojo::database::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<u16>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<u16>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithTupleModel of dojo::model::Model<ModelWithTuple> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTuple {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3520389162382437315776520663535583701836688108885454850509972628400715241
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3222351670132870101782632958288197874250493316621507272653773018669253981260
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTuple>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTuple>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTuple>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_tupleImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTuple>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tupleImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tupleImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::database::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::database::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::database::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::database::utils::sum(sizes))
                
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<Vec3>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<Vec3>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithTupleNoPrimitivesModel of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTupleNoPrimitives {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2133652848391750418502705747419625263797079439106286994977255727801602328040
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        157059227407493660591195028728750607977045261142495925435047270200565107096
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }
    
    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::database::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__model_with_tuple_no_primitivesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tuple_no_primitivesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tuple_no_primitivesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}
trait Ibad_model_multiple_versionsDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelMultipleVersions);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_multiple_versionsDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_multiple_versionsLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsLibraryDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsLibraryDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_multiple_versionsSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelMultipleVersions) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_multiple_versionsSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsSafeLibraryDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeLibraryDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_multiple_versionsSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsSafeDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ibad_model_bad_version_typeDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelBadVersionType);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_bad_version_typeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_bad_version_typeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeLibraryDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeLibraryDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_bad_version_typeSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelBadVersionType) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_bad_version_typeSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeSafeLibraryDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeLibraryDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_bad_version_typeSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeSafeDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ibad_model_no_version_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNoVersionValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_no_version_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_no_version_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueLibraryDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueLibraryDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_no_version_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNoVersionValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_no_version_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueSafeLibraryDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeLibraryDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_no_version_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueSafeDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ibad_model_unexpected_arg_with_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_arg_with_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueLibraryDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_arg_with_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueSafeDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ibad_model_unexpected_argDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArg);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_argDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_argLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argLibraryDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argLibraryDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_unexpected_argSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_argSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argSafeLibraryDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeLibraryDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_unexpected_argSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argSafeDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ibad_model_not_supported_versionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_not_supported_versionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_not_supported_versionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionLibraryDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionLibraryDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ibad_model_not_supported_versionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_not_supported_versionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionSafeLibraryDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeLibraryDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ibad_model_not_supported_versionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionSafeDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodelv_0DispatcherTrait<T> {
    fn ensure_abi(self: T, model: Modelv0);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodelv_0Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0DispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0Dispatcher> {
    fn ensure_abi(self: Imodelv_0Dispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodelv_0LibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0LibraryDispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0LibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0LibraryDispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodelv_0SafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Modelv0) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodelv_0SafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0SafeLibraryDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeLibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeLibraryDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodelv_0SafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0SafeDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_bad_namespace_formatDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_bad_namespace_formatDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_bad_namespace_formatLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatLibraryDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatLibraryDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_bad_namespace_formatSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeLibraryDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_bad_namespace_formatSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatSafeDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_short_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_short_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_short_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceLibraryDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceLibraryDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_short_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_short_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeLibraryDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_short_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceSafeDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceLibraryDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceLibraryDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeLibraryDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceSafeDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait IpositionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Position);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IpositionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionDispatcherImpl of IpositionDispatcherTrait<IpositionDispatcher> {
    fn ensure_abi(self: IpositionDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IpositionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionLibraryDispatcherImpl of IpositionDispatcherTrait<IpositionLibraryDispatcher> {
    fn ensure_abi(self: IpositionLibraryDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IpositionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Position) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IpositionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionSafeLibraryDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeLibraryDispatcher> {
    fn ensure_abi(self: IpositionSafeLibraryDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IpositionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionSafeDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeDispatcher> {
    fn ensure_abi(self: IpositionSafeDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait IrolesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Roles);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IrolesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesDispatcherImpl of IrolesDispatcherTrait<IrolesDispatcher> {
    fn ensure_abi(self: IrolesDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IrolesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesLibraryDispatcherImpl of IrolesDispatcherTrait<IrolesLibraryDispatcher> {
    fn ensure_abi(self: IrolesLibraryDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IrolesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Roles) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IrolesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesSafeLibraryDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeLibraryDispatcher> {
    fn ensure_abi(self: IrolesSafeLibraryDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IrolesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesSafeDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeDispatcher> {
    fn ensure_abi(self: IrolesSafeDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Ionly_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: OnlyKeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ionly_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelDispatcher> {
    fn ensure_abi(self: Ionly_key_modelDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ionly_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelLibraryDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelLibraryDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Ionly_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: OnlyKeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ionly_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelSafeLibraryDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeLibraryDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Ionly_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelSafeDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Iu_256_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: U256KeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Iu_256_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Iu_256_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelLibraryDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelLibraryDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Iu_256_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: U256KeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Iu_256_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelSafeLibraryDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeLibraryDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Iu_256_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelSafeDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait IplayerDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Player);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IplayerDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerDispatcherImpl of IplayerDispatcherTrait<IplayerDispatcher> {
    fn ensure_abi(self: IplayerDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IplayerLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerLibraryDispatcherImpl of IplayerDispatcherTrait<IplayerLibraryDispatcher> {
    fn ensure_abi(self: IplayerLibraryDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IplayerSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Player) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IplayerSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerSafeLibraryDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeLibraryDispatcher> {
    fn ensure_abi(self: IplayerSafeLibraryDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IplayerSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerSafeDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeDispatcher> {
    fn ensure_abi(self: IplayerSafeDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_simple_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithSimpleArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_simple_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arrayDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_simple_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arrayLibraryDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayLibraryDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_simple_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithSimpleArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_simple_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arraySafeLibraryDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeLibraryDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_simple_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arraySafeDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_byte_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithByteArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_byte_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arrayDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_byte_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arrayLibraryDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayLibraryDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_byte_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithByteArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_byte_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arraySafeLibraryDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeLibraryDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_byte_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arraySafeDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_complex_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithComplexArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_complex_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arrayDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_complex_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arrayLibraryDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayLibraryDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_complex_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithComplexArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_complex_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arraySafeLibraryDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeLibraryDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_complex_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arraySafeDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_tupleDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTuple);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tupleDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tupleLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleLibraryDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleLibraryDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_tupleSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTuple) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tupleSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleSafeLibraryDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeLibraryDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tupleSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleSafeDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
trait Imodel_with_tuple_no_primitivesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tuple_no_primitivesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tuple_no_primitivesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesLibraryDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait Imodel_with_tuple_no_primitivesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct Imodel_with_tuple_no_primitivesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesSafeDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl Ibad_model_multiple_versionsDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsDispatcher of starknet::Store::<Ibad_model_multiple_versionsDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_multiple_versionsDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_multiple_versionsDispatcher> {}
impl Ibad_model_multiple_versionsLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_multiple_versionsLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_multiple_versionsLibraryDispatcher> {}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_multiple_versionsSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {}
impl Ibad_model_multiple_versionsSafeDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_multiple_versionsSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_multiple_versionsSafeDispatcher> {}
impl Ibad_model_bad_version_typeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeDispatcher of starknet::Store::<Ibad_model_bad_version_typeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_bad_version_typeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_bad_version_typeDispatcher> {}
impl Ibad_model_bad_version_typeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_bad_version_typeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_bad_version_typeLibraryDispatcher> {}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_bad_version_typeSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {}
impl Ibad_model_bad_version_typeSafeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_bad_version_typeSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_bad_version_typeSafeDispatcher> {}
impl Ibad_model_no_version_valueDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueDispatcher of starknet::Store::<Ibad_model_no_version_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_no_version_valueDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_no_version_valueDispatcher> {}
impl Ibad_model_no_version_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_no_version_valueLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_no_version_valueLibraryDispatcher> {}
impl Ibad_model_no_version_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_no_version_valueSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_no_version_valueSafeLibraryDispatcher> {}
impl Ibad_model_no_version_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_no_version_valueSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_no_version_valueSafeDispatcher> {}
impl Ibad_model_unexpected_arg_with_valueDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_arg_with_valueDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_arg_with_valueDispatcher> {}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_arg_with_valueLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_arg_with_valueSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_arg_with_valueSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {}
impl Ibad_model_unexpected_argDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argDispatcher of starknet::Store::<Ibad_model_unexpected_argDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_argDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_argDispatcher> {}
impl Ibad_model_unexpected_argLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_argLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_argLibraryDispatcher> {}
impl Ibad_model_unexpected_argSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_argSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_argSafeLibraryDispatcher> {}
impl Ibad_model_unexpected_argSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_unexpected_argSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_unexpected_argSafeDispatcher> {}
impl Ibad_model_not_supported_versionDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionDispatcher of starknet::Store::<Ibad_model_not_supported_versionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_not_supported_versionDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_not_supported_versionDispatcher> {}
impl Ibad_model_not_supported_versionLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_not_supported_versionLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_not_supported_versionLibraryDispatcher> {}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_not_supported_versionSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {}
impl Ibad_model_not_supported_versionSafeDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIbad_model_not_supported_versionSafeDispatcher of starknet::storage_access::DeriveStorage::<Ibad_model_not_supported_versionSafeDispatcher> {}
impl Imodelv_0DispatcherCopy of core::traits::Copy::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherDrop of core::traits::Drop::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherSerde of core::serde::Serde::<Imodelv_0Dispatcher> {
    fn serialize(self: @Imodelv_0Dispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0Dispatcher> {
        core::option::Option::Some(Imodelv_0Dispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0Dispatcher of starknet::Store::<Imodelv_0Dispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodelv_0Dispatcher of starknet::storage_access::DeriveStorage::<Imodelv_0Dispatcher> {}
impl Imodelv_0LibraryDispatcherCopy of core::traits::Copy::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherDrop of core::traits::Drop::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherSerde of core::serde::Serde::<Imodelv_0LibraryDispatcher> {
    fn serialize(self: @Imodelv_0LibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0LibraryDispatcher> {
        core::option::Option::Some(Imodelv_0LibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0LibraryDispatcher of starknet::Store::<Imodelv_0LibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodelv_0LibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodelv_0LibraryDispatcher> {}
impl Imodelv_0SafeLibraryDispatcherCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherSerde of core::serde::Serde::<Imodelv_0SafeLibraryDispatcher> {
    fn serialize(self: @Imodelv_0SafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeLibraryDispatcher> {
        core::option::Option::Some(Imodelv_0SafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeLibraryDispatcher of starknet::Store::<Imodelv_0SafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodelv_0SafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodelv_0SafeLibraryDispatcher> {}
impl Imodelv_0SafeDispatcherCopy of core::traits::Copy::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherDrop of core::traits::Drop::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherSerde of core::serde::Serde::<Imodelv_0SafeDispatcher> {
    fn serialize(self: @Imodelv_0SafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeDispatcher> {
        core::option::Option::Some(Imodelv_0SafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeDispatcher of starknet::Store::<Imodelv_0SafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodelv_0SafeDispatcher of starknet::storage_access::DeriveStorage::<Imodelv_0SafeDispatcher> {}
impl Imodel_with_bad_namespace_formatDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_bad_namespace_formatDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_bad_namespace_formatDispatcher> {}
impl Imodel_with_bad_namespace_formatLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_bad_namespace_formatLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_bad_namespace_formatLibraryDispatcher> {}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_bad_namespace_formatSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {}
impl Imodel_with_bad_namespace_formatSafeDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_bad_namespace_formatSafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_bad_namespace_formatSafeDispatcher> {}
impl Imodel_with_short_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceDispatcher of starknet::Store::<Imodel_with_short_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_short_string_namespaceDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_short_string_namespaceDispatcher> {}
impl Imodel_with_short_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_short_string_namespaceLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_short_string_namespaceLibraryDispatcher> {}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_short_string_namespaceSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {}
impl Imodel_with_short_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_short_string_namespaceSafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_short_string_namespaceSafeDispatcher> {}
impl Imodel_with_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceDispatcher of starknet::Store::<Imodel_with_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_string_namespaceDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_string_namespaceDispatcher> {}
impl Imodel_with_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_string_namespaceLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_string_namespaceLibraryDispatcher> {}
impl Imodel_with_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_string_namespaceSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_string_namespaceSafeLibraryDispatcher> {}
impl Imodel_with_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_string_namespaceSafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_string_namespaceSafeDispatcher> {}
impl IpositionDispatcherCopy of core::traits::Copy::<IpositionDispatcher>;
impl IpositionDispatcherDrop of core::traits::Drop::<IpositionDispatcher>;
impl IpositionDispatcherSerde of core::serde::Serde::<IpositionDispatcher> {
    fn serialize(self: @IpositionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionDispatcher> {
        core::option::Option::Some(IpositionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionDispatcher of starknet::Store::<IpositionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIpositionDispatcher of starknet::storage_access::DeriveStorage::<IpositionDispatcher> {}
impl IpositionLibraryDispatcherCopy of core::traits::Copy::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherDrop of core::traits::Drop::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherSerde of core::serde::Serde::<IpositionLibraryDispatcher> {
    fn serialize(self: @IpositionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionLibraryDispatcher> {
        core::option::Option::Some(IpositionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionLibraryDispatcher of starknet::Store::<IpositionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIpositionLibraryDispatcher of starknet::storage_access::DeriveStorage::<IpositionLibraryDispatcher> {}
impl IpositionSafeLibraryDispatcherCopy of core::traits::Copy::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherDrop of core::traits::Drop::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherSerde of core::serde::Serde::<IpositionSafeLibraryDispatcher> {
    fn serialize(self: @IpositionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeLibraryDispatcher> {
        core::option::Option::Some(IpositionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeLibraryDispatcher of starknet::Store::<IpositionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIpositionSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IpositionSafeLibraryDispatcher> {}
impl IpositionSafeDispatcherCopy of core::traits::Copy::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherDrop of core::traits::Drop::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherSerde of core::serde::Serde::<IpositionSafeDispatcher> {
    fn serialize(self: @IpositionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeDispatcher> {
        core::option::Option::Some(IpositionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeDispatcher of starknet::Store::<IpositionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIpositionSafeDispatcher of starknet::storage_access::DeriveStorage::<IpositionSafeDispatcher> {}
impl IrolesDispatcherCopy of core::traits::Copy::<IrolesDispatcher>;
impl IrolesDispatcherDrop of core::traits::Drop::<IrolesDispatcher>;
impl IrolesDispatcherSerde of core::serde::Serde::<IrolesDispatcher> {
    fn serialize(self: @IrolesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesDispatcher> {
        core::option::Option::Some(IrolesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesDispatcher of starknet::Store::<IrolesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIrolesDispatcher of starknet::storage_access::DeriveStorage::<IrolesDispatcher> {}
impl IrolesLibraryDispatcherCopy of core::traits::Copy::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherDrop of core::traits::Drop::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherSerde of core::serde::Serde::<IrolesLibraryDispatcher> {
    fn serialize(self: @IrolesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesLibraryDispatcher> {
        core::option::Option::Some(IrolesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesLibraryDispatcher of starknet::Store::<IrolesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIrolesLibraryDispatcher of starknet::storage_access::DeriveStorage::<IrolesLibraryDispatcher> {}
impl IrolesSafeLibraryDispatcherCopy of core::traits::Copy::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherDrop of core::traits::Drop::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherSerde of core::serde::Serde::<IrolesSafeLibraryDispatcher> {
    fn serialize(self: @IrolesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeLibraryDispatcher> {
        core::option::Option::Some(IrolesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeLibraryDispatcher of starknet::Store::<IrolesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIrolesSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IrolesSafeLibraryDispatcher> {}
impl IrolesSafeDispatcherCopy of core::traits::Copy::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherDrop of core::traits::Drop::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherSerde of core::serde::Serde::<IrolesSafeDispatcher> {
    fn serialize(self: @IrolesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeDispatcher> {
        core::option::Option::Some(IrolesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeDispatcher of starknet::Store::<IrolesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIrolesSafeDispatcher of starknet::storage_access::DeriveStorage::<IrolesSafeDispatcher> {}
impl Ionly_key_modelDispatcherCopy of core::traits::Copy::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherDrop of core::traits::Drop::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherSerde of core::serde::Serde::<Ionly_key_modelDispatcher> {
    fn serialize(self: @Ionly_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelDispatcher> {
        core::option::Option::Some(Ionly_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelDispatcher of starknet::Store::<Ionly_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIonly_key_modelDispatcher of starknet::storage_access::DeriveStorage::<Ionly_key_modelDispatcher> {}
impl Ionly_key_modelLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelLibraryDispatcher of starknet::Store::<Ionly_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIonly_key_modelLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ionly_key_modelLibraryDispatcher> {}
impl Ionly_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeLibraryDispatcher of starknet::Store::<Ionly_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIonly_key_modelSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Ionly_key_modelSafeLibraryDispatcher> {}
impl Ionly_key_modelSafeDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeDispatcher of starknet::Store::<Ionly_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIonly_key_modelSafeDispatcher of starknet::storage_access::DeriveStorage::<Ionly_key_modelSafeDispatcher> {}
impl Iu_256_key_modelDispatcherCopy of core::traits::Copy::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherDrop of core::traits::Drop::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherSerde of core::serde::Serde::<Iu_256_key_modelDispatcher> {
    fn serialize(self: @Iu_256_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelDispatcher> {
        core::option::Option::Some(Iu_256_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelDispatcher of starknet::Store::<Iu_256_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIu_256_key_modelDispatcher of starknet::storage_access::DeriveStorage::<Iu_256_key_modelDispatcher> {}
impl Iu_256_key_modelLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelLibraryDispatcher of starknet::Store::<Iu_256_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIu_256_key_modelLibraryDispatcher of starknet::storage_access::DeriveStorage::<Iu_256_key_modelLibraryDispatcher> {}
impl Iu_256_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeLibraryDispatcher of starknet::Store::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIu_256_key_modelSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Iu_256_key_modelSafeLibraryDispatcher> {}
impl Iu_256_key_modelSafeDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeDispatcher of starknet::Store::<Iu_256_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIu_256_key_modelSafeDispatcher of starknet::storage_access::DeriveStorage::<Iu_256_key_modelSafeDispatcher> {}
impl IplayerDispatcherCopy of core::traits::Copy::<IplayerDispatcher>;
impl IplayerDispatcherDrop of core::traits::Drop::<IplayerDispatcher>;
impl IplayerDispatcherSerde of core::serde::Serde::<IplayerDispatcher> {
    fn serialize(self: @IplayerDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerDispatcher> {
        core::option::Option::Some(IplayerDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerDispatcher of starknet::Store::<IplayerDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIplayerDispatcher of starknet::storage_access::DeriveStorage::<IplayerDispatcher> {}
impl IplayerLibraryDispatcherCopy of core::traits::Copy::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherDrop of core::traits::Drop::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherSerde of core::serde::Serde::<IplayerLibraryDispatcher> {
    fn serialize(self: @IplayerLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerLibraryDispatcher> {
        core::option::Option::Some(IplayerLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerLibraryDispatcher of starknet::Store::<IplayerLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIplayerLibraryDispatcher of starknet::storage_access::DeriveStorage::<IplayerLibraryDispatcher> {}
impl IplayerSafeLibraryDispatcherCopy of core::traits::Copy::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherDrop of core::traits::Drop::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherSerde of core::serde::Serde::<IplayerSafeLibraryDispatcher> {
    fn serialize(self: @IplayerSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeLibraryDispatcher> {
        core::option::Option::Some(IplayerSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeLibraryDispatcher of starknet::Store::<IplayerSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIplayerSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IplayerSafeLibraryDispatcher> {}
impl IplayerSafeDispatcherCopy of core::traits::Copy::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherDrop of core::traits::Drop::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherSerde of core::serde::Serde::<IplayerSafeDispatcher> {
    fn serialize(self: @IplayerSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeDispatcher> {
        core::option::Option::Some(IplayerSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeDispatcher of starknet::Store::<IplayerSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIplayerSafeDispatcher of starknet::storage_access::DeriveStorage::<IplayerSafeDispatcher> {}
impl Imodel_with_simple_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayDispatcher of starknet::Store::<Imodel_with_simple_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_simple_arrayDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_simple_arrayDispatcher> {}
impl Imodel_with_simple_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayLibraryDispatcher of starknet::Store::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_simple_arrayLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_simple_arrayLibraryDispatcher> {}
impl Imodel_with_simple_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_simple_arraySafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_simple_arraySafeLibraryDispatcher> {}
impl Imodel_with_simple_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeDispatcher of starknet::Store::<Imodel_with_simple_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_simple_arraySafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_simple_arraySafeDispatcher> {}
impl Imodel_with_byte_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayDispatcher of starknet::Store::<Imodel_with_byte_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_byte_arrayDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_byte_arrayDispatcher> {}
impl Imodel_with_byte_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayLibraryDispatcher of starknet::Store::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_byte_arrayLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_byte_arrayLibraryDispatcher> {}
impl Imodel_with_byte_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_byte_arraySafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_byte_arraySafeLibraryDispatcher> {}
impl Imodel_with_byte_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeDispatcher of starknet::Store::<Imodel_with_byte_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_byte_arraySafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_byte_arraySafeDispatcher> {}
impl Imodel_with_complex_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayDispatcher of starknet::Store::<Imodel_with_complex_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_complex_arrayDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_complex_arrayDispatcher> {}
impl Imodel_with_complex_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayLibraryDispatcher of starknet::Store::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_complex_arrayLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_complex_arrayLibraryDispatcher> {}
impl Imodel_with_complex_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_complex_arraySafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_complex_arraySafeLibraryDispatcher> {}
impl Imodel_with_complex_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeDispatcher of starknet::Store::<Imodel_with_complex_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_complex_arraySafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_complex_arraySafeDispatcher> {}
impl Imodel_with_tupleDispatcherCopy of core::traits::Copy::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherDrop of core::traits::Drop::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherSerde of core::serde::Serde::<Imodel_with_tupleDispatcher> {
    fn serialize(self: @Imodel_with_tupleDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleDispatcher> {
        core::option::Option::Some(Imodel_with_tupleDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleDispatcher of starknet::Store::<Imodel_with_tupleDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tupleDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tupleDispatcher> {}
impl Imodel_with_tupleLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleLibraryDispatcher of starknet::Store::<Imodel_with_tupleLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tupleLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tupleLibraryDispatcher> {}
impl Imodel_with_tupleSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeLibraryDispatcher of starknet::Store::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tupleSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tupleSafeLibraryDispatcher> {}
impl Imodel_with_tupleSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeDispatcher of starknet::Store::<Imodel_with_tupleSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tupleSafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tupleSafeDispatcher> {}
impl Imodel_with_tuple_no_primitivesDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tuple_no_primitivesDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tuple_no_primitivesDispatcher> {}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tuple_no_primitivesLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tuple_no_primitivesSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {}
impl Imodel_with_tuple_no_primitivesSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageImodel_with_tuple_no_primitivesSafeDispatcher of starknet::storage_access::DeriveStorage::<Imodel_with_tuple_no_primitivesSafeDispatcher> {}

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> /var/folders/3j/41jlhmds1yvc3z3m5_sgch6w0000gn/T/.tmpqaC28y/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^
