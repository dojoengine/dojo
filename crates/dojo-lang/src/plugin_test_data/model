//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > test_id
model

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}
impl BadModelMultipleAttrIntrospect<> of dojo::model::introspect::Introspect<BadModelMultipleAttr<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelMultipleAttr',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl BadModelMultipleVersionsIntrospect<> of dojo::model::introspect::Introspect<BadModelMultipleVersions<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelMultipleVersions',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelMultipleVersionsEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelMultipleVersionsEntityStoreImpl of BadModelMultipleVersionsEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity {
        BadModelMultipleVersionsModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelMultipleVersionsEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelMultipleVersionsEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelMultipleVersionsEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelMultipleVersions::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelMultipleVersionsStoreImpl of BadModelMultipleVersionsStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelMultipleVersions {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelMultipleVersions>::get(world, serialized.span())
    }

    fn set(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelMultipleVersions>::set_model(self, world);
    }

    fn delete(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelMultipleVersions>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelMultipleVersions>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelMultipleVersions::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelMultipleVersionsModelEntityImpl of dojo::model::ModelEntity<BadModelMultipleVersionsEntity> {
    fn id(self: @BadModelMultipleVersionsEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelMultipleVersionsEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelMultipleVersionsEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelMultipleVersionsEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelMultipleVersionsEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelMultipleVersionsEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelMultipleVersionsEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
    }

    fn delete_entity(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelMultipleVersions>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelMultipleVersions>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelMultipleVersionsEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelMultipleVersions>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelMultipleVersions>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelMultipleVersionsModelImpl of dojo::model::Model<BadModelMultipleVersions> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelMultipleVersions {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelMultipleVersionsStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3538888628466873673221842373412072042558277047191927145880480325050722136660
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelMultipleVersions) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
pub mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelMultipleVersions"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelMultipleVersions"
        }

        fn version(self: @ContractState) -> u8 {
           0
        }

        fn selector(self: @ContractState) -> felt252 {
           "BadModelMultipleVersions"
        }

        fn name_hash(self: @ContractState) -> felt252 {
            3538888628466873673221842373412072042558277047191927145880480325050722136660
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_multiple_versionsImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_multiple_versionsImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_multiple_versionsImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl BadModelBadVersionTypeIntrospect<> of dojo::model::introspect::Introspect<BadModelBadVersionType<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelBadVersionType',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelBadVersionTypeEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelBadVersionTypeEntityStoreImpl of BadModelBadVersionTypeEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity {
        BadModelBadVersionTypeModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelBadVersionTypeEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelBadVersionTypeEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelBadVersionTypeEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelBadVersionType::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelBadVersionTypeStoreImpl of BadModelBadVersionTypeStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelBadVersionType {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelBadVersionType>::get(world, serialized.span())
    }

    fn set(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelBadVersionType>::set_model(self, world);
    }

    fn delete(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelBadVersionType>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelBadVersionType>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelBadVersionType::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelBadVersionTypeModelEntityImpl of dojo::model::ModelEntity<BadModelBadVersionTypeEntity> {
    fn id(self: @BadModelBadVersionTypeEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelBadVersionTypeEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelBadVersionTypeEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelBadVersionTypeEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelBadVersionTypeEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelBadVersionTypeEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelBadVersionTypeEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
    }

    fn delete_entity(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelBadVersionType>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelBadVersionType>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelBadVersionTypeEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelBadVersionType>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelBadVersionType>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelBadVersionTypeModelImpl of dojo::model::Model<BadModelBadVersionType> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelBadVersionType {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelBadVersionTypeStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1905541678078795270787966976324692071183638743428320623241420232497892529006
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        760683829940564015458541272487101565210915690045377810379189532484191344547
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelBadVersionType) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
pub mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelBadVersionType"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelBadVersionType"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           1905541678078795270787966976324692071183638743428320623241420232497892529006
        }

        fn name_hash(self: @ContractState) -> felt252 {
            760683829940564015458541272487101565210915690045377810379189532484191344547
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_bad_version_typeImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelBadVersionType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_bad_version_typeImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_bad_version_typeImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl BadModelNoVersionValueIntrospect<> of dojo::model::introspect::Introspect<BadModelNoVersionValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelNoVersionValue',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNoVersionValueEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelNoVersionValueEntityStoreImpl of BadModelNoVersionValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity {
        BadModelNoVersionValueModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelNoVersionValueEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelNoVersionValueEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelNoVersionValueEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNoVersionValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelNoVersionValueStoreImpl of BadModelNoVersionValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNoVersionValue {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNoVersionValue>::get(world, serialized.span())
    }

    fn set(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNoVersionValue>::set_model(self, world);
    }

    fn delete(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNoVersionValue>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelNoVersionValue>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNoVersionValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelNoVersionValueModelEntityImpl of dojo::model::ModelEntity<BadModelNoVersionValueEntity> {
    fn id(self: @BadModelNoVersionValueEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelNoVersionValueEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelNoVersionValueEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelNoVersionValueEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelNoVersionValueEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelNoVersionValueEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelNoVersionValueEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
    }

    fn delete_entity(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNoVersionValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelNoVersionValue>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNoVersionValueEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNoVersionValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelNoVersionValue>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelNoVersionValueModelImpl of dojo::model::Model<BadModelNoVersionValue> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelNoVersionValue {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelNoVersionValueStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2174173236757861924887576251338889271361403293870377278593064770381730742730
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2459365230136118590954025890011480023818926626380754992635699340900694864996
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelNoVersionValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
pub mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelNoVersionValue"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelNoVersionValue"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2174173236757861924887576251338889271361403293870377278593064770381730742730
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2459365230136118590954025890011480023818926626380754992635699340900694864996
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_no_version_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_no_version_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_no_version_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl BadModelUnexpectedArgWithValueIntrospect<> of dojo::model::introspect::Introspect<BadModelUnexpectedArgWithValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelUnexpectedArgWithValue',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgWithValueEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelUnexpectedArgWithValueEntityStoreImpl of BadModelUnexpectedArgWithValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity {
        BadModelUnexpectedArgWithValueModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelUnexpectedArgWithValueEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelUnexpectedArgWithValueEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelUnexpectedArgWithValueEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArgWithValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelUnexpectedArgWithValueStoreImpl of BadModelUnexpectedArgWithValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValue {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArgWithValue>::get(world, serialized.span())
    }

    fn set(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArgWithValue>::set_model(self, world);
    }

    fn delete(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArgWithValue>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelUnexpectedArgWithValue>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArgWithValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelUnexpectedArgWithValueModelEntityImpl of dojo::model::ModelEntity<BadModelUnexpectedArgWithValueEntity> {
    fn id(self: @BadModelUnexpectedArgWithValueEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelUnexpectedArgWithValueEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValueEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelUnexpectedArgWithValueEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelUnexpectedArgWithValueEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelUnexpectedArgWithValueEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelUnexpectedArgWithValueEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
    }

    fn delete_entity(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgWithValueEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelUnexpectedArgWithValueModelImpl of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelUnexpectedArgWithValue {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelUnexpectedArgWithValueStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1774601905279008934284028706234273692471613779453192873246657851412081197776
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3586339245084542986020591057627093254376225984628310828088084183494435682971
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
pub mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelUnexpectedArgWithValue"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelUnexpectedArgWithValue"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           1774601905279008934284028706234273692471613779453192873246657851412081197776
        }

        fn name_hash(self: @ContractState) -> felt252 {
            3586339245084542986020591057627093254376225984628310828088084183494435682971
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_arg_with_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl BadModelUnexpectedArgIntrospect<> of dojo::model::introspect::Introspect<BadModelUnexpectedArg<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelUnexpectedArg',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelUnexpectedArgEntityStoreImpl of BadModelUnexpectedArgEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity {
        BadModelUnexpectedArgModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelUnexpectedArgEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelUnexpectedArgEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelUnexpectedArgEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArg::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelUnexpectedArgStoreImpl of BadModelUnexpectedArgStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArg {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArg>::get(world, serialized.span())
    }

    fn set(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArg>::set_model(self, world);
    }

    fn delete(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelUnexpectedArg>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelUnexpectedArg>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArg::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelUnexpectedArgModelEntityImpl of dojo::model::ModelEntity<BadModelUnexpectedArgEntity> {
    fn id(self: @BadModelUnexpectedArgEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelUnexpectedArgEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelUnexpectedArgEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelUnexpectedArgEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelUnexpectedArgEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelUnexpectedArgEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelUnexpectedArgEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
    }

    fn delete_entity(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArg>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArg>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArg>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArg>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelUnexpectedArgModelImpl of dojo::model::Model<BadModelUnexpectedArg> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelUnexpectedArg {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelUnexpectedArgStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        285468224541147509570785281966044474829506125602814945625270991330973673529
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        246403407829267991441535935236143476032296881039254363860883767387993960270
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArg) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
pub mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelUnexpectedArg"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelUnexpectedArg"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           285468224541147509570785281966044474829506125602814945625270991330973673529
        }

        fn name_hash(self: @ContractState) -> felt252 {
            246403407829267991441535935236143476032296881039254363860883767387993960270
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_argImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_argImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_argImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl BadModelNotSupportedVersionIntrospect<> of dojo::model::introspect::Introspect<BadModelNotSupportedVersion<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelNotSupportedVersion',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNotSupportedVersionEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelNotSupportedVersionEntityStoreImpl of BadModelNotSupportedVersionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity {
        BadModelNotSupportedVersionModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelNotSupportedVersionEntity>::update_entity(self, world);
    }

    fn delete(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<BadModelNotSupportedVersionEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelNotSupportedVersionEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNotSupportedVersion::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelNotSupportedVersionStoreImpl of BadModelNotSupportedVersionStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNotSupportedVersion {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNotSupportedVersion>::get(world, serialized.span())
    }

    fn set(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNotSupportedVersion>::set_model(self, world);
    }

    fn delete(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<BadModelNotSupportedVersion>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelNotSupportedVersion>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNotSupportedVersion::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelNotSupportedVersionModelEntityImpl of dojo::model::ModelEntity<BadModelNotSupportedVersionEntity> {
    fn id(self: @BadModelNotSupportedVersionEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelNotSupportedVersionEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelNotSupportedVersionEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelNotSupportedVersionEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelNotSupportedVersionEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelNotSupportedVersionEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelNotSupportedVersionEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
    }

    fn delete_entity(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNotSupportedVersion>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNotSupportedVersionEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNotSupportedVersion>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelNotSupportedVersionModelImpl of dojo::model::Model<BadModelNotSupportedVersion> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelNotSupportedVersion {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelNotSupportedVersionStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3364830312705791335907422218790599751780160858399843169712719310945970157661
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1812257929012908024237871796629728977392496349235879470060252299886369485820
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @BadModelNotSupportedVersion) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
pub mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "BadModelNotSupportedVersion"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-BadModelNotSupportedVersion"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           3364830312705791335907422218790599751780160858399843169712719310945970157661
        }

        fn name_hash(self: @ContractState) -> felt252 {
            1812257929012908024237871796629728977392496349235879470060252299886369485820
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_not_supported_versionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_not_supported_versionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_not_supported_versionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl Modelv0Introspect<> of dojo::model::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct Modelv0Entity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl Modelv0EntityStoreImpl of Modelv0EntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity {
        Modelv0ModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<Modelv0Entity>::update_entity(self, world);
    }

    fn delete(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<Modelv0Entity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<Modelv0Entity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Modelv0::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl Modelv0StoreImpl of Modelv0Store {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Modelv0 {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Modelv0>::get(world, serialized.span())
    }

    fn set(self: @Modelv0, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Modelv0>::set_model(self, world);
    }

    fn delete(self: @Modelv0, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Modelv0>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<Modelv0>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Modelv0::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Modelv0, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl Modelv0ModelEntityImpl of dojo::model::ModelEntity<Modelv0Entity> {
    fn id(self: @Modelv0Entity) -> felt252 {
        *self.__id
    }

    fn values(self: @Modelv0Entity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> Modelv0Entity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<Modelv0Entity>::deserialize(ref serialized);
        if core::option::OptionTrait::<Modelv0Entity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `Modelv0Entity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<Modelv0Entity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Modelv0>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Modelv0>::layout()
        );
    }

    fn delete_entity(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Modelv0>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Modelv0>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Modelv0>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Modelv0Entity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Modelv0>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Modelv0>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl Modelv0ModelImpl of dojo::model::Model<Modelv0> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Modelv0 {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        Modelv0Store::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2212879130471315306779111820244908968466545702031328551192231795237740448313
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @Modelv0) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
pub mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "Modelv0"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-Modelv0"
        }

        fn version(self: @ContractState) -> u8 {
           0
        }

        fn selector(self: @ContractState) -> felt252 {
           "Modelv0"
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2212879130471315306779111820244908968466545702031328551192231795237740448313
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__modelv_0Impl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Modelv0>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    modelv_0Impl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__modelv_0Impl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::model::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithBadNamespaceFormatEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithBadNamespaceFormatEntityStoreImpl of ModelWithBadNamespaceFormatEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity {
        ModelWithBadNamespaceFormatModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithBadNamespaceFormatEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithBadNamespaceFormatEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithBadNamespaceFormatEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithBadNamespaceFormat::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithBadNamespaceFormatStoreImpl of ModelWithBadNamespaceFormatStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithBadNamespaceFormat {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithBadNamespaceFormat>::is_none(@entity) {
            panic!(
                "Model `ModelWithBadNamespaceFormat`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithBadNamespaceFormat>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithBadNamespaceFormat>::get(world, serialized.span())
    }

    fn set(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithBadNamespaceFormat>::set_model(self, world);
    }

    fn delete(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithBadNamespaceFormat>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithBadNamespaceFormat>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithBadNamespaceFormat::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithBadNamespaceFormatModelEntityImpl of dojo::model::ModelEntity<ModelWithBadNamespaceFormatEntity> {
    fn id(self: @ModelWithBadNamespaceFormatEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithBadNamespaceFormatEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithBadNamespaceFormatEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithBadNamespaceFormatEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithBadNamespaceFormatEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithBadNamespaceFormatEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithBadNamespaceFormatEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
    }

    fn delete_entity(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithBadNamespaceFormat>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithBadNamespaceFormatEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithBadNamespaceFormat>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithBadNamespaceFormatModelImpl of dojo::model::Model<ModelWithBadNamespaceFormat> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithBadNamespaceFormat {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithBadNamespaceFormatStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3339335350336894195883884955409923858499485801033572582237787132047489035817
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithBadNamespaceFormat) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        513559242384681567568052881519197161166285694153303371154270254637843894159
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithBadNamespaceFormat) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithBadNamespaceFormat) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_bad_namespace_format<T> {
    fn ensure_abi(self: @T, model: ModelWithBadNamespaceFormat);
}

#[starknet::contract]
pub mod model_with_bad_namespace_format {
    use super::ModelWithBadNamespaceFormat;
    use super::Imodel_with_bad_namespace_format;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithBadNamespaceFormat"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithBadNamespaceFormat"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           3339335350336894195883884955409923858499485801033572582237787132047489035817
        }

        fn name_hash(self: @ContractState) -> felt252 {
            513559242384681567568052881519197161166285694153303371154270254637843894159
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_bad_namespace_formatImpl of Imodel_with_bad_namespace_format<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithBadNamespaceFormat) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_bad_namespace_formatImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_bad_namespace_formatImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_bad_namespace_formatImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::model::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithShortStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithShortStringNamespaceEntityStoreImpl of ModelWithShortStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity {
        ModelWithShortStringNamespaceModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithShortStringNamespaceEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithShortStringNamespaceEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithShortStringNamespaceEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithShortStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithShortStringNamespaceStoreImpl of ModelWithShortStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithShortStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithShortStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespace>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithShortStringNamespace>::get(world, serialized.span())
    }

    fn set(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithShortStringNamespace>::set_model(self, world);
    }

    fn delete(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithShortStringNamespace>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithShortStringNamespace>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithShortStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithShortStringNamespaceModelEntityImpl of dojo::model::ModelEntity<ModelWithShortStringNamespaceEntity> {
    fn id(self: @ModelWithShortStringNamespaceEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithShortStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithShortStringNamespaceEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithShortStringNamespaceEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithShortStringNamespaceEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithShortStringNamespaceEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithShortStringNamespaceEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
    }

    fn delete_entity(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithShortStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithShortStringNamespaceEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithShortStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithShortStringNamespaceModelImpl of dojo::model::Model<ModelWithShortStringNamespace> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithShortStringNamespace {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithShortStringNamespaceStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3563011140946869267852628778244415212055246902495528859686589254859279333005
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithShortStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        4646597166239297873853881466258165424425132957303541470648153031188639878
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithShortStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithShortStringNamespace) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_short_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
pub mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::Imodel_with_short_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithShortStringNamespace"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithShortStringNamespace"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           3563011140946869267852628778244415212055246902495528859686589254859279333005
        }

        fn name_hash(self: @ContractState) -> felt252 {
            4646597166239297873853881466258165424425132957303541470648153031188639878
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithShortStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_short_string_namespaceImpl of Imodel_with_short_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_short_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_short_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_short_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithStringNamespaceIntrospect<> of dojo::model::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithStringNamespaceEntityStoreImpl of ModelWithStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity {
        ModelWithStringNamespaceModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithStringNamespaceEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithStringNamespaceEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithStringNamespaceEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithStringNamespaceStoreImpl of ModelWithStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespace>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithStringNamespace>::get(world, serialized.span())
    }

    fn set(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithStringNamespace>::set_model(self, world);
    }

    fn delete(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithStringNamespace>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithStringNamespace>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithStringNamespaceModelEntityImpl of dojo::model::ModelEntity<ModelWithStringNamespaceEntity> {
    fn id(self: @ModelWithStringNamespaceEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithStringNamespaceEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithStringNamespaceEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithStringNamespaceEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithStringNamespaceEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithStringNamespaceEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
    }

    fn delete_entity(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithStringNamespaceEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithStringNamespaceModelImpl of dojo::model::Model<ModelWithStringNamespace> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithStringNamespace {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithStringNamespaceStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3428238780389029245974129676124052799610748885939447299287640410044966811336
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        36187013840655350498900857372670392628596870210415176261336407419317644423
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithStringNamespace) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
pub mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::Imodel_with_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithStringNamespace"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithStringNamespace"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           3428238780389029245974129676124052799610748885939447299287640410044966811336
        }

        fn name_hash(self: @ContractState) -> felt252 {
            36187013840655350498900857372670392628596870210415176261336407419317644423
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_string_namespaceImpl of Imodel_with_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl PositionIntrospect<> of dojo::model::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PositionEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl PositionEntityStoreImpl of PositionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity {
        PositionModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<PositionEntity>::update_entity(self, world);
    }

    fn delete(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<PositionEntity>::delete_entity(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<PositionEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Position::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @PositionEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl PositionStoreImpl of PositionStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Position {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Position>::get(world, serialized.span())
    }

    fn set(self: @Position, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Position>::set_model(self, world);
    }

    fn delete(self: @Position, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Position>::delete_model(self, world);
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<Position>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Position::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Position, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl PositionModelEntityImpl of dojo::model::ModelEntity<PositionEntity> {
    fn id(self: @PositionEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @PositionEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> PositionEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<PositionEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<PositionEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `PositionEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<PositionEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Position>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Position>::layout()
        );
    }

    fn delete_entity(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Position>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Position>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Position>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @PositionEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Position>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Position>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl PositionModelImpl of dojo::model::Model<Position> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Position {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        PositionStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @Position,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @Position,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Position,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1782729361185285637005619480739442196364037716000358448825261820703351159758
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2899920299641094436341712346886623904698864491830316325765258522168980161362
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @Position) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
pub mod position {
    use super::Position;
    use super::Iposition;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "Position"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-Position"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           1782729361185285637005619480739442196364037716000358448825261820703351159758
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2899920299641094436341712346886623904698864491830316325765258522168980161362
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__positionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Position>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    positionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__positionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl RolesIntrospect<> of dojo::model::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 387776731289756409274549987067854286905927440612427426920343953432870065647,
                    layout: dojo::model::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'role_ids',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct RolesEntity {
    __id: felt252, // private field
    pub role_ids: Array<u8>,

}

#[generate_trait]
pub impl RolesEntityStoreImpl of RolesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity {
        RolesModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<RolesEntity>::update_entity(self, world);
    }

    fn delete(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<RolesEntity>::delete_entity(self, world);
    }

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8> {
        let mut values = dojo::model::ModelEntity::<RolesEntity>::get_member(
            world,
            entity_id,
            387776731289756409274549987067854286905927440612427426920343953432870065647
        );
        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `Roles::role_ids`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_role_ids(self: @RolesEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            387776731289756409274549987067854286905927440612427426920343953432870065647,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl RolesStoreImpl of RolesStore {
    fn entity_id_from_keys() -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Roles {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles {
        let mut serialized = core::array::ArrayTrait::new();
        

        dojo::model::Model::<Roles>::get(world, serialized.span())
    }

    fn set(self: @Roles, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Roles>::set_model(self, world);
    }

    fn delete(self: @Roles, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Roles>::delete_model(self, world);
    }

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, ) -> Array<u8> {
        let mut serialized = core::array::ArrayTrait::new();
        

        let mut values = dojo::model::Model::<Roles>::get_member(
            world,
            serialized.span(),
            387776731289756409274549987067854286905927440612427426920343953432870065647
        );

        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `Roles::role_ids`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_role_ids(self: @Roles, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            387776731289756409274549987067854286905927440612427426920343953432870065647,
            serialized.span()
        );
    }
            
}

pub impl RolesModelEntityImpl of dojo::model::ModelEntity<RolesEntity> {
    fn id(self: @RolesEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @RolesEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> RolesEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<RolesEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<RolesEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `RolesEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<RolesEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Roles>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Roles>::layout()
        );
    }

    fn delete_entity(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Roles>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Roles>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Roles>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @RolesEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Roles>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Roles>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl RolesModelImpl of dojo::model::Model<Roles> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Roles {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        RolesStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @Roles,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @Roles,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Roles,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3584099896964965841643389141246184155284218827427504603233100831001054183182
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2030971736961612564423689930729061756599290850089001157163423482274886199516
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @Roles) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
pub mod roles {
    use super::Roles;
    use super::Iroles;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "Roles"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-Roles"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           3584099896964965841643389141246184155284218827427504603233100831001054183182
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2030971736961612564423689930729061756599290850089001157163423482274886199516
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__rolesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Roles>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    rolesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__rolesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl OnlyKeyModelIntrospect<> of dojo::model::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'OnlyKeyModel',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct OnlyKeyModelEntity {
    __id: felt252, // private field
    
}

#[generate_trait]
pub impl OnlyKeyModelEntityStoreImpl of OnlyKeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity {
        OnlyKeyModelModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<OnlyKeyModelEntity>::update_entity(self, world);
    }

    fn delete(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<OnlyKeyModelEntity>::delete_entity(self, world);
    }

    
}

#[generate_trait]
pub impl OnlyKeyModelStoreImpl of OnlyKeyModelStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> OnlyKeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<OnlyKeyModel>::get(world, serialized.span())
    }

    fn set(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<OnlyKeyModel>::set_model(self, world);
    }

    fn delete(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<OnlyKeyModel>::delete_model(self, world);
    }

    
}

pub impl OnlyKeyModelModelEntityImpl of dojo::model::ModelEntity<OnlyKeyModelEntity> {
    fn id(self: @OnlyKeyModelEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @OnlyKeyModelEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> OnlyKeyModelEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<OnlyKeyModelEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<OnlyKeyModelEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `OnlyKeyModelEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<OnlyKeyModelEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
    }

    fn delete_entity(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<OnlyKeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<OnlyKeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @OnlyKeyModelEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<OnlyKeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<OnlyKeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl OnlyKeyModelModelImpl of dojo::model::Model<OnlyKeyModel> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> OnlyKeyModel {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        OnlyKeyModelStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2309092000941816896446401231215693966290521919639503466118437426986900396853
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1001826121797570811408809643478760373535949956555931325019299477987282578617
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @OnlyKeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
pub mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "OnlyKeyModel"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-OnlyKeyModel"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2309092000941816896446401231215693966290521919639503466118437426986900396853
        }

        fn name_hash(self: @ContractState) -> felt252 {
            1001826121797570811408809643478760373535949956555931325019299477987282578617
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__only_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<OnlyKeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    only_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__only_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl U256KeyModelIntrospect<> of dojo::model::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'U256KeyModel',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<u256>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct U256KeyModelEntity {
    __id: felt252, // private field
    
}

#[generate_trait]
pub impl U256KeyModelEntityStoreImpl of U256KeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity {
        U256KeyModelModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<U256KeyModelEntity>::update_entity(self, world);
    }

    fn delete(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<U256KeyModelEntity>::delete_entity(self, world);
    }

    
}

#[generate_trait]
pub impl U256KeyModelStoreImpl of U256KeyModelStore {
    fn entity_id_from_keys(id: u256) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> U256KeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);


        dojo::model::Model::<U256KeyModel>::get(world, serialized.span())
    }

    fn set(self: @U256KeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<U256KeyModel>::set_model(self, world);
    }

    fn delete(self: @U256KeyModel, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<U256KeyModel>::delete_model(self, world);
    }

    
}

pub impl U256KeyModelModelEntityImpl of dojo::model::ModelEntity<U256KeyModelEntity> {
    fn id(self: @U256KeyModelEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @U256KeyModelEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> U256KeyModelEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<U256KeyModelEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<U256KeyModelEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `U256KeyModelEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<U256KeyModelEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<U256KeyModel>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<U256KeyModel>::layout()
        );
    }

    fn delete_entity(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<U256KeyModel>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<U256KeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<U256KeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @U256KeyModelEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<U256KeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<U256KeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl U256KeyModelModelImpl of dojo::model::Model<U256KeyModel> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> U256KeyModel {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        U256KeyModelStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2221887666320363067192826725795502610968343119143207326025439486865385474790
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1848733002266458148515852001373055968326209639346734967305014900020806934517
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @U256KeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
pub mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "U256KeyModel"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-U256KeyModel"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2221887666320363067192826725795502610968343119143207326025439486865385474790
        }

        fn name_hash(self: @ContractState) -> felt252 {
            1848733002266458148515852001373055968326209639346734967305014900020806934517
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__u_256_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<U256KeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    u_256_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__u_256_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl PlayerIntrospect<> of dojo::model::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::model::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PlayerEntity {
    __id: felt252, // private field
    pub name: felt252,

}

#[generate_trait]
pub impl PlayerEntityStoreImpl of PlayerEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity {
        PlayerModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<PlayerEntity>::update_entity(self, world);
    }

    fn delete(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<PlayerEntity>::delete_entity(self, world);
    }

    
    fn get_name(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252 {
        let mut values = dojo::model::ModelEntity::<PlayerEntity>::get_member(
            world,
            entity_id,
            1528802474226268325865027367859591458315299653151958663884057507666229546336
        );
        let field_value = core::serde::Serde::<felt252>::deserialize(ref values);

        if core::option::OptionTrait::<felt252>::is_none(@field_value) {
            panic!(
                "Field `Player::name`: deserialization failed."
            );
        }

        core::option::OptionTrait::<felt252>::unwrap(field_value)
    }

    fn set_name(self: @PlayerEntity, world: dojo::world::IWorldDispatcher, value: felt252) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1528802474226268325865027367859591458315299653151958663884057507666229546336,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl PlayerStoreImpl of PlayerStore {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Player {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<Player>::get(world, serialized.span())
    }

    fn set(self: @Player, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Player>::set_model(self, world);
    }

    fn delete(self: @Player, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<Player>::delete_model(self, world);
    }

    
    fn get_name(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<Player>::get_member(
            world,
            serialized.span(),
            1528802474226268325865027367859591458315299653151958663884057507666229546336
        );

        let field_value = core::serde::Serde::<felt252>::deserialize(ref values);

        if core::option::OptionTrait::<felt252>::is_none(@field_value) {
            panic!(
                "Field `Player::name`: deserialization failed."
            );
        }

        core::option::OptionTrait::<felt252>::unwrap(field_value)
    }

    fn set_name(self: @Player, world: dojo::world::IWorldDispatcher, value: felt252) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1528802474226268325865027367859591458315299653151958663884057507666229546336,
            serialized.span()
        );
    }
            
}

pub impl PlayerModelEntityImpl of dojo::model::ModelEntity<PlayerEntity> {
    fn id(self: @PlayerEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @PlayerEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> PlayerEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<PlayerEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<PlayerEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `PlayerEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<PlayerEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Player>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Player>::layout()
        );
    }

    fn delete_entity(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Player>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Player>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Player>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @PlayerEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Player>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Player>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl PlayerModelImpl of dojo::model::Model<Player> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Player {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        PlayerStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @Player,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @Player,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Player,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        32472305970791489884889070587064570056671760620943135506258424375410423946
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1073075359926275415180704315933677548333097210683379121732618306925003101845
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @Player) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);
core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
pub mod player {
    use super::Player;
    use super::Iplayer;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "Player"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-Player"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           32472305970791489884889070587064570056671760620943135506258424375410423946
        }

        fn name_hash(self: @ContractState) -> felt252 {
            1073075359926275415180704315933677548333097210683379121732618306925003101845
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__playerImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Player>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    playerImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__playerImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithSimpleArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithSimpleArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<u8>,

}

#[generate_trait]
pub impl ModelWithSimpleArrayEntityStoreImpl of ModelWithSimpleArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity {
        ModelWithSimpleArrayModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::delete_entity(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8> {
        let mut values = dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithSimpleArrayStoreImpl of ModelWithSimpleArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithSimpleArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithSimpleArray>::get(world, serialized.span())
    }

    fn set(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithSimpleArray>::set_model(self, world);
    }

    fn delete(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithSimpleArray>::delete_model(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithSimpleArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<u8> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithSimpleArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithSimpleArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithSimpleArrayEntity> {
    fn id(self: @ModelWithSimpleArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithSimpleArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithSimpleArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithSimpleArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithSimpleArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithSimpleArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithSimpleArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
    }

    fn delete_entity(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithSimpleArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithSimpleArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithSimpleArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithSimpleArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithSimpleArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithSimpleArrayModelImpl of dojo::model::Model<ModelWithSimpleArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithSimpleArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithSimpleArrayStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2155888289741706273257207428305937938996511115291276975807216945184181752777
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        173141902001925402715103859951360389436088950156916962046507357841237663931
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithSimpleArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
pub mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithSimpleArray"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithSimpleArray"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2155888289741706273257207428305937938996511115291276975807216945184181752777
        }

        fn name_hash(self: @ContractState) -> felt252 {
            173141902001925402715103859951360389436088950156916962046507357841237663931
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_simple_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_simple_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_simple_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithByteArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithByteArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: ByteArray,

}

#[generate_trait]
pub impl ModelWithByteArrayEntityStoreImpl of ModelWithByteArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity {
        ModelWithByteArrayModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithByteArrayEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithByteArrayEntity>::delete_entity(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithByteArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray {
        let mut values = dojo::model::ModelEntity::<ModelWithByteArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<ByteArray>::deserialize(ref values);

        if core::option::OptionTrait::<ByteArray>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ByteArray>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: ByteArray) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithByteArrayStoreImpl of ModelWithByteArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithByteArray>::get(world, serialized.span())
    }

    fn set(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithByteArray>::set_model(self, world);
    }

    fn delete(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithByteArray>::delete_model(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithByteArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithByteArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<ByteArray>::deserialize(ref values);

        if core::option::OptionTrait::<ByteArray>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ByteArray>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: ByteArray) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithByteArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithByteArrayEntity> {
    fn id(self: @ModelWithByteArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithByteArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithByteArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithByteArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithByteArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithByteArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithByteArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
    }

    fn delete_entity(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithByteArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithByteArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithByteArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithByteArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithByteArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithByteArrayModelImpl of dojo::model::Model<ModelWithByteArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithByteArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithByteArrayStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2309493726682581230048608406375650493303358263694405202817326852234706548038
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2176409715042145900636260236501596599545103472111273072320531220776338338674
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithByteArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
pub mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithByteArray"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithByteArray"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2309493726682581230048608406375650493303358263694405202817326852234706548038
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2176409715042145900636260236501596599545103472111273072320531220776338338674
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_byte_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithByteArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_byte_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_byte_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithComplexArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithComplexArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<Vec3>,

}

#[generate_trait]
pub impl ModelWithComplexArrayEntityStoreImpl of ModelWithComplexArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity {
        ModelWithComplexArrayModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::delete_entity(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3> {
        let mut values = dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<Array<Vec3>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<Vec3>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<Vec3>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<Vec3>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithComplexArrayStoreImpl of ModelWithComplexArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithComplexArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithComplexArray>::get(world, serialized.span())
    }

    fn set(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithComplexArray>::set_model(self, world);
    }

    fn delete(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithComplexArray>::delete_model(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithComplexArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<Vec3> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithComplexArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<Array<Vec3>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<Vec3>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<Vec3>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: Array<Vec3>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithComplexArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithComplexArrayEntity> {
    fn id(self: @ModelWithComplexArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithComplexArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithComplexArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithComplexArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithComplexArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithComplexArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithComplexArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
    }

    fn delete_entity(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithComplexArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithComplexArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithComplexArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithComplexArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithComplexArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithComplexArrayModelImpl of dojo::model::Model<ModelWithComplexArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithComplexArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithComplexArrayStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1293570145807126672811046976011709110822800800255162893130594439459909679461
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2866472224509756243720005045848892642397514372569303051745174230372637769655
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithComplexArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
pub mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithComplexArray"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithComplexArray"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           1293570145807126672811046976011709110822800800255162893130594439459909679461
        }

        fn name_hash(self: @ContractState) -> felt252 {
            2866472224509756243720005045848892642397514372569303051745174230372637769655
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_complex_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithComplexArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_complex_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_complex_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithTupleIntrospect<> of dojo::model::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::Layout::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::layout(),
dojo::model::introspect::Introspect::<u16>::layout(),
dojo::model::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::ty(),
dojo::model::introspect::Introspect::<u16>::ty(),
dojo::model::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, u16, u32),

}

#[generate_trait]
pub impl ModelWithTupleEntityStoreImpl of ModelWithTupleEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity {
        ModelWithTupleModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithTupleEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithTupleEntity>::delete_entity(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32) {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<(u8, u16, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, u16, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, u16, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithTupleStoreImpl of ModelWithTupleStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTuple {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTuple>::get(world, serialized.span())
    }

    fn set(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTuple>::set_model(self, world);
    }

    fn delete(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTuple>::delete_model(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTuple>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, u16, u32) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTuple>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<(u8, u16, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, u16, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, u16, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithTupleModelEntityImpl of dojo::model::ModelEntity<ModelWithTupleEntity> {
    fn id(self: @ModelWithTupleEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithTupleEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithTupleEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithTupleEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithTupleEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithTupleEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithTupleEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
    }

    fn delete_entity(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTuple>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithTuple>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTuple>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithTuple>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithTupleModelImpl of dojo::model::Model<ModelWithTuple> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithTuple {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithTupleStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2556860780543194947392385177981405629628409496147617432088261544126553394590
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3222351670132870101782632958288197874250493316621507272653773018669253981260
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithTuple) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
pub mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithTuple"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithTuple"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           2556860780543194947392385177981405629628409496147617432088261544126553394590
        }

        fn name_hash(self: @ContractState) -> felt252 {
            3222351670132870101782632958288197874250493316621507272653773018669253981260
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_tupleImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTuple>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tupleImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tupleImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::model::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::model::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::utils::sum(sizes))
                
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::Layout::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::layout(),
dojo::model::introspect::Introspect::<Vec3>::layout(),
dojo::model::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::ty(),
dojo::model::introspect::Introspect::<Vec3>::ty(),
dojo::model::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleNoPrimitivesEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, Vec3, u32),

}

#[generate_trait]
pub impl ModelWithTupleNoPrimitivesEntityStoreImpl of ModelWithTupleNoPrimitivesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity {
        ModelWithTupleNoPrimitivesModelEntityImpl::get(world, entity_id)
    }

    fn update(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::update_entity(self, world);
    }

    fn delete(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::delete_entity(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32) {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<(u8, Vec3, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, Vec3, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, Vec3, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithTupleNoPrimitivesStoreImpl of ModelWithTupleNoPrimitivesStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTupleNoPrimitives {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTupleNoPrimitives>::get(world, serialized.span())
    }

    fn set(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTupleNoPrimitives>::set_model(self, world);
    }

    fn delete(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher) {
        dojo::model::Model::<ModelWithTupleNoPrimitives>::delete_model(self, world);
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTupleNoPrimitives>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, Vec3, u32) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTupleNoPrimitives>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<(u8, Vec3, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, Vec3, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, Vec3, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithTupleNoPrimitivesModelEntityImpl of dojo::model::ModelEntity<ModelWithTupleNoPrimitivesEntity> {
    fn id(self: @ModelWithTupleNoPrimitivesEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithTupleNoPrimitivesEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithTupleNoPrimitivesEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithTupleNoPrimitivesEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithTupleNoPrimitivesEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithTupleNoPrimitivesEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithTupleNoPrimitivesEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update_entity(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
    }

    fn delete_entity(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTupleNoPrimitives>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleNoPrimitivesEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTupleNoPrimitives>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithTupleNoPrimitivesModelImpl of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithTupleNoPrimitives {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithTupleNoPrimitivesStore::from_values(ref _keys, ref values)
    }

   fn set_model(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete_model(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_test"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "dojo_test-ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        59168777730614245274545541976317431416582911855710103554159293691166950405
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        157059227407493660591195028728750607977045261142495925435047270200565107096
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        1452123528942907587532668415362544424816022573043154497385993678618948064048
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithTupleNoPrimitives) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
pub mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           "ModelWithTupleNoPrimitives"
        }

        fn namespace(self: @ContractState) -> ByteArray {
           "dojo_test"
        }

        fn tag(self: @ContractState) -> ByteArray {
            "dojo_test-ModelWithTupleNoPrimitives"
        }

        fn version(self: @ContractState) -> u8 {
           1
        }

        fn selector(self: @ContractState) -> felt252 {
           59168777730614245274545541976317431416582911855710103554159293691166950405
        }

        fn name_hash(self: @ContractState) -> felt252 {
            157059227407493660591195028728750607977045261142495925435047270200565107096
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            1452123528942907587532668415362544424816022573043154497385993678618948064048
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_tuple_no_primitivesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tuple_no_primitivesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tuple_no_primitivesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}
impl BadModelMultipleVersionsEntityDrop of core::traits::Drop::<BadModelMultipleVersionsEntity>;
impl BadModelMultipleVersionsEntitySerde of core::serde::Serde::<BadModelMultipleVersionsEntity> {
    fn serialize(self: @BadModelMultipleVersionsEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelMultipleVersionsEntity> {
        core::option::Option::Some(BadModelMultipleVersionsEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelMultipleVersionsEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity;

    fn update(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelMultipleVersionsStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelMultipleVersions;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions;

    fn set(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_multiple_versionsDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelMultipleVersions);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsLibraryDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsLibraryDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_multiple_versionsSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelMultipleVersions) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsSafeLibraryDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeLibraryDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsSafeDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelBadVersionTypeEntityDrop of core::traits::Drop::<BadModelBadVersionTypeEntity>;
impl BadModelBadVersionTypeEntitySerde of core::serde::Serde::<BadModelBadVersionTypeEntity> {
    fn serialize(self: @BadModelBadVersionTypeEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelBadVersionTypeEntity> {
        core::option::Option::Some(BadModelBadVersionTypeEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelBadVersionTypeEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity;

    fn update(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelBadVersionTypeStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelBadVersionType;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType;

    fn set(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_bad_version_typeDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelBadVersionType);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeLibraryDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeLibraryDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_bad_version_typeSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelBadVersionType) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeSafeLibraryDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeLibraryDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeSafeDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelNoVersionValueEntityDrop of core::traits::Drop::<BadModelNoVersionValueEntity>;
impl BadModelNoVersionValueEntitySerde of core::serde::Serde::<BadModelNoVersionValueEntity> {
    fn serialize(self: @BadModelNoVersionValueEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNoVersionValueEntity> {
        core::option::Option::Some(BadModelNoVersionValueEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelNoVersionValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity;

    fn update(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelNoVersionValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNoVersionValue;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue;

    fn set(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_no_version_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNoVersionValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueLibraryDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueLibraryDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_no_version_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNoVersionValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueSafeLibraryDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeLibraryDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueSafeDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelUnexpectedArgWithValueEntityDrop of core::traits::Drop::<BadModelUnexpectedArgWithValueEntity>;
impl BadModelUnexpectedArgWithValueEntitySerde of core::serde::Serde::<BadModelUnexpectedArgWithValueEntity> {
    fn serialize(self: @BadModelUnexpectedArgWithValueEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgWithValueEntity> {
        core::option::Option::Some(BadModelUnexpectedArgWithValueEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelUnexpectedArgWithValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity;

    fn update(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelUnexpectedArgWithValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValue;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue;

    fn set(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_unexpected_arg_with_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueLibraryDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueSafeDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelUnexpectedArgEntityDrop of core::traits::Drop::<BadModelUnexpectedArgEntity>;
impl BadModelUnexpectedArgEntitySerde of core::serde::Serde::<BadModelUnexpectedArgEntity> {
    fn serialize(self: @BadModelUnexpectedArgEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgEntity> {
        core::option::Option::Some(BadModelUnexpectedArgEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelUnexpectedArgEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity;

    fn update(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelUnexpectedArgStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArg;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg;

    fn set(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_unexpected_argDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArg);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argLibraryDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argLibraryDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_unexpected_argSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argSafeLibraryDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeLibraryDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argSafeDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelNotSupportedVersionEntityDrop of core::traits::Drop::<BadModelNotSupportedVersionEntity>;
impl BadModelNotSupportedVersionEntitySerde of core::serde::Serde::<BadModelNotSupportedVersionEntity> {
    fn serialize(self: @BadModelNotSupportedVersionEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNotSupportedVersionEntity> {
        core::option::Option::Some(BadModelNotSupportedVersionEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelNotSupportedVersionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity;

    fn update(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelNotSupportedVersionStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNotSupportedVersion;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion;

    fn set(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher);

    fn delete(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_not_supported_versionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionLibraryDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionLibraryDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_not_supported_versionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionSafeLibraryDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeLibraryDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionSafeDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl Modelv0EntityDrop of core::traits::Drop::<Modelv0Entity>;
impl Modelv0EntitySerde of core::serde::Serde::<Modelv0Entity> {
    fn serialize(self: @Modelv0Entity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Modelv0Entity> {
        core::option::Option::Some(Modelv0Entity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait Modelv0EntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity;

    fn update(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait Modelv0Store {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Modelv0;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0;

    fn set(self: @Modelv0, world: dojo::world::IWorldDispatcher);

    fn delete(self: @Modelv0, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @Modelv0, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodelv_0DispatcherTrait<T> {
    fn ensure_abi(self: T, model: Modelv0);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0DispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0Dispatcher> {
    fn ensure_abi(self: Imodelv_0Dispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0LibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0LibraryDispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0LibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0LibraryDispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodelv_0SafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Modelv0) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0SafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0SafeLibraryDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeLibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeLibraryDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0SafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0SafeDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithBadNamespaceFormatEntityDrop of core::traits::Drop::<ModelWithBadNamespaceFormatEntity>;
impl ModelWithBadNamespaceFormatEntitySerde of core::serde::Serde::<ModelWithBadNamespaceFormatEntity> {
    fn serialize(self: @ModelWithBadNamespaceFormatEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithBadNamespaceFormatEntity> {
        core::option::Option::Some(ModelWithBadNamespaceFormatEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithBadNamespaceFormatEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity;

    fn update(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithBadNamespaceFormatStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithBadNamespaceFormat;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat;

    fn set(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_bad_namespace_formatDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatLibraryDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatLibraryDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_bad_namespace_formatSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeLibraryDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatSafeDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithShortStringNamespaceEntityDrop of core::traits::Drop::<ModelWithShortStringNamespaceEntity>;
impl ModelWithShortStringNamespaceEntitySerde of core::serde::Serde::<ModelWithShortStringNamespaceEntity> {
    fn serialize(self: @ModelWithShortStringNamespaceEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithShortStringNamespaceEntity> {
        core::option::Option::Some(ModelWithShortStringNamespaceEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithShortStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity;

    fn update(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithShortStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithShortStringNamespace;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace;

    fn set(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_short_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceLibraryDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceLibraryDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_short_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeLibraryDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceSafeDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithStringNamespaceEntityDrop of core::traits::Drop::<ModelWithStringNamespaceEntity>;
impl ModelWithStringNamespaceEntitySerde of core::serde::Serde::<ModelWithStringNamespaceEntity> {
    fn serialize(self: @ModelWithStringNamespaceEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithStringNamespaceEntity> {
        core::option::Option::Some(ModelWithStringNamespaceEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity;

    fn update(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithStringNamespace;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace;

    fn set(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceLibraryDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceLibraryDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeLibraryDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceSafeDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl PositionEntityDrop of core::traits::Drop::<PositionEntity>;
impl PositionEntitySerde of core::serde::Serde::<PositionEntity> {
    fn serialize(self: @PositionEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PositionEntity> {
        core::option::Option::Some(PositionEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait PositionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity;

    fn update(self: @PositionEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @PositionEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @PositionEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait PositionStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Position;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position;

    fn set(self: @Position, world: dojo::world::IWorldDispatcher);

    fn delete(self: @Position, world: dojo::world::IWorldDispatcher);

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @Position, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait IpositionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Position);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionDispatcherImpl of IpositionDispatcherTrait<IpositionDispatcher> {
    fn ensure_abi(self: IpositionDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionLibraryDispatcherImpl of IpositionDispatcherTrait<IpositionLibraryDispatcher> {
    fn ensure_abi(self: IpositionLibraryDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IpositionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Position) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionSafeLibraryDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeLibraryDispatcher> {
    fn ensure_abi(self: IpositionSafeLibraryDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionSafeDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeDispatcher> {
    fn ensure_abi(self: IpositionSafeDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl RolesEntityDrop of core::traits::Drop::<RolesEntity>;
impl RolesEntitySerde of core::serde::Serde::<RolesEntity> {
    fn serialize(self: @RolesEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.role_ids, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<RolesEntity> {
        core::option::Option::Some(RolesEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            role_ids: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait RolesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity;

    fn update(self: @RolesEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @RolesEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8>;

    fn set_role_ids(self: @RolesEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>);

}
pub trait RolesStore {
    fn entity_id_from_keys() -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Roles;

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles;

    fn set(self: @Roles, world: dojo::world::IWorldDispatcher);

    fn delete(self: @Roles, world: dojo::world::IWorldDispatcher);

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, ) -> Array<u8>;

    fn set_role_ids(self: @Roles, world: dojo::world::IWorldDispatcher, value: Array<u8>);
            
}
pub trait IrolesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Roles);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesDispatcherImpl of IrolesDispatcherTrait<IrolesDispatcher> {
    fn ensure_abi(self: IrolesDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesLibraryDispatcherImpl of IrolesDispatcherTrait<IrolesLibraryDispatcher> {
    fn ensure_abi(self: IrolesLibraryDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IrolesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Roles) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesSafeLibraryDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeLibraryDispatcher> {
    fn ensure_abi(self: IrolesSafeLibraryDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesSafeDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeDispatcher> {
    fn ensure_abi(self: IrolesSafeDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl OnlyKeyModelEntityDrop of core::traits::Drop::<OnlyKeyModelEntity>;
impl OnlyKeyModelEntitySerde of core::serde::Serde::<OnlyKeyModelEntity> {
    fn serialize(self: @OnlyKeyModelEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<OnlyKeyModelEntity> {
        core::option::Option::Some(OnlyKeyModelEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait OnlyKeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity;

    fn update(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher);

    
}
pub trait OnlyKeyModelStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> OnlyKeyModel;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel;

    fn set(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher);

    fn delete(self: @OnlyKeyModel, world: dojo::world::IWorldDispatcher);

    
}
pub trait Ionly_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: OnlyKeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelDispatcher> {
    fn ensure_abi(self: Ionly_key_modelDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelLibraryDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelLibraryDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ionly_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: OnlyKeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelSafeLibraryDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeLibraryDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelSafeDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl U256KeyModelEntityDrop of core::traits::Drop::<U256KeyModelEntity>;
impl U256KeyModelEntitySerde of core::serde::Serde::<U256KeyModelEntity> {
    fn serialize(self: @U256KeyModelEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<U256KeyModelEntity> {
        core::option::Option::Some(U256KeyModelEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait U256KeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity;

    fn update(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher);

    
}
pub trait U256KeyModelStore {
    fn entity_id_from_keys(id: u256) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> U256KeyModel;

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel;

    fn set(self: @U256KeyModel, world: dojo::world::IWorldDispatcher);

    fn delete(self: @U256KeyModel, world: dojo::world::IWorldDispatcher);

    
}
pub trait Iu_256_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: U256KeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelLibraryDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelLibraryDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Iu_256_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: U256KeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelSafeLibraryDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeLibraryDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelSafeDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl PlayerEntityDrop of core::traits::Drop::<PlayerEntity>;
impl PlayerEntitySerde of core::serde::Serde::<PlayerEntity> {
    fn serialize(self: @PlayerEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.name, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PlayerEntity> {
        core::option::Option::Some(PlayerEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            name: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait PlayerEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity;

    fn update(self: @PlayerEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @PlayerEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_name(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252;

    fn set_name(self: @PlayerEntity, world: dojo::world::IWorldDispatcher, value: felt252);

}
pub trait PlayerStore {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Player;

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player;

    fn set(self: @Player, world: dojo::world::IWorldDispatcher);

    fn delete(self: @Player, world: dojo::world::IWorldDispatcher);

    
    fn get_name(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> felt252;

    fn set_name(self: @Player, world: dojo::world::IWorldDispatcher, value: felt252);
            
}
pub trait IplayerDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Player);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerDispatcherImpl of IplayerDispatcherTrait<IplayerDispatcher> {
    fn ensure_abi(self: IplayerDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerLibraryDispatcherImpl of IplayerDispatcherTrait<IplayerLibraryDispatcher> {
    fn ensure_abi(self: IplayerLibraryDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IplayerSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Player) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerSafeLibraryDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeLibraryDispatcher> {
    fn ensure_abi(self: IplayerSafeLibraryDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerSafeDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeDispatcher> {
    fn ensure_abi(self: IplayerSafeDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithSimpleArrayEntityDrop of core::traits::Drop::<ModelWithSimpleArrayEntity>;
impl ModelWithSimpleArrayEntitySerde of core::serde::Serde::<ModelWithSimpleArrayEntity> {
    fn serialize(self: @ModelWithSimpleArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithSimpleArrayEntity> {
        core::option::Option::Some(ModelWithSimpleArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithSimpleArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity;

    fn update(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8>;

    fn set_y(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>);

}
pub trait ModelWithSimpleArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithSimpleArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray;

    fn set(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<u8>;

    fn set_y(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: Array<u8>);
            
}
pub trait Imodel_with_simple_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithSimpleArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arrayDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arrayLibraryDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayLibraryDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_simple_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithSimpleArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arraySafeLibraryDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeLibraryDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arraySafeDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithByteArrayEntityDrop of core::traits::Drop::<ModelWithByteArrayEntity>;
impl ModelWithByteArrayEntitySerde of core::serde::Serde::<ModelWithByteArrayEntity> {
    fn serialize(self: @ModelWithByteArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithByteArrayEntity> {
        core::option::Option::Some(ModelWithByteArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithByteArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity;

    fn update(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray;

    fn set_y(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: ByteArray);

}
pub trait ModelWithByteArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithByteArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray;

    fn set(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ByteArray;

    fn set_y(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: ByteArray);
            
}
pub trait Imodel_with_byte_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithByteArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arrayDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arrayLibraryDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayLibraryDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_byte_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithByteArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arraySafeLibraryDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeLibraryDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arraySafeDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithComplexArrayEntityDrop of core::traits::Drop::<ModelWithComplexArrayEntity>;
impl ModelWithComplexArrayEntitySerde of core::serde::Serde::<ModelWithComplexArrayEntity> {
    fn serialize(self: @ModelWithComplexArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithComplexArrayEntity> {
        core::option::Option::Some(ModelWithComplexArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithComplexArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity;

    fn update(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3>;

    fn set_y(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<Vec3>);

}
pub trait ModelWithComplexArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithComplexArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray;

    fn set(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<Vec3>;

    fn set_y(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: Array<Vec3>);
            
}
pub trait Imodel_with_complex_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithComplexArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arrayDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arrayLibraryDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayLibraryDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_complex_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithComplexArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arraySafeLibraryDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeLibraryDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arraySafeDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithTupleEntityDrop of core::traits::Drop::<ModelWithTupleEntity>;
impl ModelWithTupleEntitySerde of core::serde::Serde::<ModelWithTupleEntity> {
    fn serialize(self: @ModelWithTupleEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleEntity> {
        core::option::Option::Some(ModelWithTupleEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithTupleEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity;

    fn update(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32);

    fn set_y(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32));

}
pub trait ModelWithTupleStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTuple;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple;

    fn set(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, u16, u32);

    fn set_y(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32));
            
}
pub trait Imodel_with_tupleDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTuple);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleLibraryDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleLibraryDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_tupleSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTuple) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleSafeLibraryDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeLibraryDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleSafeDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithTupleNoPrimitivesEntityDrop of core::traits::Drop::<ModelWithTupleNoPrimitivesEntity>;
impl ModelWithTupleNoPrimitivesEntitySerde of core::serde::Serde::<ModelWithTupleNoPrimitivesEntity> {
    fn serialize(self: @ModelWithTupleNoPrimitivesEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleNoPrimitivesEntity> {
        core::option::Option::Some(ModelWithTupleNoPrimitivesEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithTupleNoPrimitivesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity;

    fn update(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32);

    fn set_y(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32));

}
pub trait ModelWithTupleNoPrimitivesStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTupleNoPrimitives;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives;

    fn set(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher);

    fn delete(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher);

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, Vec3, u32);

    fn set_y(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32));
            
}
pub trait Imodel_with_tuple_no_primitivesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesLibraryDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_tuple_no_primitivesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesSafeDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl Ibad_model_multiple_versionsDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsDispatcher of starknet::Store::<Ibad_model_multiple_versionsDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_multiple_versionsDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsDispatcher>) -> Ibad_model_multiple_versionsDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_multiple_versionsDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_multiple_versionsDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsDispatcher>>) -> Ibad_model_multiple_versionsDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_multiple_versionsLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsLibraryDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsLibraryDispatcher>) -> Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_multiple_versionsLibraryDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsLibraryDispatcher>>) -> Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsSafeLibraryDispatcher>) -> Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsSafeLibraryDispatcher>>) -> Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_multiple_versionsSafeDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsSafeDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsSafeDispatcher>) -> Ibad_model_multiple_versionsSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_multiple_versionsSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_multiple_versionsSafeDispatcher> {
    type SubPointersType = Ibad_model_multiple_versionsSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsSafeDispatcher>>) -> Ibad_model_multiple_versionsSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_multiple_versionsSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_bad_version_typeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeDispatcher of starknet::Store::<Ibad_model_bad_version_typeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_bad_version_typeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeDispatcher>) -> Ibad_model_bad_version_typeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_bad_version_typeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_bad_version_typeDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeDispatcher>>) -> Ibad_model_bad_version_typeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_bad_version_typeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeLibraryDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeLibraryDispatcher>) -> Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_bad_version_typeLibraryDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeLibraryDispatcher>>) -> Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeSafeLibraryDispatcher>) -> Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeSafeLibraryDispatcher>>) -> Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_bad_version_typeSafeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeSafeDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeSafeDispatcher>) -> Ibad_model_bad_version_typeSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_bad_version_typeSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_bad_version_typeSafeDispatcher> {
    type SubPointersType = Ibad_model_bad_version_typeSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeSafeDispatcher>>) -> Ibad_model_bad_version_typeSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_bad_version_typeSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_no_version_valueDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueDispatcher of starknet::Store::<Ibad_model_no_version_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_no_version_valueDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueDispatcher>) -> Ibad_model_no_version_valueDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_no_version_valueDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_no_version_valueDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueDispatcher>>) -> Ibad_model_no_version_valueDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_no_version_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueLibraryDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueLibraryDispatcher>) -> Ibad_model_no_version_valueLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_no_version_valueLibraryDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueLibraryDispatcher>>) -> Ibad_model_no_version_valueLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_no_version_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueSafeLibraryDispatcher>) -> Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueSafeLibraryDispatcher>>) -> Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_no_version_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_no_version_valueSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueSafeDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueSafeDispatcher>) -> Ibad_model_no_version_valueSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_no_version_valueSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_no_version_valueSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_no_version_valueSafeDispatcher> {
    type SubPointersType = Ibad_model_no_version_valueSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueSafeDispatcher>>) -> Ibad_model_no_version_valueSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_no_version_valueSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueDispatcher>) -> Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_arg_with_valueDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueDispatcher>>) -> Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>) -> Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>>) -> Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>) -> Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>>) -> Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueSafeDispatcher>) -> Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>>) -> Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_argDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argDispatcher of starknet::Store::<Ibad_model_unexpected_argDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_argDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argDispatcher>) -> Ibad_model_unexpected_argDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_unexpected_argDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_argDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argDispatcher>>) -> Ibad_model_unexpected_argDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_argLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argLibraryDispatcher>) -> Ibad_model_unexpected_argLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_argLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argLibraryDispatcher>>) -> Ibad_model_unexpected_argLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_argSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argSafeLibraryDispatcher>) -> Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argSafeLibraryDispatcher>>) -> Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_argSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_argSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argSafeDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argSafeDispatcher>) -> Ibad_model_unexpected_argSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_unexpected_argSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_unexpected_argSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_unexpected_argSafeDispatcher> {
    type SubPointersType = Ibad_model_unexpected_argSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argSafeDispatcher>>) -> Ibad_model_unexpected_argSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_unexpected_argSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_not_supported_versionDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionDispatcher of starknet::Store::<Ibad_model_not_supported_versionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_not_supported_versionDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionDispatcher>) -> Ibad_model_not_supported_versionDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_not_supported_versionDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_not_supported_versionDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionDispatcher>>) -> Ibad_model_not_supported_versionDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_not_supported_versionLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionLibraryDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionLibraryDispatcher>) -> Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_not_supported_versionLibraryDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionLibraryDispatcher>>) -> Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionSafeLibraryDispatcher>) -> Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionSafeLibraryDispatcher>>) -> Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_not_supported_versionSafeDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionSafeDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionSafeDispatcher>) -> Ibad_model_not_supported_versionSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ibad_model_not_supported_versionSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ibad_model_not_supported_versionSafeDispatcher> {
    type SubPointersType = Ibad_model_not_supported_versionSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionSafeDispatcher>>) -> Ibad_model_not_supported_versionSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ibad_model_not_supported_versionSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodelv_0DispatcherCopy of core::traits::Copy::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherDrop of core::traits::Drop::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherSerde of core::serde::Serde::<Imodelv_0Dispatcher> {
    fn serialize(self: @Imodelv_0Dispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0Dispatcher> {
        core::option::Option::Some(Imodelv_0Dispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0Dispatcher of starknet::Store::<Imodelv_0Dispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodelv_0DispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodelv_0DispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0Dispatcher> {
    type SubPointersType = Imodelv_0DispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0Dispatcher>) -> Imodelv_0DispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0DispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodelv_0DispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodelv_0DispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodelv_0Dispatcher> {
    type SubPointersType = Imodelv_0DispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0Dispatcher>>) -> Imodelv_0DispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0DispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodelv_0LibraryDispatcherCopy of core::traits::Copy::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherDrop of core::traits::Drop::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherSerde of core::serde::Serde::<Imodelv_0LibraryDispatcher> {
    fn serialize(self: @Imodelv_0LibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0LibraryDispatcher> {
        core::option::Option::Some(Imodelv_0LibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0LibraryDispatcher of starknet::Store::<Imodelv_0LibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodelv_0LibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodelv_0LibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0LibraryDispatcher> {
    type SubPointersType = Imodelv_0LibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0LibraryDispatcher>) -> Imodelv_0LibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0LibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodelv_0LibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodelv_0LibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodelv_0LibraryDispatcher> {
    type SubPointersType = Imodelv_0LibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0LibraryDispatcher>>) -> Imodelv_0LibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0LibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodelv_0SafeLibraryDispatcherCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherSerde of core::serde::Serde::<Imodelv_0SafeLibraryDispatcher> {
    fn serialize(self: @Imodelv_0SafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeLibraryDispatcher> {
        core::option::Option::Some(Imodelv_0SafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeLibraryDispatcher of starknet::Store::<Imodelv_0SafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodelv_0SafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodelv_0SafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0SafeLibraryDispatcher> {
    type SubPointersType = Imodelv_0SafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0SafeLibraryDispatcher>) -> Imodelv_0SafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0SafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodelv_0SafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodelv_0SafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodelv_0SafeLibraryDispatcher> {
    type SubPointersType = Imodelv_0SafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0SafeLibraryDispatcher>>) -> Imodelv_0SafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0SafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodelv_0SafeDispatcherCopy of core::traits::Copy::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherDrop of core::traits::Drop::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherSerde of core::serde::Serde::<Imodelv_0SafeDispatcher> {
    fn serialize(self: @Imodelv_0SafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeDispatcher> {
        core::option::Option::Some(Imodelv_0SafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeDispatcher of starknet::Store::<Imodelv_0SafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodelv_0SafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodelv_0SafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0SafeDispatcher> {
    type SubPointersType = Imodelv_0SafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0SafeDispatcher>) -> Imodelv_0SafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0SafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodelv_0SafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodelv_0SafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodelv_0SafeDispatcher> {
    type SubPointersType = Imodelv_0SafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0SafeDispatcher>>) -> Imodelv_0SafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodelv_0SafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_bad_namespace_formatDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatDispatcher>) -> Imodel_with_bad_namespace_formatDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_bad_namespace_formatDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_bad_namespace_formatDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatDispatcher>>) -> Imodel_with_bad_namespace_formatDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatLibraryDispatcher>) -> Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatLibraryDispatcher>>) -> Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>) -> Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>>) -> Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatSafeDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatSafeDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatSafeDispatcher>) -> Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_bad_namespace_formatSafeDispatcher> {
    type SubPointersType = Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatSafeDispatcher>>) -> Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_short_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceDispatcher of starknet::Store::<Imodel_with_short_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_short_string_namespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceDispatcher>) -> Imodel_with_short_string_namespaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_short_string_namespaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_short_string_namespaceDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceDispatcher>>) -> Imodel_with_short_string_namespaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_short_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceLibraryDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceLibraryDispatcher>) -> Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_short_string_namespaceLibraryDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceLibraryDispatcher>>) -> Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceSafeLibraryDispatcher>) -> Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>>) -> Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_short_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceSafeDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceSafeDispatcher>) -> Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_short_string_namespaceSafeDispatcher> {
    type SubPointersType = Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceSafeDispatcher>>) -> Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceDispatcher of starknet::Store::<Imodel_with_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_string_namespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceDispatcher>) -> Imodel_with_string_namespaceDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_string_namespaceDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_string_namespaceDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceDispatcher>>) -> Imodel_with_string_namespaceDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceLibraryDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceLibraryDispatcher>) -> Imodel_with_string_namespaceLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_string_namespaceLibraryDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceLibraryDispatcher>>) -> Imodel_with_string_namespaceLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceSafeLibraryDispatcher>) -> Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceSafeLibraryDispatcher>>) -> Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceSafeDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceSafeDispatcher>) -> Imodel_with_string_namespaceSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_string_namespaceSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_string_namespaceSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_string_namespaceSafeDispatcher> {
    type SubPointersType = Imodel_with_string_namespaceSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceSafeDispatcher>>) -> Imodel_with_string_namespaceSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_string_namespaceSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IpositionDispatcherCopy of core::traits::Copy::<IpositionDispatcher>;
impl IpositionDispatcherDrop of core::traits::Drop::<IpositionDispatcher>;
impl IpositionDispatcherSerde of core::serde::Serde::<IpositionDispatcher> {
    fn serialize(self: @IpositionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionDispatcher> {
        core::option::Option::Some(IpositionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionDispatcher of starknet::Store::<IpositionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IpositionDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IpositionDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionDispatcher> {
    type SubPointersType = IpositionDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IpositionDispatcher>) -> IpositionDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IpositionDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IpositionDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IpositionDispatcher> {
    type SubPointersType = IpositionDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionDispatcher>>) -> IpositionDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IpositionLibraryDispatcherCopy of core::traits::Copy::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherDrop of core::traits::Drop::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherSerde of core::serde::Serde::<IpositionLibraryDispatcher> {
    fn serialize(self: @IpositionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionLibraryDispatcher> {
        core::option::Option::Some(IpositionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionLibraryDispatcher of starknet::Store::<IpositionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IpositionLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IpositionLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionLibraryDispatcher> {
    type SubPointersType = IpositionLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IpositionLibraryDispatcher>) -> IpositionLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IpositionLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IpositionLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IpositionLibraryDispatcher> {
    type SubPointersType = IpositionLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionLibraryDispatcher>>) -> IpositionLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IpositionSafeLibraryDispatcherCopy of core::traits::Copy::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherDrop of core::traits::Drop::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherSerde of core::serde::Serde::<IpositionSafeLibraryDispatcher> {
    fn serialize(self: @IpositionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeLibraryDispatcher> {
        core::option::Option::Some(IpositionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeLibraryDispatcher of starknet::Store::<IpositionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IpositionSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IpositionSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionSafeLibraryDispatcher> {
    type SubPointersType = IpositionSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IpositionSafeLibraryDispatcher>) -> IpositionSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IpositionSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IpositionSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IpositionSafeLibraryDispatcher> {
    type SubPointersType = IpositionSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionSafeLibraryDispatcher>>) -> IpositionSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IpositionSafeDispatcherCopy of core::traits::Copy::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherDrop of core::traits::Drop::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherSerde of core::serde::Serde::<IpositionSafeDispatcher> {
    fn serialize(self: @IpositionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeDispatcher> {
        core::option::Option::Some(IpositionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeDispatcher of starknet::Store::<IpositionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IpositionSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IpositionSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionSafeDispatcher> {
    type SubPointersType = IpositionSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IpositionSafeDispatcher>) -> IpositionSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IpositionSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IpositionSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IpositionSafeDispatcher> {
    type SubPointersType = IpositionSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionSafeDispatcher>>) -> IpositionSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IpositionSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IrolesDispatcherCopy of core::traits::Copy::<IrolesDispatcher>;
impl IrolesDispatcherDrop of core::traits::Drop::<IrolesDispatcher>;
impl IrolesDispatcherSerde of core::serde::Serde::<IrolesDispatcher> {
    fn serialize(self: @IrolesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesDispatcher> {
        core::option::Option::Some(IrolesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesDispatcher of starknet::Store::<IrolesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IrolesDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IrolesDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesDispatcher> {
    type SubPointersType = IrolesDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IrolesDispatcher>) -> IrolesDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IrolesDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IrolesDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IrolesDispatcher> {
    type SubPointersType = IrolesDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesDispatcher>>) -> IrolesDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IrolesLibraryDispatcherCopy of core::traits::Copy::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherDrop of core::traits::Drop::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherSerde of core::serde::Serde::<IrolesLibraryDispatcher> {
    fn serialize(self: @IrolesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesLibraryDispatcher> {
        core::option::Option::Some(IrolesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesLibraryDispatcher of starknet::Store::<IrolesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IrolesLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IrolesLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesLibraryDispatcher> {
    type SubPointersType = IrolesLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IrolesLibraryDispatcher>) -> IrolesLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IrolesLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IrolesLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IrolesLibraryDispatcher> {
    type SubPointersType = IrolesLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesLibraryDispatcher>>) -> IrolesLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IrolesSafeLibraryDispatcherCopy of core::traits::Copy::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherDrop of core::traits::Drop::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherSerde of core::serde::Serde::<IrolesSafeLibraryDispatcher> {
    fn serialize(self: @IrolesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeLibraryDispatcher> {
        core::option::Option::Some(IrolesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeLibraryDispatcher of starknet::Store::<IrolesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IrolesSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IrolesSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesSafeLibraryDispatcher> {
    type SubPointersType = IrolesSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IrolesSafeLibraryDispatcher>) -> IrolesSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IrolesSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IrolesSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IrolesSafeLibraryDispatcher> {
    type SubPointersType = IrolesSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesSafeLibraryDispatcher>>) -> IrolesSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IrolesSafeDispatcherCopy of core::traits::Copy::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherDrop of core::traits::Drop::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherSerde of core::serde::Serde::<IrolesSafeDispatcher> {
    fn serialize(self: @IrolesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeDispatcher> {
        core::option::Option::Some(IrolesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeDispatcher of starknet::Store::<IrolesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IrolesSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IrolesSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesSafeDispatcher> {
    type SubPointersType = IrolesSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IrolesSafeDispatcher>) -> IrolesSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IrolesSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IrolesSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IrolesSafeDispatcher> {
    type SubPointersType = IrolesSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesSafeDispatcher>>) -> IrolesSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IrolesSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ionly_key_modelDispatcherCopy of core::traits::Copy::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherDrop of core::traits::Drop::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherSerde of core::serde::Serde::<Ionly_key_modelDispatcher> {
    fn serialize(self: @Ionly_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelDispatcher> {
        core::option::Option::Some(Ionly_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelDispatcher of starknet::Store::<Ionly_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ionly_key_modelDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ionly_key_modelDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelDispatcher> {
    type SubPointersType = Ionly_key_modelDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelDispatcher>) -> Ionly_key_modelDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ionly_key_modelDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ionly_key_modelDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ionly_key_modelDispatcher> {
    type SubPointersType = Ionly_key_modelDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelDispatcher>>) -> Ionly_key_modelDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ionly_key_modelLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelLibraryDispatcher of starknet::Store::<Ionly_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ionly_key_modelLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ionly_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelLibraryDispatcher> {
    type SubPointersType = Ionly_key_modelLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelLibraryDispatcher>) -> Ionly_key_modelLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ionly_key_modelLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ionly_key_modelLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ionly_key_modelLibraryDispatcher> {
    type SubPointersType = Ionly_key_modelLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelLibraryDispatcher>>) -> Ionly_key_modelLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ionly_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeLibraryDispatcher of starknet::Store::<Ionly_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ionly_key_modelSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ionly_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelSafeLibraryDispatcher> {
    type SubPointersType = Ionly_key_modelSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelSafeLibraryDispatcher>) -> Ionly_key_modelSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ionly_key_modelSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Ionly_key_modelSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ionly_key_modelSafeLibraryDispatcher> {
    type SubPointersType = Ionly_key_modelSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelSafeLibraryDispatcher>>) -> Ionly_key_modelSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Ionly_key_modelSafeDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeDispatcher of starknet::Store::<Ionly_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Ionly_key_modelSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ionly_key_modelSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelSafeDispatcher> {
    type SubPointersType = Ionly_key_modelSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelSafeDispatcher>) -> Ionly_key_modelSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Ionly_key_modelSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Ionly_key_modelSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Ionly_key_modelSafeDispatcher> {
    type SubPointersType = Ionly_key_modelSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelSafeDispatcher>>) -> Ionly_key_modelSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Ionly_key_modelSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Iu_256_key_modelDispatcherCopy of core::traits::Copy::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherDrop of core::traits::Drop::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherSerde of core::serde::Serde::<Iu_256_key_modelDispatcher> {
    fn serialize(self: @Iu_256_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelDispatcher> {
        core::option::Option::Some(Iu_256_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelDispatcher of starknet::Store::<Iu_256_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Iu_256_key_modelDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Iu_256_key_modelDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelDispatcher> {
    type SubPointersType = Iu_256_key_modelDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelDispatcher>) -> Iu_256_key_modelDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Iu_256_key_modelDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Iu_256_key_modelDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Iu_256_key_modelDispatcher> {
    type SubPointersType = Iu_256_key_modelDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelDispatcher>>) -> Iu_256_key_modelDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Iu_256_key_modelLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelLibraryDispatcher of starknet::Store::<Iu_256_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Iu_256_key_modelLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Iu_256_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelLibraryDispatcher> {
    type SubPointersType = Iu_256_key_modelLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelLibraryDispatcher>) -> Iu_256_key_modelLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Iu_256_key_modelLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Iu_256_key_modelLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Iu_256_key_modelLibraryDispatcher> {
    type SubPointersType = Iu_256_key_modelLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelLibraryDispatcher>>) -> Iu_256_key_modelLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Iu_256_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeLibraryDispatcher of starknet::Store::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Iu_256_key_modelSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelSafeLibraryDispatcher> {
    type SubPointersType = Iu_256_key_modelSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelSafeLibraryDispatcher>) -> Iu_256_key_modelSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Iu_256_key_modelSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Iu_256_key_modelSafeLibraryDispatcher> {
    type SubPointersType = Iu_256_key_modelSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelSafeLibraryDispatcher>>) -> Iu_256_key_modelSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Iu_256_key_modelSafeDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeDispatcher of starknet::Store::<Iu_256_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Iu_256_key_modelSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Iu_256_key_modelSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelSafeDispatcher> {
    type SubPointersType = Iu_256_key_modelSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelSafeDispatcher>) -> Iu_256_key_modelSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Iu_256_key_modelSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Iu_256_key_modelSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Iu_256_key_modelSafeDispatcher> {
    type SubPointersType = Iu_256_key_modelSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelSafeDispatcher>>) -> Iu_256_key_modelSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Iu_256_key_modelSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IplayerDispatcherCopy of core::traits::Copy::<IplayerDispatcher>;
impl IplayerDispatcherDrop of core::traits::Drop::<IplayerDispatcher>;
impl IplayerDispatcherSerde of core::serde::Serde::<IplayerDispatcher> {
    fn serialize(self: @IplayerDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerDispatcher> {
        core::option::Option::Some(IplayerDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerDispatcher of starknet::Store::<IplayerDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IplayerDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IplayerDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerDispatcher> {
    type SubPointersType = IplayerDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IplayerDispatcher>) -> IplayerDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IplayerDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IplayerDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IplayerDispatcher> {
    type SubPointersType = IplayerDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerDispatcher>>) -> IplayerDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IplayerLibraryDispatcherCopy of core::traits::Copy::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherDrop of core::traits::Drop::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherSerde of core::serde::Serde::<IplayerLibraryDispatcher> {
    fn serialize(self: @IplayerLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerLibraryDispatcher> {
        core::option::Option::Some(IplayerLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerLibraryDispatcher of starknet::Store::<IplayerLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IplayerLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IplayerLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerLibraryDispatcher> {
    type SubPointersType = IplayerLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IplayerLibraryDispatcher>) -> IplayerLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IplayerLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IplayerLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IplayerLibraryDispatcher> {
    type SubPointersType = IplayerLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerLibraryDispatcher>>) -> IplayerLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IplayerSafeLibraryDispatcherCopy of core::traits::Copy::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherDrop of core::traits::Drop::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherSerde of core::serde::Serde::<IplayerSafeLibraryDispatcher> {
    fn serialize(self: @IplayerSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeLibraryDispatcher> {
        core::option::Option::Some(IplayerSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeLibraryDispatcher of starknet::Store::<IplayerSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IplayerSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IplayerSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerSafeLibraryDispatcher> {
    type SubPointersType = IplayerSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IplayerSafeLibraryDispatcher>) -> IplayerSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IplayerSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IplayerSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IplayerSafeLibraryDispatcher> {
    type SubPointersType = IplayerSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerSafeLibraryDispatcher>>) -> IplayerSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IplayerSafeDispatcherCopy of core::traits::Copy::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherDrop of core::traits::Drop::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherSerde of core::serde::Serde::<IplayerSafeDispatcher> {
    fn serialize(self: @IplayerSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeDispatcher> {
        core::option::Option::Some(IplayerSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeDispatcher of starknet::Store::<IplayerSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IplayerSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IplayerSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerSafeDispatcher> {
    type SubPointersType = IplayerSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IplayerSafeDispatcher>) -> IplayerSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IplayerSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IplayerSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IplayerSafeDispatcher> {
    type SubPointersType = IplayerSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerSafeDispatcher>>) -> IplayerSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IplayerSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_simple_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayDispatcher of starknet::Store::<Imodel_with_simple_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_simple_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arrayDispatcher> {
    type SubPointersType = Imodel_with_simple_arrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arrayDispatcher>) -> Imodel_with_simple_arrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_simple_arrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_simple_arrayDispatcher> {
    type SubPointersType = Imodel_with_simple_arrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arrayDispatcher>>) -> Imodel_with_simple_arrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arrayDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_simple_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayLibraryDispatcher of starknet::Store::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_simple_arrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arrayLibraryDispatcher>) -> Imodel_with_simple_arrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_simple_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_simple_arrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arrayLibraryDispatcher>>) -> Imodel_with_simple_arrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arrayLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_simple_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_simple_arraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arraySafeLibraryDispatcher>) -> Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_simple_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arraySafeLibraryDispatcher>>) -> Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_simple_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeDispatcher of starknet::Store::<Imodel_with_simple_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_simple_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_simple_arraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arraySafeDispatcher>) -> Imodel_with_simple_arraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_simple_arraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_simple_arraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_simple_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_simple_arraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arraySafeDispatcher>>) -> Imodel_with_simple_arraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_simple_arraySafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_byte_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayDispatcher of starknet::Store::<Imodel_with_byte_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_byte_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arrayDispatcher> {
    type SubPointersType = Imodel_with_byte_arrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arrayDispatcher>) -> Imodel_with_byte_arrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_byte_arrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_byte_arrayDispatcher> {
    type SubPointersType = Imodel_with_byte_arrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arrayDispatcher>>) -> Imodel_with_byte_arrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arrayDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_byte_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayLibraryDispatcher of starknet::Store::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_byte_arrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arrayLibraryDispatcher>) -> Imodel_with_byte_arrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_byte_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_byte_arrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arrayLibraryDispatcher>>) -> Imodel_with_byte_arrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arrayLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_byte_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_byte_arraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arraySafeLibraryDispatcher>) -> Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_byte_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arraySafeLibraryDispatcher>>) -> Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_byte_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeDispatcher of starknet::Store::<Imodel_with_byte_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_byte_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_byte_arraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arraySafeDispatcher>) -> Imodel_with_byte_arraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_byte_arraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_byte_arraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_byte_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_byte_arraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arraySafeDispatcher>>) -> Imodel_with_byte_arraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_byte_arraySafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_complex_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayDispatcher of starknet::Store::<Imodel_with_complex_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arrayDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_complex_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arrayDispatcher> {
    type SubPointersType = Imodel_with_complex_arrayDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arrayDispatcher>) -> Imodel_with_complex_arrayDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arrayDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_complex_arrayDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_complex_arrayDispatcher> {
    type SubPointersType = Imodel_with_complex_arrayDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arrayDispatcher>>) -> Imodel_with_complex_arrayDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arrayDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_complex_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayLibraryDispatcher of starknet::Store::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arrayLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_complex_arrayLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arrayLibraryDispatcher>) -> Imodel_with_complex_arrayLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arrayLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_complex_arrayLibraryDispatcher> {
    type SubPointersType = Imodel_with_complex_arrayLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arrayLibraryDispatcher>>) -> Imodel_with_complex_arrayLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arrayLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_complex_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_complex_arraySafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arraySafeLibraryDispatcher>) -> Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_complex_arraySafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arraySafeLibraryDispatcher>>) -> Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_complex_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeDispatcher of starknet::Store::<Imodel_with_complex_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arraySafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_complex_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_complex_arraySafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arraySafeDispatcher>) -> Imodel_with_complex_arraySafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_complex_arraySafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_complex_arraySafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_complex_arraySafeDispatcher> {
    type SubPointersType = Imodel_with_complex_arraySafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arraySafeDispatcher>>) -> Imodel_with_complex_arraySafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_complex_arraySafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tupleDispatcherCopy of core::traits::Copy::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherDrop of core::traits::Drop::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherSerde of core::serde::Serde::<Imodel_with_tupleDispatcher> {
    fn serialize(self: @Imodel_with_tupleDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleDispatcher> {
        core::option::Option::Some(Imodel_with_tupleDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleDispatcher of starknet::Store::<Imodel_with_tupleDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tupleDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tupleDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleDispatcher> {
    type SubPointersType = Imodel_with_tupleDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleDispatcher>) -> Imodel_with_tupleDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tupleDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_tupleDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tupleDispatcher> {
    type SubPointersType = Imodel_with_tupleDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleDispatcher>>) -> Imodel_with_tupleDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tupleLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleLibraryDispatcher of starknet::Store::<Imodel_with_tupleLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tupleLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tupleLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleLibraryDispatcher> {
    type SubPointersType = Imodel_with_tupleLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleLibraryDispatcher>) -> Imodel_with_tupleLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tupleLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_tupleLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tupleLibraryDispatcher> {
    type SubPointersType = Imodel_with_tupleLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleLibraryDispatcher>>) -> Imodel_with_tupleLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tupleSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeLibraryDispatcher of starknet::Store::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tupleSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_tupleSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleSafeLibraryDispatcher>) -> Imodel_with_tupleSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tupleSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tupleSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_tupleSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleSafeLibraryDispatcher>>) -> Imodel_with_tupleSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tupleSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeDispatcher of starknet::Store::<Imodel_with_tupleSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tupleSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tupleSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleSafeDispatcher> {
    type SubPointersType = Imodel_with_tupleSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleSafeDispatcher>) -> Imodel_with_tupleSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tupleSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_tupleSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tupleSafeDispatcher> {
    type SubPointersType = Imodel_with_tupleSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleSafeDispatcher>>) -> Imodel_with_tupleSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tupleSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesDispatcher>) -> Imodel_with_tuple_no_primitivesDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tuple_no_primitivesDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesDispatcher>>) -> Imodel_with_tuple_no_primitivesDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesLibraryDispatcher>) -> Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesLibraryDispatcher>>) -> Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>) -> Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>>) -> Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesSafeDispatcher>) -> Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    type SubPointersType = Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesSafeDispatcher>>) -> Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_multiple_versionsDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcherSubPointers>;
impl Ibad_model_multiple_versionsDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcherSubPointers>;
impl Ibad_model_multiple_versionsDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcherSubPointersMut>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcherSubPointersMut>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcherSubPointers>;
impl Ibad_model_no_version_valueDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcherSubPointers>;
impl Ibad_model_no_version_valueDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcherSubPointersMut>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcherSubPointers>;
impl Ibad_model_unexpected_argDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcherSubPointers>;
impl Ibad_model_unexpected_argDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcherSubPointersMut>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcherSubPointers>;
impl Ibad_model_not_supported_versionDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcherSubPointers>;
impl Ibad_model_not_supported_versionDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcherSubPointersMut>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcherSubPointersMut>;
impl Imodelv_0DispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0DispatcherSubPointers>;
impl Imodelv_0DispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0DispatcherSubPointers>;
impl Imodelv_0DispatcherSubPointersMutDrop of core::traits::Drop::<Imodelv_0DispatcherSubPointersMut>;
impl Imodelv_0DispatcherSubPointersMutCopy of core::traits::Copy::<Imodelv_0DispatcherSubPointersMut>;
impl Imodelv_0LibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0LibraryDispatcherSubPointers>;
impl Imodelv_0LibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0LibraryDispatcherSubPointers>;
impl Imodelv_0LibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodelv_0LibraryDispatcherSubPointersMut>;
impl Imodelv_0LibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodelv_0LibraryDispatcherSubPointersMut>;
impl Imodelv_0SafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcherSubPointers>;
impl Imodelv_0SafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcherSubPointers>;
impl Imodelv_0SafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcherSubPointersMut>;
impl Imodelv_0SafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcherSubPointersMut>;
impl Imodelv_0SafeDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0SafeDispatcherSubPointers>;
impl Imodelv_0SafeDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0SafeDispatcherSubPointers>;
impl Imodelv_0SafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodelv_0SafeDispatcherSubPointersMut>;
impl Imodelv_0SafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodelv_0SafeDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcherSubPointers>;
impl Imodel_with_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcherSubPointers>;
impl Imodel_with_string_namespaceDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcherSubPointersMut>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcherSubPointersMut>;
impl IpositionDispatcherSubPointersDrop of core::traits::Drop::<IpositionDispatcherSubPointers>;
impl IpositionDispatcherSubPointersCopy of core::traits::Copy::<IpositionDispatcherSubPointers>;
impl IpositionDispatcherSubPointersMutDrop of core::traits::Drop::<IpositionDispatcherSubPointersMut>;
impl IpositionDispatcherSubPointersMutCopy of core::traits::Copy::<IpositionDispatcherSubPointersMut>;
impl IpositionLibraryDispatcherSubPointersDrop of core::traits::Drop::<IpositionLibraryDispatcherSubPointers>;
impl IpositionLibraryDispatcherSubPointersCopy of core::traits::Copy::<IpositionLibraryDispatcherSubPointers>;
impl IpositionLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IpositionLibraryDispatcherSubPointersMut>;
impl IpositionLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IpositionLibraryDispatcherSubPointersMut>;
impl IpositionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IpositionSafeLibraryDispatcherSubPointers>;
impl IpositionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IpositionSafeLibraryDispatcherSubPointers>;
impl IpositionSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IpositionSafeLibraryDispatcherSubPointersMut>;
impl IpositionSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IpositionSafeLibraryDispatcherSubPointersMut>;
impl IpositionSafeDispatcherSubPointersDrop of core::traits::Drop::<IpositionSafeDispatcherSubPointers>;
impl IpositionSafeDispatcherSubPointersCopy of core::traits::Copy::<IpositionSafeDispatcherSubPointers>;
impl IpositionSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IpositionSafeDispatcherSubPointersMut>;
impl IpositionSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IpositionSafeDispatcherSubPointersMut>;
impl IrolesDispatcherSubPointersDrop of core::traits::Drop::<IrolesDispatcherSubPointers>;
impl IrolesDispatcherSubPointersCopy of core::traits::Copy::<IrolesDispatcherSubPointers>;
impl IrolesDispatcherSubPointersMutDrop of core::traits::Drop::<IrolesDispatcherSubPointersMut>;
impl IrolesDispatcherSubPointersMutCopy of core::traits::Copy::<IrolesDispatcherSubPointersMut>;
impl IrolesLibraryDispatcherSubPointersDrop of core::traits::Drop::<IrolesLibraryDispatcherSubPointers>;
impl IrolesLibraryDispatcherSubPointersCopy of core::traits::Copy::<IrolesLibraryDispatcherSubPointers>;
impl IrolesLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IrolesLibraryDispatcherSubPointersMut>;
impl IrolesLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IrolesLibraryDispatcherSubPointersMut>;
impl IrolesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IrolesSafeLibraryDispatcherSubPointers>;
impl IrolesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IrolesSafeLibraryDispatcherSubPointers>;
impl IrolesSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IrolesSafeLibraryDispatcherSubPointersMut>;
impl IrolesSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IrolesSafeLibraryDispatcherSubPointersMut>;
impl IrolesSafeDispatcherSubPointersDrop of core::traits::Drop::<IrolesSafeDispatcherSubPointers>;
impl IrolesSafeDispatcherSubPointersCopy of core::traits::Copy::<IrolesSafeDispatcherSubPointers>;
impl IrolesSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IrolesSafeDispatcherSubPointersMut>;
impl IrolesSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IrolesSafeDispatcherSubPointersMut>;
impl Ionly_key_modelDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelDispatcherSubPointers>;
impl Ionly_key_modelDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelDispatcherSubPointers>;
impl Ionly_key_modelDispatcherSubPointersMutDrop of core::traits::Drop::<Ionly_key_modelDispatcherSubPointersMut>;
impl Ionly_key_modelDispatcherSubPointersMutCopy of core::traits::Copy::<Ionly_key_modelDispatcherSubPointersMut>;
impl Ionly_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcherSubPointers>;
impl Ionly_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcherSubPointers>;
impl Ionly_key_modelLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcherSubPointersMut>;
impl Ionly_key_modelLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcherSubPointersMut>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcherSubPointers>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcherSubPointers>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcherSubPointersMut>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcherSubPointersMut>;
impl Ionly_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcherSubPointers>;
impl Ionly_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcherSubPointers>;
impl Ionly_key_modelSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcherSubPointersMut>;
impl Ionly_key_modelSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcherSubPointersMut>;
impl Iu_256_key_modelDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelDispatcherSubPointers>;
impl Iu_256_key_modelDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelDispatcherSubPointers>;
impl Iu_256_key_modelDispatcherSubPointersMutDrop of core::traits::Drop::<Iu_256_key_modelDispatcherSubPointersMut>;
impl Iu_256_key_modelDispatcherSubPointersMutCopy of core::traits::Copy::<Iu_256_key_modelDispatcherSubPointersMut>;
impl Iu_256_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcherSubPointers>;
impl Iu_256_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcherSubPointers>;
impl Iu_256_key_modelLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcherSubPointersMut>;
impl Iu_256_key_modelLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcherSubPointersMut>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcherSubPointersMut>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcherSubPointersMut>;
impl Iu_256_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcherSubPointers>;
impl Iu_256_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcherSubPointers>;
impl Iu_256_key_modelSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcherSubPointersMut>;
impl Iu_256_key_modelSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcherSubPointersMut>;
impl IplayerDispatcherSubPointersDrop of core::traits::Drop::<IplayerDispatcherSubPointers>;
impl IplayerDispatcherSubPointersCopy of core::traits::Copy::<IplayerDispatcherSubPointers>;
impl IplayerDispatcherSubPointersMutDrop of core::traits::Drop::<IplayerDispatcherSubPointersMut>;
impl IplayerDispatcherSubPointersMutCopy of core::traits::Copy::<IplayerDispatcherSubPointersMut>;
impl IplayerLibraryDispatcherSubPointersDrop of core::traits::Drop::<IplayerLibraryDispatcherSubPointers>;
impl IplayerLibraryDispatcherSubPointersCopy of core::traits::Copy::<IplayerLibraryDispatcherSubPointers>;
impl IplayerLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IplayerLibraryDispatcherSubPointersMut>;
impl IplayerLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IplayerLibraryDispatcherSubPointersMut>;
impl IplayerSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IplayerSafeLibraryDispatcherSubPointers>;
impl IplayerSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IplayerSafeLibraryDispatcherSubPointers>;
impl IplayerSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IplayerSafeLibraryDispatcherSubPointersMut>;
impl IplayerSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IplayerSafeLibraryDispatcherSubPointersMut>;
impl IplayerSafeDispatcherSubPointersDrop of core::traits::Drop::<IplayerSafeDispatcherSubPointers>;
impl IplayerSafeDispatcherSubPointersCopy of core::traits::Copy::<IplayerSafeDispatcherSubPointers>;
impl IplayerSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IplayerSafeDispatcherSubPointersMut>;
impl IplayerSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IplayerSafeDispatcherSubPointersMut>;
impl Imodel_with_simple_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcherSubPointers>;
impl Imodel_with_simple_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcherSubPointers>;
impl Imodel_with_simple_arrayDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcherSubPointersMut>;
impl Imodel_with_simple_arrayDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcherSubPointersMut>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_byte_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcherSubPointers>;
impl Imodel_with_byte_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcherSubPointers>;
impl Imodel_with_byte_arrayDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcherSubPointersMut>;
impl Imodel_with_byte_arrayDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcherSubPointersMut>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_complex_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcherSubPointers>;
impl Imodel_with_complex_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcherSubPointers>;
impl Imodel_with_complex_arrayDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcherSubPointersMut>;
impl Imodel_with_complex_arrayDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcherSubPointersMut>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcherSubPointersMut>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcherSubPointersMut>;
impl Imodel_with_tupleDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleDispatcherSubPointers>;
impl Imodel_with_tupleDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleDispatcherSubPointers>;
impl Imodel_with_tupleDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tupleDispatcherSubPointersMut>;
impl Imodel_with_tupleDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tupleDispatcherSubPointersMut>;
impl Imodel_with_tupleLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcherSubPointers>;
impl Imodel_with_tupleLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcherSubPointers>;
impl Imodel_with_tupleLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcherSubPointersMut>;
impl Imodel_with_tupleLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcherSubPointersMut>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_tupleSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcherSubPointers>;
impl Imodel_with_tupleSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcherSubPointers>;
impl Imodel_with_tupleSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcherSubPointersMut>;
impl Imodel_with_tupleSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMutDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMutCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersMut>;

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> /tmp/plugin_test/model/src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> /tmp/plugin_test/model/src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> /tmp/plugin_test/model/src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> /tmp/plugin_test/model/src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> /tmp/plugin_test/model/src/lib.cairo:100:5
    id: u256
    ^^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^
