//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

impl BadModelMultipleAttrIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleAttr<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleAttr',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl BadModelMultipleVersionsIntrospect<> of dojo::database::introspect::Introspect<BadModelMultipleVersions<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelMultipleVersions',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelMultipleVersionsModel of dojo::model::Model<BadModelMultipleVersions> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelMultipleVersions {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelMultipleVersions>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelMultipleVersions>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
}

impl BadModelBadVersionTypeIntrospect<> of dojo::database::introspect::Introspect<BadModelBadVersionType<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelBadVersionType',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelBadVersionTypeModel of dojo::model::Model<BadModelBadVersionType> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelBadVersionType {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1257444965375069225632929782137899434201314657712945575000402601057577969467
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelBadVersionType>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelBadVersionType>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
}

impl BadModelNoVersionValueIntrospect<> of dojo::database::introspect::Introspect<BadModelNoVersionValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNoVersionValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelNoVersionValueModel of dojo::model::Model<BadModelNoVersionValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNoVersionValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3373097771824053354196231469173076752789704424742154674493295341772858104830
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNoVersionValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNoVersionValue>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
}

impl BadModelUnexpectedArgWithValueIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArgWithValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArgWithValue',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelUnexpectedArgWithValueModel of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArgWithValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3590405629214068034212593672218295377527112441964389853941077460616482660871
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
}

impl BadModelUnexpectedArgIntrospect<> of dojo::database::introspect::Introspect<BadModelUnexpectedArg<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelUnexpectedArg',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelUnexpectedArgModel of dojo::model::Model<BadModelUnexpectedArg> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelUnexpectedArg {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1096230073778795894347893795076822536130165745015118585791241737691598280119
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArg>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArg>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
}

impl BadModelNotSupportedVersionIntrospect<> of dojo::database::introspect::Introspect<BadModelNotSupportedVersion<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'BadModelNotSupportedVersion',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl BadModelNotSupportedVersionModel of dojo::model::Model<BadModelNotSupportedVersion> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> BadModelNotSupportedVersion {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2618259498257511987977711074037130039442899457131070784132500210658539158686
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNotSupportedVersion>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNotSupportedVersion>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
}

impl Modelv0Introspect<> of dojo::database::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl Modelv0Model of dojo::model::Model<Modelv0> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Modelv0 {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Modelv0>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Modelv0>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::database::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithShortStringNamespaceModel of dojo::model::Model<ModelWithShortStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithShortStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithShortStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespace>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        643350075018191729855964658181798951445581630505240307235771395728709379388
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithShortStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "my_namespace"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        1685136890688416384941629523783652800960468745356230625531475538826800548713
    }

    #[inline(always)]
    fn keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithShortStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_short_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::Imodel_with_short_string_namespace;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithShortStringNamespace>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithShortStringNamespace>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithShortStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithShortStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_short_string_namespaceImpl of Imodel_with_short_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
}

impl ModelWithStringNamespaceIntrospect<> of dojo::database::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithStringNamespaceModel of dojo::model::Model<ModelWithStringNamespace> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithStringNamespace {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespace>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2567055065785696374111447326195815858786390804996225951953791904194802101726
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "my_namespace"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        1685136890688416384941629523783652800960468745356230625531475538826800548713
    }

    #[inline(always)]
    fn keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithStringNamespace) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::Imodel_with_string_namespace;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithStringNamespace>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithStringNamespace>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_string_namespaceImpl of Imodel_with_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
}

impl PositionIntrospect<> of dojo::database::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::database::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl PositionModel of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2479520712854223096864276571913189358268637670027015185814050381675363770524
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Position>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Position>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
}

impl RolesIntrospect<> of dojo::database::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 387776731289756409274549987067854286905927440612427426920343953432870065647,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'role_ids',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl RolesModel of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        855657559905271410348750655782338503830053919297069309307754778237415879343
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Roles>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Roles>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
}

impl OnlyKeyModelIntrospect<> of dojo::database::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'OnlyKeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        185833973124429845784881936399707635120594083624714634478397191250435112638
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<OnlyKeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<OnlyKeyModel>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
}

impl U256KeyModelIntrospect<> of dojo::database::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'U256KeyModel',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<u256>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl U256KeyModelModel of dojo::model::Model<U256KeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> U256KeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        313949624866121544885414428820758126526635902180652023772135974434319323806
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<U256KeyModel>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<U256KeyModel>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
}

impl PlayerIntrospect<> of dojo::database::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::database::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        },
dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
impl PlayerModel of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3236595220905041720254406300307550499454912078227837571413280031443759061272
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Player>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Player>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
}

impl ModelWithSimpleArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithSimpleArrayModel of dojo::model::Model<ModelWithSimpleArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithSimpleArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3015573168128997707047545520976347917082964620628387533056114714397499472255
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithSimpleArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithSimpleArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
}

impl ModelWithByteArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithByteArrayModel of dojo::model::Model<ModelWithByteArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithByteArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1495813766814131974177657304275361143893541941399872042870855060582891570868
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithByteArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithByteArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
}

impl ModelWithComplexArrayIntrospect<> of dojo::database::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Array(
                array![
                dojo::database::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithComplexArrayModel of dojo::model::Model<ModelWithComplexArray> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithComplexArray {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        36330270687495804813979499325154873801411429162367231362587376627277795482
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithComplexArray>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithComplexArray>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
}

impl ModelWithTupleIntrospect<> of dojo::database::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<u16>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<u16>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithTupleModel of dojo::model::Model<ModelWithTuple> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTuple {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2968932965114787437968555813812827702683268243780347884633996291362924490633
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTuple>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTuple>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::database::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::database::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::database::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::database::utils::sum(sizes))
                
    }

    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Layout::Struct(
            array![
            dojo::database::introspect::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::database::introspect::Introspect::<u16>::layout()
                },
dojo::database::introspect::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::database::introspect::Layout::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::layout(),
dojo::database::introspect::Introspect::<Vec3>::layout(),
dojo::database::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::database::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::database::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::database::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::database::introspect::Introspect::<u16>::ty()
        },
dojo::database::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::database::introspect::Ty::Tuple(
            array![
            dojo::database::introspect::Introspect::<u8>::ty(),
dojo::database::introspect::Introspect::<Vec3>::ty(),
dojo::database::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
impl ModelWithTupleNoPrimitivesModel of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: dojo::database::introspect::Layout) -> ModelWithTupleNoPrimitives {
        let values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            keys,
            layout
        );

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        1303002480984182254910512996281734914702552284127358821084351389028444664680
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "dojo_plugin"
    }

    #[inline(always)]
    fn namespace_selector() -> felt252 {
        3437408695301308226171664635441698996501144546809569617702850025816833723775
    }

    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);core::serde::Serde::serialize(self.y, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::database::introspect::Layout {
        dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::database::introspect::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        let layout = Self::layout();

        match layout {
            dojo::database::introspect::Layout::Fixed(layout) => {
                let mut span_layout = layout;
                Option::Some(dojo::packing::calculate_packed_size(ref span_layout))
            },
            dojo::database::introspect::Layout::Struct(_) => Option::None,
            dojo::database::introspect::Layout::Array(_) => Option::None,
            dojo::database::introspect::Layout::Tuple(_) => Option::None,
            dojo::database::introspect::Layout::Enum(_) => Option::None,
            dojo::database::introspect::Layout::ByteArray => Option::None,
        }
    }
}

#[starknet::interface]
trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
        }

        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::name()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::version()
        }
        
        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace()
        }

        fn namespace_selector(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace_selector()
        }
        
        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::database::introspect::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
}

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> test_src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> test_src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> test_src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> test_src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: The model namespace 'MyNamespace' can only contain lower case characters (a-z) and underscore (_)
 --> test_src/lib.cairo:59:8
struct ModelWithBadNamespaceFormat {
       ^*************************^

error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> test_src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:23:1
#[dojo::model(version)]
^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:30:1
#[dojo::model(my_arg: 1)]
^***********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:37:1
#[dojo::model(my_arg)]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:1
#[dojo::model(version: 2)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:51:1
#[dojo::model(version: 0)]
^************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:65:1
#[dojo::model(namespace: 'my_namespace')]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:72:1
#[dojo::model(namespace: "my_namespace")]
^***************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:79:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:86:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:91:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:97:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:103:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:115:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:123:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:139:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^

error: Unsupported attribute.
 --> test_src/lib.cairo:147:1
#[dojo::model]
^************^
