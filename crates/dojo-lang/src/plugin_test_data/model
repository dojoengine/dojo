//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}

#[dojo::model]
type OtherPlayer = Player;

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}

#[dojo::model]
type OtherPlayer = Player;

impl BadModelMultipleVersionsModel of dojo::model::Model<BadModelMultipleVersions> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelMultipleVersions {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelMultipleVersions"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelMultipleVersions) -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version(self: @BadModelMultipleVersions) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelMultipleVersions) -> felt252 {
        selector!("BadModelMultipleVersions")
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelMultipleVersions) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelMultipleVersions) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelMultipleVersions")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelMultipleVersions"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
}

impl BadModelBadVersionTypeModel of dojo::model::Model<BadModelBadVersionType> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelBadVersionType {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelBadVersionType"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelBadVersionType) -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn version(self: @BadModelBadVersionType) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelBadVersionType) -> felt252 {
        selector!("BadModelBadVersionType")
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelBadVersionType) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelBadVersionType) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelBadVersionType")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelBadVersionType"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
}

impl BadModelNoVersionValueModel of dojo::model::Model<BadModelNoVersionValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelNoVersionValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelNoVersionValue"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelNoVersionValue) -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version(self: @BadModelNoVersionValue) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelNoVersionValue) -> felt252 {
        selector!("BadModelNoVersionValue")
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelNoVersionValue) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelNoVersionValue) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelNoVersionValue")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelNoVersionValue"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
}

impl BadModelUnexpectedArgWithValueModel of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelUnexpectedArgWithValue {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelUnexpectedArgWithValue"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelUnexpectedArgWithValue) -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version(self: @BadModelUnexpectedArgWithValue) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        selector!("BadModelUnexpectedArgWithValue")
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelUnexpectedArgWithValue) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelUnexpectedArgWithValue) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelUnexpectedArgWithValue")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelUnexpectedArgWithValue"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
}

impl BadModelUnexpectedArgModel of dojo::model::Model<BadModelUnexpectedArg> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelUnexpectedArg {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelUnexpectedArg"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelUnexpectedArg) -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version(self: @BadModelUnexpectedArg) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelUnexpectedArg) -> felt252 {
        selector!("BadModelUnexpectedArg")
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelUnexpectedArg) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelUnexpectedArg) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelUnexpectedArg")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelUnexpectedArg"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
}

impl BadModelNotSupportedVersionModel of dojo::model::Model<BadModelNotSupportedVersion> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> BadModelNotSupportedVersion {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("BadModelNotSupportedVersion"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @BadModelNotSupportedVersion) -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version(self: @BadModelNotSupportedVersion) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @BadModelNotSupportedVersion) -> felt252 {
        selector!("BadModelNotSupportedVersion")
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @BadModelNotSupportedVersion) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @BadModelNotSupportedVersion) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("BadModelNotSupportedVersion")
        }

        fn name(self: @ContractState) -> ByteArray {
            "BadModelNotSupportedVersion"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
}

impl Modelv0Model of dojo::model::Model<Modelv0> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Modelv0 {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Modelv0"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Modelv0) -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn version(self: @Modelv0) -> u8 {
        0
    }

    #[inline(always)]
    fn selector(self: @Modelv0) -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Modelv0) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Modelv0>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Modelv0) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            "Modelv0"
        }

        fn name(self: @ContractState) -> ByteArray {
            "Modelv0"
        }

        fn version(self: @ContractState) -> u8 {
            0
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Modelv0>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Modelv0>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
}

impl PositionModel of dojo::model::Model<Position> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Position {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Position"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Position) -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn version(self: @Position) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Position) -> felt252 {
        selector!("Position")
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Position) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Position) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
mod position {
    use super::Position;
    use super::Iposition;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Position")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Position"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Position>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Position>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
}

impl RolesModel of dojo::model::Model<Roles> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Roles {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Roles"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Roles) -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn version(self: @Roles) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Roles) -> felt252 {
        selector!("Roles")
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Roles) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Roles) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
mod roles {
    use super::Roles;
    use super::Iroles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Roles")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Roles"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
}

impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> OnlyKeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("OnlyKeyModel"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @OnlyKeyModel) -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn version(self: @OnlyKeyModel) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @OnlyKeyModel) -> felt252 {
        selector!("OnlyKeyModel")
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @OnlyKeyModel) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @OnlyKeyModel) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("OnlyKeyModel")
        }

        fn name(self: @ContractState) -> ByteArray {
            "OnlyKeyModel"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
}

impl U256KeyModelModel of dojo::model::Model<U256KeyModel> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> U256KeyModel {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("U256KeyModel"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @U256KeyModel) -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn version(self: @U256KeyModel) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @U256KeyModel) -> felt252 {
        selector!("U256KeyModel")
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @U256KeyModel) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @U256KeyModel) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("U256KeyModel")
        }

        fn name(self: @ContractState) -> ByteArray {
            "U256KeyModel"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
}

impl PlayerModel of dojo::model::Model<Player> {
    fn entity(world: dojo::world::IWorldDispatcher, keys: Span<felt252>, layout: Span<u8>) -> Player {
        let values = dojo::world::IWorldDispatcherTrait::entity(world, selector!("Player"), keys, layout);

        // TODO: Generate method to deserialize from keys / values directly to avoid
        // serializing to intermediate array.
        let mut serialized = core::array::ArrayTrait::new();
        core::array::serialize_array_helper(keys, ref serialized);
        core::array::serialize_array_helper(values, ref serialized);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    #[inline(always)]
    fn name(self: @Player) -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn version(self: @Player) -> u8 {
        1
    }

    #[inline(always)]
    fn selector(self: @Player) -> felt252 {
        selector!("Player")
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Player) -> Span<u8> {
        let mut layout = core::array::ArrayTrait::new();
        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
        core::array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Player) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}

#[starknet::interface]
trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
mod player {
    use super::Player;
    use super::Iplayer;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn selector(self: @ContractState) -> felt252 {
            selector!("Player")
        }

        fn name(self: @ContractState) -> ByteArray {
            "Player"
        }

        fn version(self: @ContractState) -> u8 {
            1
        }

        fn unpacked_size(self: @ContractState) -> usize {
            dojo::database::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> usize {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Player>::layout(ref layout);
            let mut layout_span = layout.span();
            dojo::packing::calculate_packed_size(ref layout_span)
        }

        fn layout(self: @ContractState) -> Span<u8> {
            let mut layout = core::array::ArrayTrait::new();
            dojo::database::introspect::Introspect::<Player>::layout(ref layout);
            core::array::ArrayTrait::span(@layout)
        }

        fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
            dojo::database::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
}

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> test_src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> test_src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> test_src/lib.cairo:16:1
#[dojo::model(version: hello)]
^****************************^

error: Unexpected argument 'version' for dojo::model
 --> test_src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> test_src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> test_src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:66:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:71:8
struct OnlyKeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:77:8
struct U256KeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> test_src/lib.cairo:77:8
struct U256KeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelMultipleVersions]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelBadVersionType]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNoVersionValue]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArgWithValue]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArg]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNotSupportedVersion]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Modelv0]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:72:1
#[starknet::contract]
^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelMultipleVersions]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelMultipleVersions]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelMultipleVersions]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelBadVersionType]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelBadVersionType]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelBadVersionType]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNoVersionValue]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNoVersionValue]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNoVersionValue]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArgWithValue]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArgWithValue]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArgWithValue]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArg]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArg]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelUnexpectedArg]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNotSupportedVersion]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNotSupportedVersion]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[BadModelNotSupportedVersion]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Modelv0]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Modelv0]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Modelv0]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:116:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:77:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:80:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:116:5
    #[abi(embed_v0)]
    ^**************^
