//! > Test expansion of the dojo::model.

//! > test_runner_name
test_expand_plugin

//! > test_id
model

//! > cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}

//! > expanded_cairo_code
#[dojo::model(version: 0)]
#[dojo::model(version: 0)]
struct BadModelMultipleAttr {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0, version: 0)]
struct BadModelMultipleVersions {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: hello)]
struct BadModelBadVersionType {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version)]
struct BadModelNoVersionValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg: 1)]
struct BadModelUnexpectedArgWithValue {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(my_arg)]
struct BadModelUnexpectedArg {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 2)]
struct BadModelNotSupportedVersion {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(version: 0)]
struct Modelv0 {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'MyNamespace')]
struct ModelWithBadNamespaceFormat {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: 'my_namespace')]
struct ModelWithShortStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model(namespace: "my_namespace")]
struct ModelWithStringNamespace {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

#[dojo::model]
struct Roles {
    role_ids: Array<u8>
}

#[dojo::model]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[dojo::model]
struct U256KeyModel {
    #[key]
    id: u256
}

#[dojo::model]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,
    name: felt252,
}

#[dojo::model]
type OtherPlayer = Player;

#[dojo::model]
struct ModelWithSimpleArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<u8>
}

#[dojo::model]
struct ModelWithByteArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: ByteArray
}

#[dojo::model]
struct ModelWithComplexArray {
    #[key]
    player: ContractAddress,
    x: u16,
    y: Array<Vec3>
}

#[dojo::model]
struct ModelWithTuple {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, u16, u32)
}

#[dojo::model]
struct ModelWithTupleNoPrimitives {
    #[key]
    player: ContractAddress,
    x: u16,
    y: (u8, Vec3, u32)
}
impl BadModelMultipleAttrIntrospect<> of dojo::model::introspect::Introspect<BadModelMultipleAttr<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelMultipleAttr',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}

impl BadModelMultipleVersionsIntrospect<> of dojo::model::introspect::Introspect<BadModelMultipleVersions<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelMultipleVersions',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelMultipleVersionsEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelMultipleVersionsEntityStoreImpl of BadModelMultipleVersionsEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity {
        BadModelMultipleVersionsModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelMultipleVersionsEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelMultipleVersions::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelMultipleVersionsStoreImpl of BadModelMultipleVersionsStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelMultipleVersions {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelMultipleVersions>::is_none(@entity) {
            panic!(
                "Model `BadModelMultipleVersions`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelMultipleVersions>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelMultipleVersions>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelMultipleVersions>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelMultipleVersions::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelMultipleVersionsModelEntityImpl of dojo::model::ModelEntity<BadModelMultipleVersionsEntity> {
    fn id(self: @BadModelMultipleVersionsEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelMultipleVersionsEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelMultipleVersionsEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelMultipleVersionsEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelMultipleVersionsEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelMultipleVersionsEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelMultipleVersionsEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
    }

    fn delete(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelMultipleVersions>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelMultipleVersions>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelMultipleVersions>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelMultipleVersionsEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelMultipleVersions>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelMultipleVersions>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelMultipleVersionsModelImpl of dojo::model::Model<BadModelMultipleVersions> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelMultipleVersions {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelMultipleVersionsStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelMultipleVersions,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelMultipleVersions"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "BadModelMultipleVersions"
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelMultipleVersions) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3538888628466873673221842373412072042558277047191927145880480325050722136660
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelMultipleVersions) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelMultipleVersions) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelMultipleVersions>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelMultipleVersions) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_multiple_versions<T> {
    fn ensure_abi(self: @T, model: BadModelMultipleVersions);
}

#[starknet::contract]
pub mod bad_model_multiple_versions {
    use super::BadModelMultipleVersions;
    use super::Ibad_model_multiple_versions;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelMultipleVersions>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelMultipleVersions>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelMultipleVersions>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelMultipleVersions>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelMultipleVersions>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelMultipleVersions>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelMultipleVersions>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelMultipleVersions>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelMultipleVersions>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_multiple_versionsImpl of Ibad_model_multiple_versions<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelMultipleVersions) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_multiple_versionsImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelMultipleVersions>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_multiple_versionsImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_multiple_versionsImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelBadVersionTypeIntrospect<> of dojo::model::introspect::Introspect<BadModelBadVersionType<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelBadVersionType',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelBadVersionTypeEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelBadVersionTypeEntityStoreImpl of BadModelBadVersionTypeEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity {
        BadModelBadVersionTypeModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelBadVersionTypeEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelBadVersionType::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelBadVersionTypeStoreImpl of BadModelBadVersionTypeStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelBadVersionType {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelBadVersionType>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelBadVersionType>::is_none(@entity) {
            panic!(
                "Model `BadModelBadVersionType`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelBadVersionType>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelBadVersionType>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelBadVersionType>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelBadVersionType::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelBadVersionTypeModelEntityImpl of dojo::model::ModelEntity<BadModelBadVersionTypeEntity> {
    fn id(self: @BadModelBadVersionTypeEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelBadVersionTypeEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelBadVersionTypeEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelBadVersionTypeEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelBadVersionTypeEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelBadVersionTypeEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelBadVersionTypeEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
    }

    fn delete(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelBadVersionType>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelBadVersionType>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelBadVersionType>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelBadVersionType>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelBadVersionTypeEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelBadVersionType>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelBadVersionType>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelBadVersionTypeModelImpl of dojo::model::Model<BadModelBadVersionType> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelBadVersionType {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelBadVersionTypeStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelBadVersionType,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelBadVersionType"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelBadVersionType"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3424346430891629531332762252537876298286978002978132542474104837759156545171
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelBadVersionType) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        760683829940564015458541272487101565210915690045377810379189532484191344547
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelBadVersionType) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelBadVersionType) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelBadVersionType>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelBadVersionType) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_bad_version_type<T> {
    fn ensure_abi(self: @T, model: BadModelBadVersionType);
}

#[starknet::contract]
pub mod bad_model_bad_version_type {
    use super::BadModelBadVersionType;
    use super::Ibad_model_bad_version_type;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelBadVersionType>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelBadVersionType>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelBadVersionType>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelBadVersionType>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelBadVersionType>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelBadVersionType>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelBadVersionType>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelBadVersionType>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelBadVersionType>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_bad_version_typeImpl of Ibad_model_bad_version_type<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelBadVersionType) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_bad_version_typeImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelBadVersionType>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_bad_version_typeImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_bad_version_typeImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelNoVersionValueIntrospect<> of dojo::model::introspect::Introspect<BadModelNoVersionValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelNoVersionValue',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNoVersionValueEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelNoVersionValueEntityStoreImpl of BadModelNoVersionValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity {
        BadModelNoVersionValueModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelNoVersionValueEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNoVersionValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelNoVersionValueStoreImpl of BadModelNoVersionValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNoVersionValue {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNoVersionValue>::is_none(@entity) {
            panic!(
                "Model `BadModelNoVersionValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNoVersionValue>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNoVersionValue>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelNoVersionValue>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNoVersionValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelNoVersionValueModelEntityImpl of dojo::model::ModelEntity<BadModelNoVersionValueEntity> {
    fn id(self: @BadModelNoVersionValueEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelNoVersionValueEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelNoVersionValueEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelNoVersionValueEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelNoVersionValueEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelNoVersionValueEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelNoVersionValueEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
    }

    fn delete(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelNoVersionValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNoVersionValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelNoVersionValue>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNoVersionValueEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNoVersionValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelNoVersionValue>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelNoVersionValueModelImpl of dojo::model::Model<BadModelNoVersionValue> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelNoVersionValue {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelNoVersionValueStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNoVersionValue,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNoVersionValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelNoVersionValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3137507464979648719446085887369604472442296862296217793557428940425307809922
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNoVersionValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2459365230136118590954025890011480023818926626380754992635699340900694864996
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelNoVersionValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNoVersionValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelNoVersionValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNoVersionValue) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_no_version_value<T> {
    fn ensure_abi(self: @T, model: BadModelNoVersionValue);
}

#[starknet::contract]
pub mod bad_model_no_version_value {
    use super::BadModelNoVersionValue;
    use super::Ibad_model_no_version_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNoVersionValue>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNoVersionValue>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNoVersionValue>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNoVersionValue>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNoVersionValue>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelNoVersionValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNoVersionValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelNoVersionValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelNoVersionValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_no_version_valueImpl of Ibad_model_no_version_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNoVersionValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_no_version_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNoVersionValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_no_version_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_no_version_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelUnexpectedArgWithValueIntrospect<> of dojo::model::introspect::Introspect<BadModelUnexpectedArgWithValue<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelUnexpectedArgWithValue',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgWithValueEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelUnexpectedArgWithValueEntityStoreImpl of BadModelUnexpectedArgWithValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity {
        BadModelUnexpectedArgWithValueModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelUnexpectedArgWithValueEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArgWithValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelUnexpectedArgWithValueStoreImpl of BadModelUnexpectedArgWithValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValue {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArgWithValue`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArgWithValue>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArgWithValue>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelUnexpectedArgWithValue>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArgWithValue::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelUnexpectedArgWithValueModelEntityImpl of dojo::model::ModelEntity<BadModelUnexpectedArgWithValueEntity> {
    fn id(self: @BadModelUnexpectedArgWithValueEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelUnexpectedArgWithValueEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValueEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelUnexpectedArgWithValueEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelUnexpectedArgWithValueEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelUnexpectedArgWithValueEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelUnexpectedArgWithValueEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
    }

    fn delete(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgWithValueEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelUnexpectedArgWithValueModelImpl of dojo::model::Model<BadModelUnexpectedArgWithValue> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelUnexpectedArgWithValue {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelUnexpectedArgWithValueStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgWithValue,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelUnexpectedArgWithValue"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3162902274274075293574414479899149167035238805798288683939511839395372839584
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3586339245084542986020591057627093254376225984628310828088084183494435682971
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArgWithValue) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArgWithValue) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArgWithValue) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_unexpected_arg_with_value<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArgWithValue);
}

#[starknet::contract]
pub mod bad_model_unexpected_arg_with_value {
    use super::BadModelUnexpectedArgWithValue;
    use super::Ibad_model_unexpected_arg_with_value;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArgWithValue>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelUnexpectedArgWithValue>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArgWithValue>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_arg_with_valueImpl of Ibad_model_unexpected_arg_with_value<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArgWithValue) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_arg_with_valueImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_arg_with_valueImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelUnexpectedArgIntrospect<> of dojo::model::introspect::Introspect<BadModelUnexpectedArg<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelUnexpectedArg',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelUnexpectedArgEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelUnexpectedArgEntityStoreImpl of BadModelUnexpectedArgEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity {
        BadModelUnexpectedArgModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelUnexpectedArgEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArg::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelUnexpectedArgStoreImpl of BadModelUnexpectedArgStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArg {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelUnexpectedArg>::is_none(@entity) {
            panic!(
                "Model `BadModelUnexpectedArg`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelUnexpectedArg>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelUnexpectedArg>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelUnexpectedArg>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelUnexpectedArg::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelUnexpectedArgModelEntityImpl of dojo::model::ModelEntity<BadModelUnexpectedArgEntity> {
    fn id(self: @BadModelUnexpectedArgEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelUnexpectedArgEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelUnexpectedArgEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelUnexpectedArgEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelUnexpectedArgEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelUnexpectedArgEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelUnexpectedArgEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
    }

    fn delete(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelUnexpectedArg>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArg>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArg>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArgEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelUnexpectedArg>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelUnexpectedArg>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelUnexpectedArgModelImpl of dojo::model::Model<BadModelUnexpectedArg> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelUnexpectedArg {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelUnexpectedArgStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelUnexpectedArg,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelUnexpectedArg"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2062327100205703339988289387876316143748074129748784084948535166252334131324
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelUnexpectedArg) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        246403407829267991441535935236143476032296881039254363860883767387993960270
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelUnexpectedArg) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelUnexpectedArg) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelUnexpectedArg) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_unexpected_arg<T> {
    fn ensure_abi(self: @T, model: BadModelUnexpectedArg);
}

#[starknet::contract]
pub mod bad_model_unexpected_arg {
    use super::BadModelUnexpectedArg;
    use super::Ibad_model_unexpected_arg;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelUnexpectedArg>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelUnexpectedArg>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelUnexpectedArg>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelUnexpectedArg>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelUnexpectedArg>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelUnexpectedArg>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelUnexpectedArg>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelUnexpectedArg>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_unexpected_argImpl of Ibad_model_unexpected_arg<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelUnexpectedArg) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_unexpected_argImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelUnexpectedArg>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_unexpected_argImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_unexpected_argImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl BadModelNotSupportedVersionIntrospect<> of dojo::model::introspect::Introspect<BadModelNotSupportedVersion<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'BadModelNotSupportedVersion',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct BadModelNotSupportedVersionEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl BadModelNotSupportedVersionEntityStoreImpl of BadModelNotSupportedVersionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity {
        BadModelNotSupportedVersionModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<BadModelNotSupportedVersionEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNotSupportedVersion::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl BadModelNotSupportedVersionStoreImpl of BadModelNotSupportedVersionStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNotSupportedVersion {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref serialized);

        if core::option::OptionTrait::<BadModelNotSupportedVersion>::is_none(@entity) {
            panic!(
                "Model `BadModelNotSupportedVersion`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<BadModelNotSupportedVersion>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<BadModelNotSupportedVersion>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<BadModelNotSupportedVersion>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `BadModelNotSupportedVersion::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl BadModelNotSupportedVersionModelEntityImpl of dojo::model::ModelEntity<BadModelNotSupportedVersionEntity> {
    fn id(self: @BadModelNotSupportedVersionEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @BadModelNotSupportedVersionEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> BadModelNotSupportedVersionEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<BadModelNotSupportedVersionEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<BadModelNotSupportedVersionEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `BadModelNotSupportedVersionEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<BadModelNotSupportedVersionEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
    }

    fn delete(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNotSupportedVersion>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNotSupportedVersionEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<BadModelNotSupportedVersion>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<BadModelNotSupportedVersion>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl BadModelNotSupportedVersionModelImpl of dojo::model::Model<BadModelNotSupportedVersion> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> BadModelNotSupportedVersion {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        BadModelNotSupportedVersionStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @BadModelNotSupportedVersion,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-BadModelNotSupportedVersion"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2399868061331388591523307843619168972583102717296603562171130686072940081207
    }

    #[inline(always)]
    fn instance_selector(self: @BadModelNotSupportedVersion) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1812257929012908024237871796629728977392496349235879470060252299886369485820
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @BadModelNotSupportedVersion) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @BadModelNotSupportedVersion) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @BadModelNotSupportedVersion) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ibad_model_not_supported_version<T> {
    fn ensure_abi(self: @T, model: BadModelNotSupportedVersion);
}

#[starknet::contract]
pub mod bad_model_not_supported_version {
    use super::BadModelNotSupportedVersion;
    use super::Ibad_model_not_supported_version;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<BadModelNotSupportedVersion>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<BadModelNotSupportedVersion>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<BadModelNotSupportedVersion>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<BadModelNotSupportedVersion>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<BadModelNotSupportedVersion>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<BadModelNotSupportedVersion>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<BadModelNotSupportedVersion>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<BadModelNotSupportedVersion>::ty()
        }
    }

    #[abi(embed_v0)]
    impl bad_model_not_supported_versionImpl of Ibad_model_not_supported_version<ContractState>{
        fn ensure_abi(self: @ContractState, model: BadModelNotSupportedVersion) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__bad_model_not_supported_versionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<BadModelNotSupportedVersion>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    bad_model_not_supported_versionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__bad_model_not_supported_versionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl Modelv0Introspect<> of dojo::model::introspect::Introspect<Modelv0<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Modelv0',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct Modelv0Entity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl Modelv0EntityStoreImpl of Modelv0EntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity {
        Modelv0ModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<Modelv0Entity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Modelv0::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl Modelv0StoreImpl of Modelv0Store {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Modelv0 {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Modelv0>::deserialize(ref serialized);

        if core::option::OptionTrait::<Modelv0>::is_none(@entity) {
            panic!(
                "Model `Modelv0`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Modelv0>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Modelv0>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<Modelv0>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Modelv0::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Modelv0, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl Modelv0ModelEntityImpl of dojo::model::ModelEntity<Modelv0Entity> {
    fn id(self: @Modelv0Entity) -> felt252 {
        *self.__id
    }

    fn values(self: @Modelv0Entity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> Modelv0Entity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<Modelv0Entity>::deserialize(ref serialized);
        if core::option::OptionTrait::<Modelv0Entity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `Modelv0Entity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<Modelv0Entity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Modelv0>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Modelv0>::layout()
        );
    }

    fn delete(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Modelv0>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Modelv0>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Modelv0>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Modelv0>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Modelv0Entity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Modelv0>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Modelv0>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl Modelv0ModelImpl of dojo::model::Model<Modelv0> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Modelv0 {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        Modelv0Store::from_values(ref _keys, ref values)
    }

   fn set(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Modelv0,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Modelv0"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Modelv0"
    }

    #[inline(always)]
    fn version() -> u8 {
        0
    }

    #[inline(always)]
    fn selector() -> felt252 {
        "Modelv0"
    }

    #[inline(always)]
    fn instance_selector(self: @Modelv0) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2212879130471315306779111820244908968466545702031328551192231795237740448313
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @Modelv0) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Modelv0) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Modelv0>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Modelv0) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodelv_0<T> {
    fn ensure_abi(self: @T, model: Modelv0);
}

#[starknet::contract]
pub mod modelv_0 {
    use super::Modelv0;
    use super::Imodelv_0;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Modelv0>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Modelv0>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Modelv0>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Modelv0>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Modelv0>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Modelv0>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Modelv0>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Modelv0>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Modelv0>::ty()
        }
    }

    #[abi(embed_v0)]
    impl modelv_0Impl of Imodelv_0<ContractState>{
        fn ensure_abi(self: @ContractState, model: Modelv0) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__modelv_0Impl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Modelv0>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    modelv_0Impl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__modelv_0Impl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithBadNamespaceFormatIntrospect<> of dojo::model::introspect::Introspect<ModelWithBadNamespaceFormat<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithBadNamespaceFormat',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithBadNamespaceFormatEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithBadNamespaceFormatEntityStoreImpl of ModelWithBadNamespaceFormatEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity {
        ModelWithBadNamespaceFormatModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithBadNamespaceFormatEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithBadNamespaceFormat::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithBadNamespaceFormatStoreImpl of ModelWithBadNamespaceFormatStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithBadNamespaceFormat {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithBadNamespaceFormat>::is_none(@entity) {
            panic!(
                "Model `ModelWithBadNamespaceFormat`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithBadNamespaceFormat>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithBadNamespaceFormat>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithBadNamespaceFormat>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithBadNamespaceFormat::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithBadNamespaceFormatModelEntityImpl of dojo::model::ModelEntity<ModelWithBadNamespaceFormatEntity> {
    fn id(self: @ModelWithBadNamespaceFormatEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithBadNamespaceFormatEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithBadNamespaceFormatEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithBadNamespaceFormatEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithBadNamespaceFormatEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithBadNamespaceFormatEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithBadNamespaceFormatEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
    }

    fn delete(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithBadNamespaceFormat>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithBadNamespaceFormatEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithBadNamespaceFormat>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithBadNamespaceFormat>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithBadNamespaceFormatModelImpl of dojo::model::Model<ModelWithBadNamespaceFormat> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithBadNamespaceFormat {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithBadNamespaceFormatStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithBadNamespaceFormat,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithBadNamespaceFormat"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3059539413433693207383279334860020534329215374860715071558931541261069058621
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithBadNamespaceFormat) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        513559242384681567568052881519197161166285694153303371154270254637843894159
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithBadNamespaceFormat) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithBadNamespaceFormat) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithBadNamespaceFormat) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_bad_namespace_format<T> {
    fn ensure_abi(self: @T, model: ModelWithBadNamespaceFormat);
}

#[starknet::contract]
pub mod model_with_bad_namespace_format {
    use super::ModelWithBadNamespaceFormat;
    use super::Imodel_with_bad_namespace_format;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithBadNamespaceFormat>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithBadNamespaceFormat>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithBadNamespaceFormat>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_bad_namespace_formatImpl of Imodel_with_bad_namespace_format<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithBadNamespaceFormat) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_bad_namespace_formatImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithBadNamespaceFormat>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_bad_namespace_formatImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_bad_namespace_formatImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithShortStringNamespaceIntrospect<> of dojo::model::introspect::Introspect<ModelWithShortStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithShortStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithShortStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithShortStringNamespaceEntityStoreImpl of ModelWithShortStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity {
        ModelWithShortStringNamespaceModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithShortStringNamespaceEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithShortStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithShortStringNamespaceStoreImpl of ModelWithShortStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithShortStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithShortStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithShortStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithShortStringNamespace>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithShortStringNamespace>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithShortStringNamespace>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithShortStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithShortStringNamespaceModelEntityImpl of dojo::model::ModelEntity<ModelWithShortStringNamespaceEntity> {
    fn id(self: @ModelWithShortStringNamespaceEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithShortStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithShortStringNamespaceEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithShortStringNamespaceEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithShortStringNamespaceEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithShortStringNamespaceEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithShortStringNamespaceEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
    }

    fn delete(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithShortStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithShortStringNamespaceEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithShortStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithShortStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithShortStringNamespaceModelImpl of dojo::model::Model<ModelWithShortStringNamespace> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithShortStringNamespace {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithShortStringNamespaceStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithShortStringNamespace,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithShortStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        516169310422367104631924468147010406642920381144711483043394373786075028578
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithShortStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        4646597166239297873853881466258165424425132957303541470648153031188639878
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithShortStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithShortStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithShortStringNamespace) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_short_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithShortStringNamespace);
}

#[starknet::contract]
pub mod model_with_short_string_namespace {
    use super::ModelWithShortStringNamespace;
    use super::Imodel_with_short_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithShortStringNamespace>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithShortStringNamespace>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithShortStringNamespace>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithShortStringNamespace>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithShortStringNamespace>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithShortStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithShortStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithShortStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_short_string_namespaceImpl of Imodel_with_short_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithShortStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_short_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithShortStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_short_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_short_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithStringNamespaceIntrospect<> of dojo::model::introspect::Introspect<ModelWithStringNamespace<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithStringNamespace',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithStringNamespaceEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl ModelWithStringNamespaceEntityStoreImpl of ModelWithStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity {
        ModelWithStringNamespaceModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<ModelWithStringNamespaceEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithStringNamespaceStoreImpl of ModelWithStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithStringNamespace>::is_none(@entity) {
            panic!(
                "Model `ModelWithStringNamespace`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithStringNamespace>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<ModelWithStringNamespace>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<ModelWithStringNamespace>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `ModelWithStringNamespace::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl ModelWithStringNamespaceModelEntityImpl of dojo::model::ModelEntity<ModelWithStringNamespaceEntity> {
    fn id(self: @ModelWithStringNamespaceEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithStringNamespaceEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithStringNamespaceEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithStringNamespaceEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithStringNamespaceEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithStringNamespaceEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithStringNamespaceEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
    }

    fn delete(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithStringNamespace>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithStringNamespaceEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithStringNamespace>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithStringNamespace>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithStringNamespaceModelImpl of dojo::model::Model<ModelWithStringNamespace> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithStringNamespace {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithStringNamespaceStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithStringNamespace,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithStringNamespace"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithStringNamespace"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2244952983831849087562617629161882602941157493177409459461888999685738447838
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithStringNamespace) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        36187013840655350498900857372670392628596870210415176261336407419317644423
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithStringNamespace) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithStringNamespace) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithStringNamespace>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithStringNamespace) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_string_namespace<T> {
    fn ensure_abi(self: @T, model: ModelWithStringNamespace);
}

#[starknet::contract]
pub mod model_with_string_namespace {
    use super::ModelWithStringNamespace;
    use super::Imodel_with_string_namespace;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithStringNamespace>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithStringNamespace>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithStringNamespace>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithStringNamespace>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithStringNamespace>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithStringNamespace>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithStringNamespace>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithStringNamespace>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithStringNamespace>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_string_namespaceImpl of Imodel_with_string_namespace<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithStringNamespace) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_string_namespaceImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithStringNamespace>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_string_namespaceImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_string_namespaceImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl PositionIntrospect<> of dojo::model::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        dojo::model::introspect::Introspect::<Vec3>::size()
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 578691550836206188651404750433984985630363913126316857592149308417275000080,
                    layout: dojo::model::introspect::Introspect::<Vec3>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'v',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<Vec3>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PositionEntity {
    __id: felt252, // private field
    pub v: Vec3,

}

#[generate_trait]
pub impl PositionEntityStoreImpl of PositionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity {
        PositionModelEntityImpl::get(world, entity_id)
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3 {
        let mut values = dojo::model::ModelEntity::<PositionEntity>::get_member(
            world,
            entity_id,
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );
        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Position::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @PositionEntity, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl PositionStoreImpl of PositionStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Position {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Position>::deserialize(ref serialized);

        if core::option::OptionTrait::<Position>::is_none(@entity) {
            panic!(
                "Model `Position`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Position>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<Position>::get(world, serialized.span())
    }

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        let mut values = dojo::model::Model::<Position>::get_member(
            world,
            serialized.span(),
            578691550836206188651404750433984985630363913126316857592149308417275000080
        );

        let field_value = core::serde::Serde::<Vec3>::deserialize(ref values);

        if core::option::OptionTrait::<Vec3>::is_none(@field_value) {
            panic!(
                "Field `Position::v`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Vec3>::unwrap(field_value)
    }

    fn set_v(self: @Position, world: dojo::world::IWorldDispatcher, value: Vec3) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            578691550836206188651404750433984985630363913126316857592149308417275000080,
            serialized.span()
        );
    }
            
}

pub impl PositionModelEntityImpl of dojo::model::ModelEntity<PositionEntity> {
    fn id(self: @PositionEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @PositionEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> PositionEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<PositionEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<PositionEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `PositionEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<PositionEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Position>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Position>::layout()
        );
    }

    fn delete(self: @PositionEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Position>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Position>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Position>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Position>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @PositionEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Position>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Position>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl PositionModelImpl of dojo::model::Model<Position> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Position {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        PositionStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @Position,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @Position,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Position,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Position"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Position"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2583140722357655302813194934296353271867745884944715988664292532004552033294
    }

    #[inline(always)]
    fn instance_selector(self: @Position) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2899920299641094436341712346886623904698864491830316325765258522168980161362
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @Position) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Position>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Position) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iposition<T> {
    fn ensure_abi(self: @T, model: Position);
}

#[starknet::contract]
pub mod position {
    use super::Position;
    use super::Iposition;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Position>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Position>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Position>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Position>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Position>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Position>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Position>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Position>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Position>::ty()
        }
    }

    #[abi(embed_v0)]
    impl positionImpl of Iposition<ContractState>{
        fn ensure_abi(self: @ContractState, model: Position) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__positionImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Position>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    positionImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__positionImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl RolesIntrospect<> of dojo::model::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 387776731289756409274549987067854286905927440612427426920343953432870065647,
                    layout: dojo::model::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'role_ids',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct RolesEntity {
    __id: felt252, // private field
    pub role_ids: Array<u8>,

}

#[generate_trait]
pub impl RolesEntityStoreImpl of RolesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity {
        RolesModelEntityImpl::get(world, entity_id)
    }

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8> {
        let mut values = dojo::model::ModelEntity::<RolesEntity>::get_member(
            world,
            entity_id,
            387776731289756409274549987067854286905927440612427426920343953432870065647
        );
        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `Roles::role_ids`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_role_ids(self: @RolesEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            387776731289756409274549987067854286905927440612427426920343953432870065647,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl RolesStoreImpl of RolesStore {
    fn entity_id_from_keys() -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Roles {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Roles>::deserialize(ref serialized);

        if core::option::OptionTrait::<Roles>::is_none(@entity) {
            panic!(
                "Model `Roles`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Roles>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles {
        let mut serialized = core::array::ArrayTrait::new();
        

        dojo::model::Model::<Roles>::get(world, serialized.span())
    }

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, ) -> Array<u8> {
        let mut serialized = core::array::ArrayTrait::new();
        

        let mut values = dojo::model::Model::<Roles>::get_member(
            world,
            serialized.span(),
            387776731289756409274549987067854286905927440612427426920343953432870065647
        );

        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `Roles::role_ids`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_role_ids(self: @Roles, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            387776731289756409274549987067854286905927440612427426920343953432870065647,
            serialized.span()
        );
    }
            
}

pub impl RolesModelEntityImpl of dojo::model::ModelEntity<RolesEntity> {
    fn id(self: @RolesEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @RolesEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> RolesEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<RolesEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<RolesEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `RolesEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<RolesEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Roles>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Roles>::layout()
        );
    }

    fn delete(self: @RolesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Roles>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Roles>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Roles>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Roles>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @RolesEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Roles>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Roles>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl RolesModelImpl of dojo::model::Model<Roles> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Roles {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        RolesStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @Roles,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @Roles,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Roles,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Roles"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Roles"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2381319068167303801085530774544728044506110381004500761927797648058170896946
    }

    #[inline(always)]
    fn instance_selector(self: @Roles) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2030971736961612564423689930729061756599290850089001157163423482274886199516
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @Roles) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Roles>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Roles) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iroles<T> {
    fn ensure_abi(self: @T, model: Roles);
}

#[starknet::contract]
pub mod roles {
    use super::Roles;
    use super::Iroles;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Roles>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Roles>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Roles>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Roles>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Roles>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Roles>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Roles>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Roles>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Roles>::ty()
        }
    }

    #[abi(embed_v0)]
    impl rolesImpl of Iroles<ContractState>{
        fn ensure_abi(self: @ContractState, model: Roles) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__rolesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Roles>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    rolesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__rolesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl OnlyKeyModelIntrospect<> of dojo::model::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'OnlyKeyModel',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct OnlyKeyModelEntity {
    __id: felt252, // private field
    
}

#[generate_trait]
pub impl OnlyKeyModelEntityStoreImpl of OnlyKeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity {
        OnlyKeyModelModelEntityImpl::get(world, entity_id)
    }

    
}

#[generate_trait]
pub impl OnlyKeyModelStoreImpl of OnlyKeyModelStore {
    fn entity_id_from_keys(id: felt252) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> OnlyKeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<OnlyKeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<OnlyKeyModel>::is_none(@entity) {
            panic!(
                "Model `OnlyKeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<OnlyKeyModel>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, id);


        dojo::model::Model::<OnlyKeyModel>::get(world, serialized.span())
    }

    
}

pub impl OnlyKeyModelModelEntityImpl of dojo::model::ModelEntity<OnlyKeyModelEntity> {
    fn id(self: @OnlyKeyModelEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @OnlyKeyModelEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> OnlyKeyModelEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<OnlyKeyModelEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<OnlyKeyModelEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `OnlyKeyModelEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<OnlyKeyModelEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
    }

    fn delete(self: @OnlyKeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<OnlyKeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<OnlyKeyModel>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<OnlyKeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<OnlyKeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @OnlyKeyModelEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<OnlyKeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<OnlyKeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl OnlyKeyModelModelImpl of dojo::model::Model<OnlyKeyModel> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> OnlyKeyModel {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        OnlyKeyModelStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @OnlyKeyModel,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "OnlyKeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-OnlyKeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        399971050958024375507922651483187108363916132710819632852036528607645634778
    }

    #[inline(always)]
    fn instance_selector(self: @OnlyKeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1001826121797570811408809643478760373535949956555931325019299477987282578617
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @OnlyKeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.id);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @OnlyKeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<OnlyKeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @OnlyKeyModel) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Ionly_key_model<T> {
    fn ensure_abi(self: @T, model: OnlyKeyModel);
}

#[starknet::contract]
pub mod only_key_model {
    use super::OnlyKeyModel;
    use super::Ionly_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<OnlyKeyModel>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<OnlyKeyModel>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<OnlyKeyModel>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<OnlyKeyModel>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<OnlyKeyModel>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<OnlyKeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<OnlyKeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<OnlyKeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<OnlyKeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl only_key_modelImpl of Ionly_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__only_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<OnlyKeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    only_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__only_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl U256KeyModelIntrospect<> of dojo::model::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'U256KeyModel',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'id',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<u256>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct U256KeyModelEntity {
    __id: felt252, // private field
    
}

#[generate_trait]
pub impl U256KeyModelEntityStoreImpl of U256KeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity {
        U256KeyModelModelEntityImpl::get(world, entity_id)
    }

    
}

#[generate_trait]
pub impl U256KeyModelStoreImpl of U256KeyModelStore {
    fn entity_id_from_keys(id: u256) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> U256KeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<U256KeyModel>::deserialize(ref serialized);

        if core::option::OptionTrait::<U256KeyModel>::is_none(@entity) {
            panic!(
                "Model `U256KeyModel`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<U256KeyModel>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@id, ref serialized);


        dojo::model::Model::<U256KeyModel>::get(world, serialized.span())
    }

    
}

pub impl U256KeyModelModelEntityImpl of dojo::model::ModelEntity<U256KeyModelEntity> {
    fn id(self: @U256KeyModelEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @U256KeyModelEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> U256KeyModelEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<U256KeyModelEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<U256KeyModelEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `U256KeyModelEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<U256KeyModelEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<U256KeyModel>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<U256KeyModel>::layout()
        );
    }

    fn delete(self: @U256KeyModelEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<U256KeyModel>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<U256KeyModel>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<U256KeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<U256KeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @U256KeyModelEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<U256KeyModel>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<U256KeyModel>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl U256KeyModelModelImpl of dojo::model::Model<U256KeyModel> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> U256KeyModel {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        U256KeyModelStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @U256KeyModel,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "U256KeyModel"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-U256KeyModel"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3403346971723769227042162502675592040860576799654783499419654467804113799823
    }

    #[inline(always)]
    fn instance_selector(self: @U256KeyModel) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1848733002266458148515852001373055968326209639346734967305014900020806934517
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @U256KeyModel) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.id, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @U256KeyModel) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        
        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<U256KeyModel>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @U256KeyModel) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iu_256_key_model<T> {
    fn ensure_abi(self: @T, model: U256KeyModel);
}

#[starknet::contract]
pub mod u_256_key_model {
    use super::U256KeyModel;
    use super::Iu_256_key_model;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<U256KeyModel>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<U256KeyModel>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<U256KeyModel>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<U256KeyModel>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<U256KeyModel>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<U256KeyModel>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<U256KeyModel>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<U256KeyModel>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<U256KeyModel>::ty()
        }
    }

    #[abi(embed_v0)]
    impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
        fn ensure_abi(self: @ContractState, model: U256KeyModel) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__u_256_key_modelImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<U256KeyModel>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    u_256_key_modelImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__u_256_key_modelImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl PlayerIntrospect<> of dojo::model::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(1)
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 1528802474226268325865027367859591458315299653151958663884057507666229546336,
                    layout: dojo::model::introspect::Introspect::<felt252>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'game',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        },
dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'name',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<felt252>::ty()
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct PlayerEntity {
    __id: felt252, // private field
    pub name: felt252,

}

#[generate_trait]
pub impl PlayerEntityStoreImpl of PlayerEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity {
        PlayerModelEntityImpl::get(world, entity_id)
    }

    
    fn get_name(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252 {
        let mut values = dojo::model::ModelEntity::<PlayerEntity>::get_member(
            world,
            entity_id,
            1528802474226268325865027367859591458315299653151958663884057507666229546336
        );
        let field_value = core::serde::Serde::<felt252>::deserialize(ref values);

        if core::option::OptionTrait::<felt252>::is_none(@field_value) {
            panic!(
                "Field `Player::name`: deserialization failed."
            );
        }

        core::option::OptionTrait::<felt252>::unwrap(field_value)
    }

    fn set_name(self: @PlayerEntity, world: dojo::world::IWorldDispatcher, value: felt252) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1528802474226268325865027367859591458315299653151958663884057507666229546336,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl PlayerStoreImpl of PlayerStore {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Player {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<Player>::deserialize(ref serialized);

        if core::option::OptionTrait::<Player>::is_none(@entity) {
            panic!(
                "Model `Player`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<Player>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<Player>::get(world, serialized.span())
    }

    
    fn get_name(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, game);
core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<Player>::get_member(
            world,
            serialized.span(),
            1528802474226268325865027367859591458315299653151958663884057507666229546336
        );

        let field_value = core::serde::Serde::<felt252>::deserialize(ref values);

        if core::option::OptionTrait::<felt252>::is_none(@field_value) {
            panic!(
                "Field `Player::name`: deserialization failed."
            );
        }

        core::option::OptionTrait::<felt252>::unwrap(field_value)
    }

    fn set_name(self: @Player, world: dojo::world::IWorldDispatcher, value: felt252) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1528802474226268325865027367859591458315299653151958663884057507666229546336,
            serialized.span()
        );
    }
            
}

pub impl PlayerModelEntityImpl of dojo::model::ModelEntity<PlayerEntity> {
    fn id(self: @PlayerEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @PlayerEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> PlayerEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<PlayerEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<PlayerEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `PlayerEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<PlayerEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<Player>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<Player>::layout()
        );
    }

    fn delete(self: @PlayerEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<Player>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<Player>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Player>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<Player>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @PlayerEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<Player>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<Player>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl PlayerModelImpl of dojo::model::Model<Player> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> Player {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        PlayerStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @Player,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @Player,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @Player,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "Player"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-Player"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3068209845672224878774101526910835120619854456556690065951127565061014675679
    }

    #[inline(always)]
    fn instance_selector(self: @Player) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        1073075359926275415180704315933677548333097210683379121732618306925003101845
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @Player) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.game);
core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::array::ArrayTrait::append(ref serialized, *self.name);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<Player>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @Player) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Iplayer<T> {
    fn ensure_abi(self: @T, model: Player);
}

#[starknet::contract]
pub mod player {
    use super::Player;
    use super::Iplayer;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<Player>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<Player>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<Player>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<Player>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<Player>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<Player>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<Player>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<Player>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<Player>::ty()
        }
    }

    #[abi(embed_v0)]
    impl playerImpl of Iplayer<ContractState>{
        fn ensure_abi(self: @ContractState, model: Player) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__playerImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Player>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    playerImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__playerImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithSimpleArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithSimpleArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<Array<u8>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithSimpleArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<u8>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithSimpleArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<u8>,

}

#[generate_trait]
pub impl ModelWithSimpleArrayEntityStoreImpl of ModelWithSimpleArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity {
        ModelWithSimpleArrayModelEntityImpl::get(world, entity_id)
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8> {
        let mut values = dojo::model::ModelEntity::<ModelWithSimpleArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithSimpleArrayStoreImpl of ModelWithSimpleArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithSimpleArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithSimpleArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithSimpleArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithSimpleArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithSimpleArray>::get(world, serialized.span())
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithSimpleArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<u8> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithSimpleArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<Array<u8>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<u8>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithSimpleArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<u8>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: Array<u8>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithSimpleArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithSimpleArrayEntity> {
    fn id(self: @ModelWithSimpleArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithSimpleArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithSimpleArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithSimpleArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithSimpleArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithSimpleArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithSimpleArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
    }

    fn delete(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithSimpleArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithSimpleArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithSimpleArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithSimpleArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithSimpleArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithSimpleArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithSimpleArrayModelImpl of dojo::model::Model<ModelWithSimpleArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithSimpleArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithSimpleArrayStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithSimpleArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithSimpleArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithSimpleArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        516248842335934132822768408262411488579427278776919857986291389606250466377
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithSimpleArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        173141902001925402715103859951360389436088950156916962046507357841237663931
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithSimpleArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithSimpleArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithSimpleArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithSimpleArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_simple_array<T> {
    fn ensure_abi(self: @T, model: ModelWithSimpleArray);
}

#[starknet::contract]
pub mod model_with_simple_array {
    use super::ModelWithSimpleArray;
    use super::Imodel_with_simple_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithSimpleArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithSimpleArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithSimpleArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithSimpleArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithSimpleArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithSimpleArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithSimpleArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithSimpleArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithSimpleArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_simple_arrayImpl of Imodel_with_simple_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithSimpleArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_simple_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithSimpleArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_simple_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_simple_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithByteArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithByteArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<ByteArray
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithByteArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::ByteArray
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithByteArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: ByteArray,

}

#[generate_trait]
pub impl ModelWithByteArrayEntityStoreImpl of ModelWithByteArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity {
        ModelWithByteArrayModelEntityImpl::get(world, entity_id)
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithByteArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray {
        let mut values = dojo::model::ModelEntity::<ModelWithByteArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<ByteArray>::deserialize(ref values);

        if core::option::OptionTrait::<ByteArray>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ByteArray>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: ByteArray) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithByteArrayStoreImpl of ModelWithByteArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithByteArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithByteArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithByteArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithByteArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithByteArray>::get(world, serialized.span())
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithByteArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ByteArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithByteArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<ByteArray>::deserialize(ref values);

        if core::option::OptionTrait::<ByteArray>::is_none(@field_value) {
            panic!(
                "Field `ModelWithByteArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<ByteArray>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: ByteArray) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithByteArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithByteArrayEntity> {
    fn id(self: @ModelWithByteArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithByteArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithByteArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithByteArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithByteArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithByteArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithByteArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
    }

    fn delete(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithByteArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithByteArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithByteArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithByteArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithByteArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithByteArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithByteArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithByteArrayModelImpl of dojo::model::Model<ModelWithByteArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithByteArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithByteArrayStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithByteArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithByteArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithByteArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        858867864009207556499907034628308336720989886132468668210801974294049151990
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithByteArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2176409715042145900636260236501596599545103472111273072320531220776338338674
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithByteArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithByteArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithByteArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithByteArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_byte_array<T> {
    fn ensure_abi(self: @T, model: ModelWithByteArray);
}

#[starknet::contract]
pub mod model_with_byte_array {
    use super::ModelWithByteArray;
    use super::Imodel_with_byte_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithByteArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithByteArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithByteArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithByteArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithByteArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithByteArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithByteArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithByteArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithByteArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_byte_arrayImpl of Imodel_with_byte_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithByteArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_byte_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithByteArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_byte_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_byte_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithComplexArrayIntrospect<> of dojo::model::introspect::Introspect<ModelWithComplexArray<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::None
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::introspect::Introspect::<Array<Vec3>
>::layout()
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithComplexArray',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Array(
                array![
                dojo::model::introspect::Introspect::<Vec3>::ty()
                ].span()
            )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithComplexArrayEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: Array<Vec3>,

}

#[generate_trait]
pub impl ModelWithComplexArrayEntityStoreImpl of ModelWithComplexArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity {
        ModelWithComplexArrayModelEntityImpl::get(world, entity_id)
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3> {
        let mut values = dojo::model::ModelEntity::<ModelWithComplexArrayEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<Array<Vec3>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<Vec3>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<Vec3>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<Vec3>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithComplexArrayStoreImpl of ModelWithComplexArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithComplexArray {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithComplexArray>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithComplexArray>::is_none(@entity) {
            panic!(
                "Model `ModelWithComplexArray`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithComplexArray>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithComplexArray>::get(world, serialized.span())
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithComplexArray>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<Vec3> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithComplexArray>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<Array<Vec3>>::deserialize(ref values);

        if core::option::OptionTrait::<Array<Vec3>>::is_none(@field_value) {
            panic!(
                "Field `ModelWithComplexArray::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<Array<Vec3>>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: Array<Vec3>) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithComplexArrayModelEntityImpl of dojo::model::ModelEntity<ModelWithComplexArrayEntity> {
    fn id(self: @ModelWithComplexArrayEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithComplexArrayEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithComplexArrayEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithComplexArrayEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithComplexArrayEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithComplexArrayEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithComplexArrayEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
    }

    fn delete(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithComplexArray>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithComplexArray>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithComplexArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithComplexArray>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithComplexArrayEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithComplexArray>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithComplexArray>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithComplexArrayModelImpl of dojo::model::Model<ModelWithComplexArray> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithComplexArray {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithComplexArrayStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithComplexArray,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithComplexArray"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithComplexArray"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        298653312264896693167501639402458085580783343254117966446641652721994965516
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithComplexArray) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        2866472224509756243720005045848892642397514372569303051745174230372637769655
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithComplexArray) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithComplexArray) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithComplexArray>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithComplexArray) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_complex_array<T> {
    fn ensure_abi(self: @T, model: ModelWithComplexArray);
}

#[starknet::contract]
pub mod model_with_complex_array {
    use super::ModelWithComplexArray;
    use super::Imodel_with_complex_array;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithComplexArray>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithComplexArray>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithComplexArray>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithComplexArray>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithComplexArray>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithComplexArray>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithComplexArray>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithComplexArray>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithComplexArray>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_complex_arrayImpl of Imodel_with_complex_array<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithComplexArray) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_complex_arrayImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithComplexArray>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_complex_arrayImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_complex_arrayImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithTupleIntrospect<> of dojo::model::introspect::Introspect<ModelWithTuple<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        Option::Some(4)
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::Layout::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::layout(),
dojo::model::introspect::Introspect::<u16>::layout(),
dojo::model::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithTuple',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::ty(),
dojo::model::introspect::Introspect::<u16>::ty(),
dojo::model::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, u16, u32),

}

#[generate_trait]
pub impl ModelWithTupleEntityStoreImpl of ModelWithTupleEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity {
        ModelWithTupleModelEntityImpl::get(world, entity_id)
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32) {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<(u8, u16, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, u16, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, u16, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithTupleStoreImpl of ModelWithTupleStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTuple {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTuple>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTuple>::is_none(@entity) {
            panic!(
                "Model `ModelWithTuple`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTuple>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTuple>::get(world, serialized.span())
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTuple>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, u16, u32) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTuple>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<(u8, u16, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, u16, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTuple::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, u16, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithTupleModelEntityImpl of dojo::model::ModelEntity<ModelWithTupleEntity> {
    fn id(self: @ModelWithTupleEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithTupleEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithTupleEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithTupleEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithTupleEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithTupleEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithTupleEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
    }

    fn delete(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithTuple>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithTuple>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTuple>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithTuple>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTuple>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithTuple>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithTupleModelImpl of dojo::model::Model<ModelWithTuple> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithTuple {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithTupleStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTuple,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTuple"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithTuple"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        3520389162382437315776520663535583701836688108885454850509972628400715241
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTuple) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        3222351670132870101782632958288197874250493316621507272653773018669253981260
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithTuple) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTuple) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithTuple>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTuple) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_tuple<T> {
    fn ensure_abi(self: @T, model: ModelWithTuple);
}

#[starknet::contract]
pub mod model_with_tuple {
    use super::ModelWithTuple;
    use super::Imodel_with_tuple;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTuple>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTuple>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTuple>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTuple>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTuple>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithTuple>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTuple>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithTuple>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithTuple>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tupleImpl of Imodel_with_tuple<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTuple) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_tupleImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTuple>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tupleImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tupleImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}

impl ModelWithTupleNoPrimitivesIntrospect<> of dojo::model::introspect::Introspect<ModelWithTupleNoPrimitives<>> {
    #[inline(always)]
    fn size() -> Option<usize> {
        let sizes : Array<Option<usize>> = array![
                    dojo::model::introspect::Introspect::<Vec3>::size(),
Option::Some(3)
                ];

                if dojo::utils::any_none(@sizes) {
                    return Option::None;
                }
                Option::Some(dojo::utils::sum(sizes))
                
    }

    fn layout() -> dojo::model::Layout {
        dojo::model::Layout::Struct(
            array![
            dojo::model::FieldLayout {
                    selector: 512066735765477566404754172672287371265995314501343422459174036873487219331,
                    layout: dojo::model::introspect::Introspect::<u16>::layout()
                },
dojo::model::FieldLayout {
                    selector: 1591024729085637502504777720563487898377940395575083379770417352976841400819,
                    layout: dojo::model::Layout::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::layout(),
dojo::model::introspect::Introspect::<Vec3>::layout(),
dojo::model::introspect::Introspect::<u32>::layout()
            ].span()
        )
                }
            ].span()
        )
    }

    #[inline(always)]
    fn ty() -> dojo::model::introspect::Ty {
        dojo::model::introspect::Ty::Struct(
            dojo::model::introspect::Struct {
                name: 'ModelWithTupleNoPrimitives',
                attrs: array![].span(),
                children: array![
                dojo::model::introspect::Member {
            name: 'player',
            attrs: array!['key'].span(),
            ty: dojo::model::introspect::Introspect::<ContractAddress>::ty()
        },
dojo::model::introspect::Member {
            name: 'x',
            attrs: array![].span(),
            ty: dojo::model::introspect::Introspect::<u16>::ty()
        },
dojo::model::introspect::Member {
            name: 'y',
            attrs: array![].span(),
            ty: dojo::model::introspect::Ty::Tuple(
            array![
            dojo::model::introspect::Introspect::<u8>::ty(),
dojo::model::introspect::Introspect::<Vec3>::ty(),
dojo::model::introspect::Introspect::<u32>::ty()
            ].span()
        )
        }

                ].span()
            }
        )
    }
}
        
#[derive(Drop, Serde)]
pub struct ModelWithTupleNoPrimitivesEntity {
    __id: felt252, // private field
    pub x: u16,
pub y: (u8, Vec3, u32),

}

#[generate_trait]
pub impl ModelWithTupleNoPrimitivesEntityStoreImpl of ModelWithTupleNoPrimitivesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity {
        ModelWithTupleNoPrimitivesModelEntityImpl::get(world, entity_id)
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16 {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::get_member(
            world,
            entity_id,
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );
        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32) {
        let mut values = dojo::model::ModelEntity::<ModelWithTupleNoPrimitivesEntity>::get_member(
            world,
            entity_id,
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );
        let field_value = core::serde::Serde::<(u8, Vec3, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, Vec3, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, Vec3, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }

}

#[generate_trait]
pub impl ModelWithTupleNoPrimitivesStoreImpl of ModelWithTupleNoPrimitivesStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);

        core::poseidon::poseidon_hash_span(serialized.span())
    }

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTupleNoPrimitives {
        let mut serialized = core::array::ArrayTrait::new();
        serialized.append_span(keys);
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity = core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref serialized);

        if core::option::OptionTrait::<ModelWithTupleNoPrimitives>::is_none(@entity) {
            panic!(
                "Model `ModelWithTupleNoPrimitives`: deserialization failed. Ensure the length of the keys tuple is matching the number of #[key] fields in the model struct."
            );
        }

        core::option::OptionTrait::<ModelWithTupleNoPrimitives>::unwrap(entity)
    }

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        dojo::model::Model::<ModelWithTupleNoPrimitives>::get(world, serialized.span())
    }

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16 {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTupleNoPrimitives>::get_member(
            world,
            serialized.span(),
            512066735765477566404754172672287371265995314501343422459174036873487219331
        );

        let field_value = core::serde::Serde::<u16>::deserialize(ref values);

        if core::option::OptionTrait::<u16>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::x`: deserialization failed."
            );
        }

        core::option::OptionTrait::<u16>::unwrap(field_value)
    }

    fn set_x(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: u16) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            512066735765477566404754172672287371265995314501343422459174036873487219331,
            serialized.span()
        );
    }
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, Vec3, u32) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@player, ref serialized);


        let mut values = dojo::model::Model::<ModelWithTupleNoPrimitives>::get_member(
            world,
            serialized.span(),
            1591024729085637502504777720563487898377940395575083379770417352976841400819
        );

        let field_value = core::serde::Serde::<(u8, Vec3, u32)>::deserialize(ref values);

        if core::option::OptionTrait::<(u8, Vec3, u32)>::is_none(@field_value) {
            panic!(
                "Field `ModelWithTupleNoPrimitives::y`: deserialization failed."
            );
        }

        core::option::OptionTrait::<(u8, Vec3, u32)>::unwrap(field_value)
    }

    fn set_y(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32)) {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(@value, ref serialized);

        self.set_member(
            world,
            1591024729085637502504777720563487898377940395575083379770417352976841400819,
            serialized.span()
        );
    }
            
}

pub impl ModelWithTupleNoPrimitivesModelEntityImpl of dojo::model::ModelEntity<ModelWithTupleNoPrimitivesEntity> {
    fn id(self: @ModelWithTupleNoPrimitivesEntity) -> felt252 {
        *self.__id
    }

    fn values(self: @ModelWithTupleNoPrimitivesEntity) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    fn from_values(entity_id: felt252, ref values: Span<felt252>) -> ModelWithTupleNoPrimitivesEntity {
        let mut serialized = array![entity_id];
        serialized.append_span(values);
        let mut serialized = core::array::ArrayTrait::span(@serialized);

        let entity_values = core::serde::Serde::<ModelWithTupleNoPrimitivesEntity>::deserialize(ref serialized);
        if core::option::OptionTrait::<ModelWithTupleNoPrimitivesEntity>::is_none(@entity_values) {
            panic!(
                "ModelEntity `ModelWithTupleNoPrimitivesEntity`: deserialization failed."
            );
        }
        core::option::OptionTrait::<ModelWithTupleNoPrimitivesEntity>::unwrap(entity_values)
    }

    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(entity_id),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
        Self::from_values(entity_id, ref values)
    }

    fn update(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            self.values(),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
    }

    fn delete(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
            dojo::model::ModelIndex::Id(self.id()),
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        entity_id: felt252,
        member_id: felt252,
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTupleNoPrimitives>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleNoPrimitivesEntity,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>,
    ) {
        match dojo::utils::find_model_field_layout(dojo::model::Model::<ModelWithTupleNoPrimitives>::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    dojo::model::Model::<ModelWithTupleNoPrimitives>::selector(),
                    dojo::model::ModelIndex::MemberId((self.id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }
}

pub impl ModelWithTupleNoPrimitivesModelImpl of dojo::model::Model<ModelWithTupleNoPrimitives> {
    fn get(world: dojo::world::IWorldDispatcher, keys: Span<felt252>) -> ModelWithTupleNoPrimitives {
        let mut values = dojo::world::IWorldDispatcherTrait::entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(keys),
            Self::layout()
        );
        let mut _keys = keys;

        ModelWithTupleNoPrimitivesStore::from_values(ref _keys, ref values)
    }

   fn set(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::set_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::values(self),
            Self::layout()
        );
    }

    fn delete(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher
    ) {
        dojo::world::IWorldDispatcherTrait::delete_entity(
            world,
            Self::selector(),
            dojo::model::ModelIndex::Keys(Self::keys(self)),
            Self::layout()
        );
    }

    fn get_member(
        world: dojo::world::IWorldDispatcher,
        keys: Span<felt252>,
        member_id: felt252
    ) -> Span<felt252> {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                let entity_id = dojo::utils::entity_id_from_keys(keys);
                dojo::world::IWorldDispatcherTrait::entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((entity_id, member_id)),
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    fn set_member(
        self: @ModelWithTupleNoPrimitives,
        world: dojo::world::IWorldDispatcher,
        member_id: felt252,
        values: Span<felt252>
    ) {
        match dojo::utils::find_model_field_layout(Self::layout(), member_id) {
            Option::Some(field_layout) => {
                dojo::world::IWorldDispatcherTrait::set_entity(
                    world,
                    Self::selector(),
                    dojo::model::ModelIndex::MemberId((self.entity_id(), member_id)),
                    values,
                    field_layout
                )
            },
            Option::None => core::panic_with_felt252('bad member id')
        }
    }

    #[inline(always)]
    fn name() -> ByteArray {
        "ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn namespace() -> ByteArray {
        "test_package"
    }

    #[inline(always)]
    fn tag() -> ByteArray {
        "test_package-ModelWithTupleNoPrimitives"
    }

    #[inline(always)]
    fn version() -> u8 {
        1
    }

    #[inline(always)]
    fn selector() -> felt252 {
        2133652848391750418502705747419625263797079439106286994977255727801602328040
    }

    #[inline(always)]
    fn instance_selector(self: @ModelWithTupleNoPrimitives) -> felt252 {
        Self::selector()
    }

    #[inline(always)]
    fn name_hash() -> felt252 {
        157059227407493660591195028728750607977045261142495925435047270200565107096
    }

    #[inline(always)]
    fn namespace_hash() -> felt252 {
        3061092720893075933752785490401950953836105364709575990296000909161416686979
    }

    #[inline(always)]
    fn entity_id(self: @ModelWithTupleNoPrimitives) -> felt252 {
        core::poseidon::poseidon_hash_span(self.keys())
    }

    #[inline(always)]
    fn keys(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.player, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @ModelWithTupleNoPrimitives) -> Span<felt252> {
        let mut serialized = core::array::ArrayTrait::new();
        core::serde::Serde::serialize(self.x, ref serialized);
core::serde::Serde::serialize(self.y, ref serialized);

        core::array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout() -> dojo::model::Layout {
        dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::layout()
    }

    #[inline(always)]
    fn instance_layout(self: @ModelWithTupleNoPrimitives) -> dojo::model::Layout {
        Self::layout()
    }

    #[inline(always)]
    fn packed_size() -> Option<usize> {
        dojo::model::layout::compute_packed_size(Self::layout())
    }
}

#[starknet::interface]
pub trait Imodel_with_tuple_no_primitives<T> {
    fn ensure_abi(self: @T, model: ModelWithTupleNoPrimitives);
}

#[starknet::contract]
pub mod model_with_tuple_no_primitives {
    use super::ModelWithTupleNoPrimitives;
    use super::Imodel_with_tuple_no_primitives;

    #[abi(embed_v0)]
    impl DojoModelImpl of dojo::model::IModel<ContractState>{
        fn name(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::name()
        }

        fn namespace(self: @ContractState) -> ByteArray {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace()
        }

        fn tag(self: @ContractState) -> ByteArray {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::tag()
        }

        fn version(self: @ContractState) -> u8 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::version()
        }

        fn selector(self: @ContractState) -> felt252 {
           dojo::model::Model::<ModelWithTupleNoPrimitives>::selector()
        }

        fn name_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::name_hash()
        }

        fn namespace_hash(self: @ContractState) -> felt252 {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::namespace_hash()
        }

        fn unpacked_size(self: @ContractState) -> Option<usize> {
            dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::size()
        }

        fn packed_size(self: @ContractState) -> Option<usize> {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::packed_size()
        }

        fn layout(self: @ContractState) -> dojo::model::Layout {
            dojo::model::Model::<ModelWithTupleNoPrimitives>::layout()
        }

        fn schema(self: @ContractState) -> dojo::model::introspect::Ty {
            dojo::model::introspect::Introspect::<ModelWithTupleNoPrimitives>::ty()
        }
    }

    #[abi(embed_v0)]
    impl model_with_tuple_no_primitivesImpl of Imodel_with_tuple_no_primitives<ContractState>{
        fn ensure_abi(self: @ContractState, model: ModelWithTupleNoPrimitives) {
        }
    }
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
        }
    }
}
pub struct ContractState {
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__version(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::version(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<u8>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__unpacked_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::unpacked_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__packed_size(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::packed_size(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<Option<usize>>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__layout(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::layout(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::Layout>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__DojoModelImpl__schema(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = DojoModelImpl::schema(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<dojo::model::introspect::Ty>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__model_with_tuple_no_primitivesImpl__ensure_abi(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_model = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ModelWithTupleNoPrimitives>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    model_with_tuple_no_primitivesImpl::ensure_abi(@contract_state, __arg_model);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__DojoModelImpl__name as name;
    pub use super::__wrapper__DojoModelImpl__namespace as namespace;
    pub use super::__wrapper__DojoModelImpl__tag as tag;
    pub use super::__wrapper__DojoModelImpl__version as version;
    pub use super::__wrapper__DojoModelImpl__selector as selector;
    pub use super::__wrapper__DojoModelImpl__name_hash as name_hash;
    pub use super::__wrapper__DojoModelImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__DojoModelImpl__unpacked_size as unpacked_size;
    pub use super::__wrapper__DojoModelImpl__packed_size as packed_size;
    pub use super::__wrapper__DojoModelImpl__layout as layout;
    pub use super::__wrapper__DojoModelImpl__schema as schema;
    pub use super::__wrapper__model_with_tuple_no_primitivesImpl__ensure_abi as ensure_abi;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
}
impl BadModelMultipleVersionsEntityDrop of core::traits::Drop::<BadModelMultipleVersionsEntity>;
impl BadModelMultipleVersionsEntitySerde of core::serde::Serde::<BadModelMultipleVersionsEntity> {
    fn serialize(self: @BadModelMultipleVersionsEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelMultipleVersionsEntity> {
        core::option::Option::Some(BadModelMultipleVersionsEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelMultipleVersionsEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelMultipleVersionsEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelMultipleVersionsEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelMultipleVersionsStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelMultipleVersions;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelMultipleVersions;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelMultipleVersions, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_multiple_versionsDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelMultipleVersions);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsLibraryDispatcherImpl of Ibad_model_multiple_versionsDispatcherTrait<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsLibraryDispatcher, model: BadModelMultipleVersions) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_multiple_versionsSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelMultipleVersions) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_multiple_versionsSafeLibraryDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeLibraryDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_multiple_versionsSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_multiple_versionsSafeDispatcherImpl of Ibad_model_multiple_versionsSafeDispatcherTrait<Ibad_model_multiple_versionsSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_multiple_versionsSafeDispatcher, model: BadModelMultipleVersions) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelMultipleVersions>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelBadVersionTypeEntityDrop of core::traits::Drop::<BadModelBadVersionTypeEntity>;
impl BadModelBadVersionTypeEntitySerde of core::serde::Serde::<BadModelBadVersionTypeEntity> {
    fn serialize(self: @BadModelBadVersionTypeEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelBadVersionTypeEntity> {
        core::option::Option::Some(BadModelBadVersionTypeEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelBadVersionTypeEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelBadVersionTypeEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelBadVersionTypeEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelBadVersionTypeStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelBadVersionType;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelBadVersionType;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelBadVersionType, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_bad_version_typeDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelBadVersionType);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeLibraryDispatcherImpl of Ibad_model_bad_version_typeDispatcherTrait<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeLibraryDispatcher, model: BadModelBadVersionType) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_bad_version_typeSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelBadVersionType) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_bad_version_typeSafeLibraryDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeLibraryDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_bad_version_typeSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_bad_version_typeSafeDispatcherImpl of Ibad_model_bad_version_typeSafeDispatcherTrait<Ibad_model_bad_version_typeSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_bad_version_typeSafeDispatcher, model: BadModelBadVersionType) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelBadVersionType>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelNoVersionValueEntityDrop of core::traits::Drop::<BadModelNoVersionValueEntity>;
impl BadModelNoVersionValueEntitySerde of core::serde::Serde::<BadModelNoVersionValueEntity> {
    fn serialize(self: @BadModelNoVersionValueEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNoVersionValueEntity> {
        core::option::Option::Some(BadModelNoVersionValueEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelNoVersionValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNoVersionValueEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelNoVersionValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelNoVersionValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNoVersionValue;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNoVersionValue;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelNoVersionValue, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_no_version_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNoVersionValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueLibraryDispatcherImpl of Ibad_model_no_version_valueDispatcherTrait<Ibad_model_no_version_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueLibraryDispatcher, model: BadModelNoVersionValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_no_version_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNoVersionValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_no_version_valueSafeLibraryDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeLibraryDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_no_version_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_no_version_valueSafeDispatcherImpl of Ibad_model_no_version_valueSafeDispatcherTrait<Ibad_model_no_version_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_no_version_valueSafeDispatcher, model: BadModelNoVersionValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNoVersionValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelUnexpectedArgWithValueEntityDrop of core::traits::Drop::<BadModelUnexpectedArgWithValueEntity>;
impl BadModelUnexpectedArgWithValueEntitySerde of core::serde::Serde::<BadModelUnexpectedArgWithValueEntity> {
    fn serialize(self: @BadModelUnexpectedArgWithValueEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgWithValueEntity> {
        core::option::Option::Some(BadModelUnexpectedArgWithValueEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelUnexpectedArgWithValueEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgWithValueEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgWithValueEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelUnexpectedArgWithValueStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArgWithValue;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArgWithValue;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgWithValue, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_unexpected_arg_with_valueDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueDispatcherTrait<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueLibraryDispatcher, model: BadModelUnexpectedArgWithValue) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_arg_with_valueSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_arg_with_valueSafeDispatcherImpl of Ibad_model_unexpected_arg_with_valueSafeDispatcherTrait<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_arg_with_valueSafeDispatcher, model: BadModelUnexpectedArgWithValue) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArgWithValue>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelUnexpectedArgEntityDrop of core::traits::Drop::<BadModelUnexpectedArgEntity>;
impl BadModelUnexpectedArgEntitySerde of core::serde::Serde::<BadModelUnexpectedArgEntity> {
    fn serialize(self: @BadModelUnexpectedArgEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelUnexpectedArgEntity> {
        core::option::Option::Some(BadModelUnexpectedArgEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelUnexpectedArgEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelUnexpectedArgEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArgEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelUnexpectedArgStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelUnexpectedArg;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelUnexpectedArg;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelUnexpectedArg, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_unexpected_argDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelUnexpectedArg);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argLibraryDispatcherImpl of Ibad_model_unexpected_argDispatcherTrait<Ibad_model_unexpected_argLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argLibraryDispatcher, model: BadModelUnexpectedArg) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_unexpected_argSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_unexpected_argSafeLibraryDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeLibraryDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_unexpected_argSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_unexpected_argSafeDispatcherImpl of Ibad_model_unexpected_argSafeDispatcherTrait<Ibad_model_unexpected_argSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_unexpected_argSafeDispatcher, model: BadModelUnexpectedArg) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelUnexpectedArg>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl BadModelNotSupportedVersionEntityDrop of core::traits::Drop::<BadModelNotSupportedVersionEntity>;
impl BadModelNotSupportedVersionEntitySerde of core::serde::Serde::<BadModelNotSupportedVersionEntity> {
    fn serialize(self: @BadModelNotSupportedVersionEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<BadModelNotSupportedVersionEntity> {
        core::option::Option::Some(BadModelNotSupportedVersionEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait BadModelNotSupportedVersionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> BadModelNotSupportedVersionEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @BadModelNotSupportedVersionEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait BadModelNotSupportedVersionStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> BadModelNotSupportedVersion;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> BadModelNotSupportedVersion;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @BadModelNotSupportedVersion, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Ibad_model_not_supported_versionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionLibraryDispatcherImpl of Ibad_model_not_supported_versionDispatcherTrait<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionLibraryDispatcher, model: BadModelNotSupportedVersion) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ibad_model_not_supported_versionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ibad_model_not_supported_versionSafeLibraryDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeLibraryDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ibad_model_not_supported_versionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ibad_model_not_supported_versionSafeDispatcherImpl of Ibad_model_not_supported_versionSafeDispatcherTrait<Ibad_model_not_supported_versionSafeDispatcher> {
    fn ensure_abi(self: Ibad_model_not_supported_versionSafeDispatcher, model: BadModelNotSupportedVersion) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<BadModelNotSupportedVersion>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl Modelv0EntityDrop of core::traits::Drop::<Modelv0Entity>;
impl Modelv0EntitySerde of core::serde::Serde::<Modelv0Entity> {
    fn serialize(self: @Modelv0Entity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Modelv0Entity> {
        core::option::Option::Some(Modelv0Entity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait Modelv0EntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Modelv0Entity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @Modelv0Entity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait Modelv0Store {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Modelv0;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Modelv0;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @Modelv0, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodelv_0DispatcherTrait<T> {
    fn ensure_abi(self: T, model: Modelv0);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0Dispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0DispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0Dispatcher> {
    fn ensure_abi(self: Imodelv_0Dispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0LibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0LibraryDispatcherImpl of Imodelv_0DispatcherTrait<Imodelv_0LibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0LibraryDispatcher, model: Modelv0) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodelv_0SafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Modelv0) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0SafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodelv_0SafeLibraryDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeLibraryDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeLibraryDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodelv_0SafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodelv_0SafeDispatcherImpl of Imodelv_0SafeDispatcherTrait<Imodelv_0SafeDispatcher> {
    fn ensure_abi(self: Imodelv_0SafeDispatcher, model: Modelv0) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Modelv0>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithBadNamespaceFormatEntityDrop of core::traits::Drop::<ModelWithBadNamespaceFormatEntity>;
impl ModelWithBadNamespaceFormatEntitySerde of core::serde::Serde::<ModelWithBadNamespaceFormatEntity> {
    fn serialize(self: @ModelWithBadNamespaceFormatEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithBadNamespaceFormatEntity> {
        core::option::Option::Some(ModelWithBadNamespaceFormatEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithBadNamespaceFormatEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithBadNamespaceFormatEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithBadNamespaceFormatEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithBadNamespaceFormatStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithBadNamespaceFormat;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithBadNamespaceFormat;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithBadNamespaceFormat, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_bad_namespace_formatDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatLibraryDispatcherImpl of Imodel_with_bad_namespace_formatDispatcherTrait<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatLibraryDispatcher, model: ModelWithBadNamespaceFormat) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_bad_namespace_formatSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeLibraryDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_bad_namespace_formatSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_bad_namespace_formatSafeDispatcherImpl of Imodel_with_bad_namespace_formatSafeDispatcherTrait<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_bad_namespace_formatSafeDispatcher, model: ModelWithBadNamespaceFormat) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithBadNamespaceFormat>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithShortStringNamespaceEntityDrop of core::traits::Drop::<ModelWithShortStringNamespaceEntity>;
impl ModelWithShortStringNamespaceEntitySerde of core::serde::Serde::<ModelWithShortStringNamespaceEntity> {
    fn serialize(self: @ModelWithShortStringNamespaceEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithShortStringNamespaceEntity> {
        core::option::Option::Some(ModelWithShortStringNamespaceEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithShortStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithShortStringNamespaceEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithShortStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithShortStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithShortStringNamespace;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithShortStringNamespace;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithShortStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_short_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceLibraryDispatcherImpl of Imodel_with_short_string_namespaceDispatcherTrait<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceLibraryDispatcher, model: ModelWithShortStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_short_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_short_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeLibraryDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_short_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_short_string_namespaceSafeDispatcherImpl of Imodel_with_short_string_namespaceSafeDispatcherTrait<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_short_string_namespaceSafeDispatcher, model: ModelWithShortStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithShortStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithStringNamespaceEntityDrop of core::traits::Drop::<ModelWithStringNamespaceEntity>;
impl ModelWithStringNamespaceEntitySerde of core::serde::Serde::<ModelWithStringNamespaceEntity> {
    fn serialize(self: @ModelWithStringNamespaceEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithStringNamespaceEntity> {
        core::option::Option::Some(ModelWithStringNamespaceEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithStringNamespaceEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithStringNamespaceEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @ModelWithStringNamespaceEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait ModelWithStringNamespaceStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithStringNamespace;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> ModelWithStringNamespace;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @ModelWithStringNamespace, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait Imodel_with_string_namespaceDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithStringNamespace);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceLibraryDispatcherImpl of Imodel_with_string_namespaceDispatcherTrait<Imodel_with_string_namespaceLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceLibraryDispatcher, model: ModelWithStringNamespace) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_string_namespaceSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithStringNamespace) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_string_namespaceSafeLibraryDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeLibraryDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_string_namespaceSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_string_namespaceSafeDispatcherImpl of Imodel_with_string_namespaceSafeDispatcherTrait<Imodel_with_string_namespaceSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_string_namespaceSafeDispatcher, model: ModelWithStringNamespace) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithStringNamespace>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl PositionEntityDrop of core::traits::Drop::<PositionEntity>;
impl PositionEntitySerde of core::serde::Serde::<PositionEntity> {
    fn serialize(self: @PositionEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PositionEntity> {
        core::option::Option::Some(PositionEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait PositionEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PositionEntity;

    
    fn get_v(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Vec3;

    fn set_v(self: @PositionEntity, world: dojo::world::IWorldDispatcher, value: Vec3);

}
pub trait PositionStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Position;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> Position;

    
    fn get_v(world: dojo::world::IWorldDispatcher, id: felt252) -> Vec3;

    fn set_v(self: @Position, world: dojo::world::IWorldDispatcher, value: Vec3);
            
}
pub trait IpositionDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Position);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionDispatcherImpl of IpositionDispatcherTrait<IpositionDispatcher> {
    fn ensure_abi(self: IpositionDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionLibraryDispatcherImpl of IpositionDispatcherTrait<IpositionLibraryDispatcher> {
    fn ensure_abi(self: IpositionLibraryDispatcher, model: Position) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IpositionSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Position) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IpositionSafeLibraryDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeLibraryDispatcher> {
    fn ensure_abi(self: IpositionSafeLibraryDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IpositionSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IpositionSafeDispatcherImpl of IpositionSafeDispatcherTrait<IpositionSafeDispatcher> {
    fn ensure_abi(self: IpositionSafeDispatcher, model: Position) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Position>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl RolesEntityDrop of core::traits::Drop::<RolesEntity>;
impl RolesEntitySerde of core::serde::Serde::<RolesEntity> {
    fn serialize(self: @RolesEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.role_ids, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<RolesEntity> {
        core::option::Option::Some(RolesEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            role_ids: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait RolesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> RolesEntity;

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8>;

    fn set_role_ids(self: @RolesEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>);

}
pub trait RolesStore {
    fn entity_id_from_keys() -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Roles;

    fn get(world: dojo::world::IWorldDispatcher, ) -> Roles;

    
    fn get_role_ids(world: dojo::world::IWorldDispatcher, ) -> Array<u8>;

    fn set_role_ids(self: @Roles, world: dojo::world::IWorldDispatcher, value: Array<u8>);
            
}
pub trait IrolesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Roles);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesDispatcherImpl of IrolesDispatcherTrait<IrolesDispatcher> {
    fn ensure_abi(self: IrolesDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesLibraryDispatcherImpl of IrolesDispatcherTrait<IrolesLibraryDispatcher> {
    fn ensure_abi(self: IrolesLibraryDispatcher, model: Roles) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IrolesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Roles) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IrolesSafeLibraryDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeLibraryDispatcher> {
    fn ensure_abi(self: IrolesSafeLibraryDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IrolesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IrolesSafeDispatcherImpl of IrolesSafeDispatcherTrait<IrolesSafeDispatcher> {
    fn ensure_abi(self: IrolesSafeDispatcher, model: Roles) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Roles>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl OnlyKeyModelEntityDrop of core::traits::Drop::<OnlyKeyModelEntity>;
impl OnlyKeyModelEntitySerde of core::serde::Serde::<OnlyKeyModelEntity> {
    fn serialize(self: @OnlyKeyModelEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<OnlyKeyModelEntity> {
        core::option::Option::Some(OnlyKeyModelEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait OnlyKeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> OnlyKeyModelEntity;

    
}
pub trait OnlyKeyModelStore {
    fn entity_id_from_keys(id: felt252) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> OnlyKeyModel;

    fn get(world: dojo::world::IWorldDispatcher, id: felt252) -> OnlyKeyModel;

    
}
pub trait Ionly_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: OnlyKeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelDispatcher> {
    fn ensure_abi(self: Ionly_key_modelDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelLibraryDispatcherImpl of Ionly_key_modelDispatcherTrait<Ionly_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelLibraryDispatcher, model: OnlyKeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Ionly_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: OnlyKeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Ionly_key_modelSafeLibraryDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeLibraryDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Ionly_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Ionly_key_modelSafeDispatcherImpl of Ionly_key_modelSafeDispatcherTrait<Ionly_key_modelSafeDispatcher> {
    fn ensure_abi(self: Ionly_key_modelSafeDispatcher, model: OnlyKeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<OnlyKeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl U256KeyModelEntityDrop of core::traits::Drop::<U256KeyModelEntity>;
impl U256KeyModelEntitySerde of core::serde::Serde::<U256KeyModelEntity> {
    fn serialize(self: @U256KeyModelEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<U256KeyModelEntity> {
        core::option::Option::Some(U256KeyModelEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait U256KeyModelEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> U256KeyModelEntity;

    
}
pub trait U256KeyModelStore {
    fn entity_id_from_keys(id: u256) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> U256KeyModel;

    fn get(world: dojo::world::IWorldDispatcher, id: u256) -> U256KeyModel;

    
}
pub trait Iu_256_key_modelDispatcherTrait<T> {
    fn ensure_abi(self: T, model: U256KeyModel);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelLibraryDispatcherImpl of Iu_256_key_modelDispatcherTrait<Iu_256_key_modelLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelLibraryDispatcher, model: U256KeyModel) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Iu_256_key_modelSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: U256KeyModel) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Iu_256_key_modelSafeLibraryDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeLibraryDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeLibraryDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Iu_256_key_modelSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Iu_256_key_modelSafeDispatcherImpl of Iu_256_key_modelSafeDispatcherTrait<Iu_256_key_modelSafeDispatcher> {
    fn ensure_abi(self: Iu_256_key_modelSafeDispatcher, model: U256KeyModel) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<U256KeyModel>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl PlayerEntityDrop of core::traits::Drop::<PlayerEntity>;
impl PlayerEntitySerde of core::serde::Serde::<PlayerEntity> {
    fn serialize(self: @PlayerEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.name, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<PlayerEntity> {
        core::option::Option::Some(PlayerEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            name: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait PlayerEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> PlayerEntity;

    
    fn get_name(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> felt252;

    fn set_name(self: @PlayerEntity, world: dojo::world::IWorldDispatcher, value: felt252);

}
pub trait PlayerStore {
    fn entity_id_from_keys(game: felt252, player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> Player;

    fn get(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> Player;

    
    fn get_name(world: dojo::world::IWorldDispatcher, game: felt252, player: ContractAddress) -> felt252;

    fn set_name(self: @Player, world: dojo::world::IWorldDispatcher, value: felt252);
            
}
pub trait IplayerDispatcherTrait<T> {
    fn ensure_abi(self: T, model: Player);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerDispatcherImpl of IplayerDispatcherTrait<IplayerDispatcher> {
    fn ensure_abi(self: IplayerDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerLibraryDispatcherImpl of IplayerDispatcherTrait<IplayerLibraryDispatcher> {
    fn ensure_abi(self: IplayerLibraryDispatcher, model: Player) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait IplayerSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: Player) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IplayerSafeLibraryDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeLibraryDispatcher> {
    fn ensure_abi(self: IplayerSafeLibraryDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct IplayerSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IplayerSafeDispatcherImpl of IplayerSafeDispatcherTrait<IplayerSafeDispatcher> {
    fn ensure_abi(self: IplayerSafeDispatcher, model: Player) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<Player>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithSimpleArrayEntityDrop of core::traits::Drop::<ModelWithSimpleArrayEntity>;
impl ModelWithSimpleArrayEntitySerde of core::serde::Serde::<ModelWithSimpleArrayEntity> {
    fn serialize(self: @ModelWithSimpleArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithSimpleArrayEntity> {
        core::option::Option::Some(ModelWithSimpleArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithSimpleArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithSimpleArrayEntity;

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<u8>;

    fn set_y(self: @ModelWithSimpleArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<u8>);

}
pub trait ModelWithSimpleArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithSimpleArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithSimpleArray;

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<u8>;

    fn set_y(self: @ModelWithSimpleArray, world: dojo::world::IWorldDispatcher, value: Array<u8>);
            
}
pub trait Imodel_with_simple_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithSimpleArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arrayDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arrayLibraryDispatcherImpl of Imodel_with_simple_arrayDispatcherTrait<Imodel_with_simple_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arrayLibraryDispatcher, model: ModelWithSimpleArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_simple_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithSimpleArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_simple_arraySafeLibraryDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeLibraryDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_simple_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_simple_arraySafeDispatcherImpl of Imodel_with_simple_arraySafeDispatcherTrait<Imodel_with_simple_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_simple_arraySafeDispatcher, model: ModelWithSimpleArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithSimpleArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithByteArrayEntityDrop of core::traits::Drop::<ModelWithByteArrayEntity>;
impl ModelWithByteArrayEntitySerde of core::serde::Serde::<ModelWithByteArrayEntity> {
    fn serialize(self: @ModelWithByteArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithByteArrayEntity> {
        core::option::Option::Some(ModelWithByteArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithByteArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithByteArrayEntity;

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ByteArray;

    fn set_y(self: @ModelWithByteArrayEntity, world: dojo::world::IWorldDispatcher, value: ByteArray);

}
pub trait ModelWithByteArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithByteArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithByteArray;

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ByteArray;

    fn set_y(self: @ModelWithByteArray, world: dojo::world::IWorldDispatcher, value: ByteArray);
            
}
pub trait Imodel_with_byte_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithByteArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arrayDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arrayLibraryDispatcherImpl of Imodel_with_byte_arrayDispatcherTrait<Imodel_with_byte_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arrayLibraryDispatcher, model: ModelWithByteArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_byte_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithByteArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_byte_arraySafeLibraryDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeLibraryDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_byte_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_byte_arraySafeDispatcherImpl of Imodel_with_byte_arraySafeDispatcherTrait<Imodel_with_byte_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_byte_arraySafeDispatcher, model: ModelWithByteArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithByteArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithComplexArrayEntityDrop of core::traits::Drop::<ModelWithComplexArrayEntity>;
impl ModelWithComplexArrayEntitySerde of core::serde::Serde::<ModelWithComplexArrayEntity> {
    fn serialize(self: @ModelWithComplexArrayEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithComplexArrayEntity> {
        core::option::Option::Some(ModelWithComplexArrayEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithComplexArrayEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithComplexArrayEntity;

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> Array<Vec3>;

    fn set_y(self: @ModelWithComplexArrayEntity, world: dojo::world::IWorldDispatcher, value: Array<Vec3>);

}
pub trait ModelWithComplexArrayStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithComplexArray;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithComplexArray;

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> Array<Vec3>;

    fn set_y(self: @ModelWithComplexArray, world: dojo::world::IWorldDispatcher, value: Array<Vec3>);
            
}
pub trait Imodel_with_complex_arrayDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithComplexArray);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arrayDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arrayDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arrayLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arrayLibraryDispatcherImpl of Imodel_with_complex_arrayDispatcherTrait<Imodel_with_complex_arrayLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arrayLibraryDispatcher, model: ModelWithComplexArray) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_complex_arraySafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithComplexArray) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arraySafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_complex_arraySafeLibraryDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeLibraryDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_complex_arraySafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_complex_arraySafeDispatcherImpl of Imodel_with_complex_arraySafeDispatcherTrait<Imodel_with_complex_arraySafeDispatcher> {
    fn ensure_abi(self: Imodel_with_complex_arraySafeDispatcher, model: ModelWithComplexArray) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithComplexArray>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithTupleEntityDrop of core::traits::Drop::<ModelWithTupleEntity>;
impl ModelWithTupleEntitySerde of core::serde::Serde::<ModelWithTupleEntity> {
    fn serialize(self: @ModelWithTupleEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleEntity> {
        core::option::Option::Some(ModelWithTupleEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithTupleEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleEntity;

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, u16, u32);

    fn set_y(self: @ModelWithTupleEntity, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32));

}
pub trait ModelWithTupleStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTuple;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTuple;

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, u16, u32);

    fn set_y(self: @ModelWithTuple, world: dojo::world::IWorldDispatcher, value: (u8, u16, u32));
            
}
pub trait Imodel_with_tupleDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTuple);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleLibraryDispatcherImpl of Imodel_with_tupleDispatcherTrait<Imodel_with_tupleLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleLibraryDispatcher, model: ModelWithTuple) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_tupleSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTuple) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tupleSafeLibraryDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeLibraryDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tupleSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tupleSafeDispatcherImpl of Imodel_with_tupleSafeDispatcherTrait<Imodel_with_tupleSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tupleSafeDispatcher, model: ModelWithTuple) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTuple>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ModelWithTupleNoPrimitivesEntityDrop of core::traits::Drop::<ModelWithTupleNoPrimitivesEntity>;
impl ModelWithTupleNoPrimitivesEntitySerde of core::serde::Serde::<ModelWithTupleNoPrimitivesEntity> {
    fn serialize(self: @ModelWithTupleNoPrimitivesEntity, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.__id, ref output);
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<ModelWithTupleNoPrimitivesEntity> {
        core::option::Option::Some(ModelWithTupleNoPrimitivesEntity {
            __id: core::serde::Serde::deserialize(ref serialized)?,
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
pub trait ModelWithTupleNoPrimitivesEntityStore {
    fn get(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> ModelWithTupleNoPrimitivesEntity;

    
    fn get_x(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> u16;

    fn set_x(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: u16);

    fn get_y(world: dojo::world::IWorldDispatcher, entity_id: felt252) -> (u8, Vec3, u32);

    fn set_y(self: @ModelWithTupleNoPrimitivesEntity, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32));

}
pub trait ModelWithTupleNoPrimitivesStore {
    fn entity_id_from_keys(player: ContractAddress) -> felt252;

    fn from_values(ref keys: Span<felt252>, ref values: Span<felt252>) -> ModelWithTupleNoPrimitives;

    fn get(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> ModelWithTupleNoPrimitives;

    
    fn get_x(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> u16;

    fn set_x(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: u16);
            
    fn get_y(world: dojo::world::IWorldDispatcher, player: ContractAddress) -> (u8, Vec3, u32);

    fn set_y(self: @ModelWithTupleNoPrimitives, world: dojo::world::IWorldDispatcher, value: (u8, Vec3, u32));
            
}
pub trait Imodel_with_tuple_no_primitivesDispatcherTrait<T> {
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesDispatcherTrait<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesLibraryDispatcher, model: ModelWithTupleNoPrimitives) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

pub trait Imodel_with_tuple_no_primitivesSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
    fn ensure_abi(self: T, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct Imodel_with_tuple_no_primitivesSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl Imodel_with_tuple_no_primitivesSafeDispatcherImpl of Imodel_with_tuple_no_primitivesSafeDispatcherTrait<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn ensure_abi(self: Imodel_with_tuple_no_primitivesSafeDispatcher, model: ModelWithTupleNoPrimitives) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ModelWithTupleNoPrimitives>::serialize(@model, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("ensure_abi"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl Ibad_model_multiple_versionsDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcher>;
impl Ibad_model_multiple_versionsDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsDispatcher of starknet::Store::<Ibad_model_multiple_versionsDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_multiple_versionsDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_multiple_versionsDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsDispatcher> {
type SubPointersType = Ibad_model_multiple_versionsDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsDispatcher>) -> Ibad_model_multiple_versionsDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_multiple_versionsDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_multiple_versionsDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_multiple_versionsDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_multiple_versionsDispatcher> {
type SubPointersType = MutableIbad_model_multiple_versionsDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsDispatcher>>) -> MutableIbad_model_multiple_versionsDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_multiple_versionsDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_multiple_versionsLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcher>;
impl Ibad_model_multiple_versionsLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsLibraryDispatcher> {
type SubPointersType = Ibad_model_multiple_versionsLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsLibraryDispatcher>) -> Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_multiple_versionsLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_multiple_versionsLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_multiple_versionsLibraryDispatcher> {
type SubPointersType = MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsLibraryDispatcher>>) -> MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcher>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeLibraryDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsSafeLibraryDispatcher>) -> Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_multiple_versionsSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsSafeLibraryDispatcher>>) -> MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_multiple_versionsSafeDispatcherCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcher>;
impl Ibad_model_multiple_versionsSafeDispatcherSerde of core::serde::Serde::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn serialize(self: @Ibad_model_multiple_versionsSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_multiple_versionsSafeDispatcher> {
        core::option::Option::Some(Ibad_model_multiple_versionsSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_multiple_versionsSafeDispatcher of starknet::Store::<Ibad_model_multiple_versionsSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_multiple_versionsSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_multiple_versionsSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_multiple_versionsSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_multiple_versionsSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_multiple_versionsSafeDispatcher> {
type SubPointersType = Ibad_model_multiple_versionsSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_multiple_versionsSafeDispatcher>) -> Ibad_model_multiple_versionsSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_multiple_versionsSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_multiple_versionsSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_multiple_versionsSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_multiple_versionsSafeDispatcher> {
type SubPointersType = MutableIbad_model_multiple_versionsSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_multiple_versionsSafeDispatcher>>) -> MutableIbad_model_multiple_versionsSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_multiple_versionsSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_bad_version_typeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcher>;
impl Ibad_model_bad_version_typeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeDispatcher of starknet::Store::<Ibad_model_bad_version_typeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_bad_version_typeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_bad_version_typeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeDispatcher> {
type SubPointersType = Ibad_model_bad_version_typeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeDispatcher>) -> Ibad_model_bad_version_typeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_bad_version_typeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_bad_version_typeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_bad_version_typeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_bad_version_typeDispatcher> {
type SubPointersType = MutableIbad_model_bad_version_typeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeDispatcher>>) -> MutableIbad_model_bad_version_typeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_bad_version_typeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_bad_version_typeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcher>;
impl Ibad_model_bad_version_typeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeLibraryDispatcher> {
type SubPointersType = Ibad_model_bad_version_typeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeLibraryDispatcher>) -> Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_bad_version_typeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_bad_version_typeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_bad_version_typeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeLibraryDispatcher>>) -> MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcher>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeLibraryDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeSafeLibraryDispatcher>) -> Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_bad_version_typeSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeSafeLibraryDispatcher>>) -> MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_bad_version_typeSafeDispatcherCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcher>;
impl Ibad_model_bad_version_typeSafeDispatcherSerde of core::serde::Serde::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn serialize(self: @Ibad_model_bad_version_typeSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_bad_version_typeSafeDispatcher> {
        core::option::Option::Some(Ibad_model_bad_version_typeSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_bad_version_typeSafeDispatcher of starknet::Store::<Ibad_model_bad_version_typeSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_bad_version_typeSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_bad_version_typeSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_bad_version_typeSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_bad_version_typeSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_bad_version_typeSafeDispatcher> {
type SubPointersType = Ibad_model_bad_version_typeSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_bad_version_typeSafeDispatcher>) -> Ibad_model_bad_version_typeSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_bad_version_typeSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_bad_version_typeSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_bad_version_typeSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_bad_version_typeSafeDispatcher> {
type SubPointersType = MutableIbad_model_bad_version_typeSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_bad_version_typeSafeDispatcher>>) -> MutableIbad_model_bad_version_typeSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_bad_version_typeSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_no_version_valueDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcher>;
impl Ibad_model_no_version_valueDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueDispatcher of starknet::Store::<Ibad_model_no_version_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_no_version_valueDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_no_version_valueDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueDispatcher> {
type SubPointersType = Ibad_model_no_version_valueDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueDispatcher>) -> Ibad_model_no_version_valueDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_no_version_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_no_version_valueDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_no_version_valueDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_no_version_valueDispatcher> {
type SubPointersType = MutableIbad_model_no_version_valueDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueDispatcher>>) -> MutableIbad_model_no_version_valueDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_no_version_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_no_version_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcher>;
impl Ibad_model_no_version_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_no_version_valueLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueLibraryDispatcher> {
type SubPointersType = Ibad_model_no_version_valueLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueLibraryDispatcher>) -> Ibad_model_no_version_valueLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_no_version_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_no_version_valueLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_no_version_valueLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_no_version_valueLibraryDispatcher> {
type SubPointersType = MutableIbad_model_no_version_valueLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueLibraryDispatcher>>) -> MutableIbad_model_no_version_valueLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_no_version_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_no_version_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcher>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueSafeLibraryDispatcher>) -> Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_no_version_valueSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueSafeLibraryDispatcher>>) -> MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_no_version_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcher>;
impl Ibad_model_no_version_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_no_version_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_no_version_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_no_version_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_no_version_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_no_version_valueSafeDispatcher of starknet::Store::<Ibad_model_no_version_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_no_version_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_no_version_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_no_version_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_no_version_valueSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_no_version_valueSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_no_version_valueSafeDispatcher> {
type SubPointersType = Ibad_model_no_version_valueSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_no_version_valueSafeDispatcher>) -> Ibad_model_no_version_valueSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_no_version_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_no_version_valueSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_no_version_valueSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_no_version_valueSafeDispatcher> {
type SubPointersType = MutableIbad_model_no_version_valueSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_no_version_valueSafeDispatcher>>) -> MutableIbad_model_no_version_valueSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_no_version_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcher>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueDispatcher> {
type SubPointersType = Ibad_model_unexpected_arg_with_valueDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueDispatcher>) -> Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_arg_with_valueDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueDispatcher>>) -> MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
type SubPointersType = Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>) -> Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_arg_with_valueLibraryDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueLibraryDispatcher>>) -> MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>) -> Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcher>>) -> MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_arg_with_valueSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_arg_with_valueSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_arg_with_valueSafeDispatcher of starknet::Store::<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_arg_with_valueSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_arg_with_valueSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
type SubPointersType = Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_arg_with_valueSafeDispatcher>) -> Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_arg_with_valueSafeDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_arg_with_valueSafeDispatcher>>) -> MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_argDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcher>;
impl Ibad_model_unexpected_argDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argDispatcher of starknet::Store::<Ibad_model_unexpected_argDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_argDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_argDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argDispatcher> {
type SubPointersType = Ibad_model_unexpected_argDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argDispatcher>) -> Ibad_model_unexpected_argDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_argDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_argDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_unexpected_argDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_argDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_argDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argDispatcher>>) -> MutableIbad_model_unexpected_argDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_argDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_unexpected_argLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcher>;
impl Ibad_model_unexpected_argLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_argLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argLibraryDispatcher> {
type SubPointersType = Ibad_model_unexpected_argLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argLibraryDispatcher>) -> Ibad_model_unexpected_argLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_argLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_argLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_unexpected_argLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_argLibraryDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_argLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argLibraryDispatcher>>) -> MutableIbad_model_unexpected_argLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_argLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_argSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcher>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeLibraryDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argSafeLibraryDispatcher>) -> Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_argSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argSafeLibraryDispatcher>>) -> MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_unexpected_argSafeDispatcherCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcher>;
impl Ibad_model_unexpected_argSafeDispatcherSerde of core::serde::Serde::<Ibad_model_unexpected_argSafeDispatcher> {
    fn serialize(self: @Ibad_model_unexpected_argSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_unexpected_argSafeDispatcher> {
        core::option::Option::Some(Ibad_model_unexpected_argSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_unexpected_argSafeDispatcher of starknet::Store::<Ibad_model_unexpected_argSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_unexpected_argSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_unexpected_argSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_unexpected_argSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_unexpected_argSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_unexpected_argSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_unexpected_argSafeDispatcher> {
type SubPointersType = Ibad_model_unexpected_argSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_unexpected_argSafeDispatcher>) -> Ibad_model_unexpected_argSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_unexpected_argSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_unexpected_argSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_unexpected_argSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_unexpected_argSafeDispatcher> {
type SubPointersType = MutableIbad_model_unexpected_argSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_unexpected_argSafeDispatcher>>) -> MutableIbad_model_unexpected_argSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_unexpected_argSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_not_supported_versionDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcher>;
impl Ibad_model_not_supported_versionDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionDispatcher of starknet::Store::<Ibad_model_not_supported_versionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_not_supported_versionDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_not_supported_versionDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionDispatcher> {
type SubPointersType = Ibad_model_not_supported_versionDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionDispatcher>) -> Ibad_model_not_supported_versionDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_not_supported_versionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_not_supported_versionDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_not_supported_versionDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_not_supported_versionDispatcher> {
type SubPointersType = MutableIbad_model_not_supported_versionDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionDispatcher>>) -> MutableIbad_model_not_supported_versionDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_not_supported_versionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_not_supported_versionLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcher>;
impl Ibad_model_not_supported_versionLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionLibraryDispatcher> {
type SubPointersType = Ibad_model_not_supported_versionLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionLibraryDispatcher>) -> Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_not_supported_versionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_not_supported_versionLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_not_supported_versionLibraryDispatcher> {
type SubPointersType = MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionLibraryDispatcher>>) -> MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcher>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeLibraryDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
type SubPointersType = Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionSafeLibraryDispatcher>) -> Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_not_supported_versionSafeLibraryDispatcher> {
type SubPointersType = MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionSafeLibraryDispatcher>>) -> MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ibad_model_not_supported_versionSafeDispatcherCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcher>;
impl Ibad_model_not_supported_versionSafeDispatcherSerde of core::serde::Serde::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn serialize(self: @Ibad_model_not_supported_versionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ibad_model_not_supported_versionSafeDispatcher> {
        core::option::Option::Some(Ibad_model_not_supported_versionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIbad_model_not_supported_versionSafeDispatcher of starknet::Store::<Ibad_model_not_supported_versionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ibad_model_not_supported_versionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ibad_model_not_supported_versionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ibad_model_not_supported_versionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ibad_model_not_supported_versionSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ibad_model_not_supported_versionSafeDispatcher> {
type SubPointersType = Ibad_model_not_supported_versionSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ibad_model_not_supported_versionSafeDispatcher>) -> Ibad_model_not_supported_versionSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ibad_model_not_supported_versionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIbad_model_not_supported_versionSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIbad_model_not_supported_versionSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ibad_model_not_supported_versionSafeDispatcher> {
type SubPointersType = MutableIbad_model_not_supported_versionSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ibad_model_not_supported_versionSafeDispatcher>>) -> MutableIbad_model_not_supported_versionSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIbad_model_not_supported_versionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodelv_0DispatcherCopy of core::traits::Copy::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherDrop of core::traits::Drop::<Imodelv_0Dispatcher>;
impl Imodelv_0DispatcherSerde of core::serde::Serde::<Imodelv_0Dispatcher> {
    fn serialize(self: @Imodelv_0Dispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0Dispatcher> {
        core::option::Option::Some(Imodelv_0Dispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0Dispatcher of starknet::Store::<Imodelv_0Dispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0Dispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0Dispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0Dispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodelv_0DispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodelv_0DispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0Dispatcher> {
type SubPointersType = Imodelv_0DispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0Dispatcher>) -> Imodelv_0DispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodelv_0DispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodelv_0DispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodelv_0DispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodelv_0Dispatcher> {
type SubPointersType = MutableImodelv_0DispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0Dispatcher>>) -> MutableImodelv_0DispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodelv_0DispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodelv_0LibraryDispatcherCopy of core::traits::Copy::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherDrop of core::traits::Drop::<Imodelv_0LibraryDispatcher>;
impl Imodelv_0LibraryDispatcherSerde of core::serde::Serde::<Imodelv_0LibraryDispatcher> {
    fn serialize(self: @Imodelv_0LibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0LibraryDispatcher> {
        core::option::Option::Some(Imodelv_0LibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0LibraryDispatcher of starknet::Store::<Imodelv_0LibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0LibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0LibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0LibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodelv_0LibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodelv_0LibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0LibraryDispatcher> {
type SubPointersType = Imodelv_0LibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0LibraryDispatcher>) -> Imodelv_0LibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodelv_0LibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodelv_0LibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodelv_0LibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodelv_0LibraryDispatcher> {
type SubPointersType = MutableImodelv_0LibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0LibraryDispatcher>>) -> MutableImodelv_0LibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodelv_0LibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodelv_0SafeLibraryDispatcherCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcher>;
impl Imodelv_0SafeLibraryDispatcherSerde of core::serde::Serde::<Imodelv_0SafeLibraryDispatcher> {
    fn serialize(self: @Imodelv_0SafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeLibraryDispatcher> {
        core::option::Option::Some(Imodelv_0SafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeLibraryDispatcher of starknet::Store::<Imodelv_0SafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodelv_0SafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodelv_0SafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0SafeLibraryDispatcher> {
type SubPointersType = Imodelv_0SafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0SafeLibraryDispatcher>) -> Imodelv_0SafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodelv_0SafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodelv_0SafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodelv_0SafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodelv_0SafeLibraryDispatcher> {
type SubPointersType = MutableImodelv_0SafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0SafeLibraryDispatcher>>) -> MutableImodelv_0SafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodelv_0SafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodelv_0SafeDispatcherCopy of core::traits::Copy::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherDrop of core::traits::Drop::<Imodelv_0SafeDispatcher>;
impl Imodelv_0SafeDispatcherSerde of core::serde::Serde::<Imodelv_0SafeDispatcher> {
    fn serialize(self: @Imodelv_0SafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodelv_0SafeDispatcher> {
        core::option::Option::Some(Imodelv_0SafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodelv_0SafeDispatcher of starknet::Store::<Imodelv_0SafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodelv_0SafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodelv_0SafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodelv_0SafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodelv_0SafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodelv_0SafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodelv_0SafeDispatcher> {
type SubPointersType = Imodelv_0SafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodelv_0SafeDispatcher>) -> Imodelv_0SafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodelv_0SafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodelv_0SafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodelv_0SafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodelv_0SafeDispatcher> {
type SubPointersType = MutableImodelv_0SafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodelv_0SafeDispatcher>>) -> MutableImodelv_0SafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodelv_0SafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcher>;
impl Imodel_with_bad_namespace_formatDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_bad_namespace_formatDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_bad_namespace_formatDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatDispatcher> {
type SubPointersType = Imodel_with_bad_namespace_formatDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatDispatcher>) -> Imodel_with_bad_namespace_formatDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_bad_namespace_formatDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_bad_namespace_formatDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_bad_namespace_formatDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_bad_namespace_formatDispatcher> {
type SubPointersType = MutableImodel_with_bad_namespace_formatDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatDispatcher>>) -> MutableImodel_with_bad_namespace_formatDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_bad_namespace_formatDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatLibraryDispatcher> {
type SubPointersType = Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatLibraryDispatcher>) -> Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_bad_namespace_formatLibraryDispatcher> {
type SubPointersType = MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatLibraryDispatcher>>) -> MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeLibraryDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
type SubPointersType = Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>) -> Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_bad_namespace_formatSafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatSafeLibraryDispatcher>>) -> MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_bad_namespace_formatSafeDispatcherCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcher>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSerde of core::serde::Serde::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn serialize(self: @Imodel_with_bad_namespace_formatSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_bad_namespace_formatSafeDispatcher> {
        core::option::Option::Some(Imodel_with_bad_namespace_formatSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_bad_namespace_formatSafeDispatcher of starknet::Store::<Imodel_with_bad_namespace_formatSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_bad_namespace_formatSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_bad_namespace_formatSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_bad_namespace_formatSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_bad_namespace_formatSafeDispatcher> {
type SubPointersType = Imodel_with_bad_namespace_formatSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_bad_namespace_formatSafeDispatcher>) -> Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_bad_namespace_formatSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_bad_namespace_formatSafeDispatcher> {
type SubPointersType = MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_bad_namespace_formatSafeDispatcher>>) -> MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_short_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcher>;
impl Imodel_with_short_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceDispatcher of starknet::Store::<Imodel_with_short_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_short_string_namespaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_short_string_namespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceDispatcher> {
type SubPointersType = Imodel_with_short_string_namespaceDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceDispatcher>) -> Imodel_with_short_string_namespaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_short_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_short_string_namespaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_short_string_namespaceDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_short_string_namespaceDispatcher> {
type SubPointersType = MutableImodel_with_short_string_namespaceDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceDispatcher>>) -> MutableImodel_with_short_string_namespaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_short_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_short_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcher>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceLibraryDispatcher> {
type SubPointersType = Imodel_with_short_string_namespaceLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceLibraryDispatcher>) -> Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_short_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_short_string_namespaceLibraryDispatcher> {
type SubPointersType = MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceLibraryDispatcher>>) -> MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
type SubPointersType = Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceSafeLibraryDispatcher>) -> Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_short_string_namespaceSafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceSafeLibraryDispatcher>>) -> MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_short_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcher>;
impl Imodel_with_short_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_short_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_short_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_short_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_short_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_short_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_short_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_short_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_short_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_short_string_namespaceSafeDispatcher> {
type SubPointersType = Imodel_with_short_string_namespaceSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_short_string_namespaceSafeDispatcher>) -> Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_short_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_short_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_short_string_namespaceSafeDispatcher> {
type SubPointersType = MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_short_string_namespaceSafeDispatcher>>) -> MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_string_namespaceDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcher>;
impl Imodel_with_string_namespaceDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceDispatcher of starknet::Store::<Imodel_with_string_namespaceDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_string_namespaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_string_namespaceDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceDispatcher> {
type SubPointersType = Imodel_with_string_namespaceDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceDispatcher>) -> Imodel_with_string_namespaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_string_namespaceDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_string_namespaceDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_string_namespaceDispatcher> {
type SubPointersType = MutableImodel_with_string_namespaceDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceDispatcher>>) -> MutableImodel_with_string_namespaceDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_string_namespaceDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_string_namespaceLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcher>;
impl Imodel_with_string_namespaceLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_string_namespaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceLibraryDispatcher> {
type SubPointersType = Imodel_with_string_namespaceLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceLibraryDispatcher>) -> Imodel_with_string_namespaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_string_namespaceLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_string_namespaceLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_string_namespaceLibraryDispatcher> {
type SubPointersType = MutableImodel_with_string_namespaceLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceLibraryDispatcher>>) -> MutableImodel_with_string_namespaceLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_string_namespaceLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_string_namespaceSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcher>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeLibraryDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceSafeLibraryDispatcher> {
type SubPointersType = Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceSafeLibraryDispatcher>) -> Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_string_namespaceSafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceSafeLibraryDispatcher>>) -> MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_string_namespaceSafeDispatcherCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcher>;
impl Imodel_with_string_namespaceSafeDispatcherSerde of core::serde::Serde::<Imodel_with_string_namespaceSafeDispatcher> {
    fn serialize(self: @Imodel_with_string_namespaceSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_string_namespaceSafeDispatcher> {
        core::option::Option::Some(Imodel_with_string_namespaceSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_string_namespaceSafeDispatcher of starknet::Store::<Imodel_with_string_namespaceSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_string_namespaceSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_string_namespaceSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_string_namespaceSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_string_namespaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_string_namespaceSafeDispatcher> {
type SubPointersType = Imodel_with_string_namespaceSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_string_namespaceSafeDispatcher>) -> Imodel_with_string_namespaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_string_namespaceSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_string_namespaceSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_string_namespaceSafeDispatcher> {
type SubPointersType = MutableImodel_with_string_namespaceSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_string_namespaceSafeDispatcher>>) -> MutableImodel_with_string_namespaceSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_string_namespaceSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IpositionDispatcherCopy of core::traits::Copy::<IpositionDispatcher>;
impl IpositionDispatcherDrop of core::traits::Drop::<IpositionDispatcher>;
impl IpositionDispatcherSerde of core::serde::Serde::<IpositionDispatcher> {
    fn serialize(self: @IpositionDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionDispatcher> {
        core::option::Option::Some(IpositionDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionDispatcher of starknet::Store::<IpositionDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IpositionDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IpositionDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionDispatcher> {
type SubPointersType = IpositionDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IpositionDispatcher>) -> IpositionDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IpositionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIpositionDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIpositionDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IpositionDispatcher> {
type SubPointersType = MutableIpositionDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionDispatcher>>) -> MutableIpositionDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIpositionDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IpositionLibraryDispatcherCopy of core::traits::Copy::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherDrop of core::traits::Drop::<IpositionLibraryDispatcher>;
impl IpositionLibraryDispatcherSerde of core::serde::Serde::<IpositionLibraryDispatcher> {
    fn serialize(self: @IpositionLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionLibraryDispatcher> {
        core::option::Option::Some(IpositionLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionLibraryDispatcher of starknet::Store::<IpositionLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IpositionLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IpositionLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionLibraryDispatcher> {
type SubPointersType = IpositionLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IpositionLibraryDispatcher>) -> IpositionLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IpositionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIpositionLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIpositionLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IpositionLibraryDispatcher> {
type SubPointersType = MutableIpositionLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionLibraryDispatcher>>) -> MutableIpositionLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIpositionLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IpositionSafeLibraryDispatcherCopy of core::traits::Copy::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherDrop of core::traits::Drop::<IpositionSafeLibraryDispatcher>;
impl IpositionSafeLibraryDispatcherSerde of core::serde::Serde::<IpositionSafeLibraryDispatcher> {
    fn serialize(self: @IpositionSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeLibraryDispatcher> {
        core::option::Option::Some(IpositionSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeLibraryDispatcher of starknet::Store::<IpositionSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IpositionSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IpositionSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionSafeLibraryDispatcher> {
type SubPointersType = IpositionSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IpositionSafeLibraryDispatcher>) -> IpositionSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IpositionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIpositionSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIpositionSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IpositionSafeLibraryDispatcher> {
type SubPointersType = MutableIpositionSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionSafeLibraryDispatcher>>) -> MutableIpositionSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIpositionSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IpositionSafeDispatcherCopy of core::traits::Copy::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherDrop of core::traits::Drop::<IpositionSafeDispatcher>;
impl IpositionSafeDispatcherSerde of core::serde::Serde::<IpositionSafeDispatcher> {
    fn serialize(self: @IpositionSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IpositionSafeDispatcher> {
        core::option::Option::Some(IpositionSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIpositionSafeDispatcher of starknet::Store::<IpositionSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IpositionSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IpositionSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IpositionSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IpositionSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IpositionSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IpositionSafeDispatcher> {
type SubPointersType = IpositionSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IpositionSafeDispatcher>) -> IpositionSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IpositionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIpositionSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIpositionSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IpositionSafeDispatcher> {
type SubPointersType = MutableIpositionSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IpositionSafeDispatcher>>) -> MutableIpositionSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIpositionSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IrolesDispatcherCopy of core::traits::Copy::<IrolesDispatcher>;
impl IrolesDispatcherDrop of core::traits::Drop::<IrolesDispatcher>;
impl IrolesDispatcherSerde of core::serde::Serde::<IrolesDispatcher> {
    fn serialize(self: @IrolesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesDispatcher> {
        core::option::Option::Some(IrolesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesDispatcher of starknet::Store::<IrolesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IrolesDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IrolesDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesDispatcher> {
type SubPointersType = IrolesDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IrolesDispatcher>) -> IrolesDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IrolesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIrolesDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIrolesDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IrolesDispatcher> {
type SubPointersType = MutableIrolesDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesDispatcher>>) -> MutableIrolesDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIrolesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IrolesLibraryDispatcherCopy of core::traits::Copy::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherDrop of core::traits::Drop::<IrolesLibraryDispatcher>;
impl IrolesLibraryDispatcherSerde of core::serde::Serde::<IrolesLibraryDispatcher> {
    fn serialize(self: @IrolesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesLibraryDispatcher> {
        core::option::Option::Some(IrolesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesLibraryDispatcher of starknet::Store::<IrolesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IrolesLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IrolesLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesLibraryDispatcher> {
type SubPointersType = IrolesLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IrolesLibraryDispatcher>) -> IrolesLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IrolesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIrolesLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIrolesLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IrolesLibraryDispatcher> {
type SubPointersType = MutableIrolesLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesLibraryDispatcher>>) -> MutableIrolesLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIrolesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IrolesSafeLibraryDispatcherCopy of core::traits::Copy::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherDrop of core::traits::Drop::<IrolesSafeLibraryDispatcher>;
impl IrolesSafeLibraryDispatcherSerde of core::serde::Serde::<IrolesSafeLibraryDispatcher> {
    fn serialize(self: @IrolesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeLibraryDispatcher> {
        core::option::Option::Some(IrolesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeLibraryDispatcher of starknet::Store::<IrolesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IrolesSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IrolesSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesSafeLibraryDispatcher> {
type SubPointersType = IrolesSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IrolesSafeLibraryDispatcher>) -> IrolesSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IrolesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIrolesSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIrolesSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IrolesSafeLibraryDispatcher> {
type SubPointersType = MutableIrolesSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesSafeLibraryDispatcher>>) -> MutableIrolesSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIrolesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IrolesSafeDispatcherCopy of core::traits::Copy::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherDrop of core::traits::Drop::<IrolesSafeDispatcher>;
impl IrolesSafeDispatcherSerde of core::serde::Serde::<IrolesSafeDispatcher> {
    fn serialize(self: @IrolesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IrolesSafeDispatcher> {
        core::option::Option::Some(IrolesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIrolesSafeDispatcher of starknet::Store::<IrolesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IrolesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IrolesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IrolesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IrolesSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IrolesSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IrolesSafeDispatcher> {
type SubPointersType = IrolesSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IrolesSafeDispatcher>) -> IrolesSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IrolesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIrolesSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIrolesSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IrolesSafeDispatcher> {
type SubPointersType = MutableIrolesSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IrolesSafeDispatcher>>) -> MutableIrolesSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIrolesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ionly_key_modelDispatcherCopy of core::traits::Copy::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherDrop of core::traits::Drop::<Ionly_key_modelDispatcher>;
impl Ionly_key_modelDispatcherSerde of core::serde::Serde::<Ionly_key_modelDispatcher> {
    fn serialize(self: @Ionly_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelDispatcher> {
        core::option::Option::Some(Ionly_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelDispatcher of starknet::Store::<Ionly_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ionly_key_modelDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ionly_key_modelDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelDispatcher> {
type SubPointersType = Ionly_key_modelDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelDispatcher>) -> Ionly_key_modelDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ionly_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIonly_key_modelDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIonly_key_modelDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ionly_key_modelDispatcher> {
type SubPointersType = MutableIonly_key_modelDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelDispatcher>>) -> MutableIonly_key_modelDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIonly_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ionly_key_modelLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcher>;
impl Ionly_key_modelLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelLibraryDispatcher of starknet::Store::<Ionly_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ionly_key_modelLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ionly_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelLibraryDispatcher> {
type SubPointersType = Ionly_key_modelLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelLibraryDispatcher>) -> Ionly_key_modelLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ionly_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIonly_key_modelLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIonly_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ionly_key_modelLibraryDispatcher> {
type SubPointersType = MutableIonly_key_modelLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelLibraryDispatcher>>) -> MutableIonly_key_modelLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIonly_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ionly_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcher>;
impl Ionly_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeLibraryDispatcher of starknet::Store::<Ionly_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Ionly_key_modelSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Ionly_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelSafeLibraryDispatcher> {
type SubPointersType = Ionly_key_modelSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelSafeLibraryDispatcher>) -> Ionly_key_modelSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ionly_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIonly_key_modelSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIonly_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ionly_key_modelSafeLibraryDispatcher> {
type SubPointersType = MutableIonly_key_modelSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelSafeLibraryDispatcher>>) -> MutableIonly_key_modelSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIonly_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Ionly_key_modelSafeDispatcherCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcher>;
impl Ionly_key_modelSafeDispatcherSerde of core::serde::Serde::<Ionly_key_modelSafeDispatcher> {
    fn serialize(self: @Ionly_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Ionly_key_modelSafeDispatcher> {
        core::option::Option::Some(Ionly_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIonly_key_modelSafeDispatcher of starknet::Store::<Ionly_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Ionly_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Ionly_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Ionly_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Ionly_key_modelSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Ionly_key_modelSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Ionly_key_modelSafeDispatcher> {
type SubPointersType = Ionly_key_modelSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Ionly_key_modelSafeDispatcher>) -> Ionly_key_modelSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Ionly_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIonly_key_modelSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIonly_key_modelSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Ionly_key_modelSafeDispatcher> {
type SubPointersType = MutableIonly_key_modelSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Ionly_key_modelSafeDispatcher>>) -> MutableIonly_key_modelSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIonly_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Iu_256_key_modelDispatcherCopy of core::traits::Copy::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherDrop of core::traits::Drop::<Iu_256_key_modelDispatcher>;
impl Iu_256_key_modelDispatcherSerde of core::serde::Serde::<Iu_256_key_modelDispatcher> {
    fn serialize(self: @Iu_256_key_modelDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelDispatcher> {
        core::option::Option::Some(Iu_256_key_modelDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelDispatcher of starknet::Store::<Iu_256_key_modelDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Iu_256_key_modelDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Iu_256_key_modelDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelDispatcher> {
type SubPointersType = Iu_256_key_modelDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelDispatcher>) -> Iu_256_key_modelDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Iu_256_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIu_256_key_modelDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIu_256_key_modelDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Iu_256_key_modelDispatcher> {
type SubPointersType = MutableIu_256_key_modelDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelDispatcher>>) -> MutableIu_256_key_modelDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIu_256_key_modelDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Iu_256_key_modelLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcher>;
impl Iu_256_key_modelLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelLibraryDispatcher of starknet::Store::<Iu_256_key_modelLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Iu_256_key_modelLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Iu_256_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelLibraryDispatcher> {
type SubPointersType = Iu_256_key_modelLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelLibraryDispatcher>) -> Iu_256_key_modelLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Iu_256_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIu_256_key_modelLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIu_256_key_modelLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Iu_256_key_modelLibraryDispatcher> {
type SubPointersType = MutableIu_256_key_modelLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelLibraryDispatcher>>) -> MutableIu_256_key_modelLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIu_256_key_modelLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Iu_256_key_modelSafeLibraryDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcher>;
impl Iu_256_key_modelSafeLibraryDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeLibraryDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeLibraryDispatcher of starknet::Store::<Iu_256_key_modelSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Iu_256_key_modelSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelSafeLibraryDispatcher> {
type SubPointersType = Iu_256_key_modelSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelSafeLibraryDispatcher>) -> Iu_256_key_modelSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Iu_256_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIu_256_key_modelSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIu_256_key_modelSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Iu_256_key_modelSafeLibraryDispatcher> {
type SubPointersType = MutableIu_256_key_modelSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelSafeLibraryDispatcher>>) -> MutableIu_256_key_modelSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIu_256_key_modelSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Iu_256_key_modelSafeDispatcherCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcher>;
impl Iu_256_key_modelSafeDispatcherSerde of core::serde::Serde::<Iu_256_key_modelSafeDispatcher> {
    fn serialize(self: @Iu_256_key_modelSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Iu_256_key_modelSafeDispatcher> {
        core::option::Option::Some(Iu_256_key_modelSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIu_256_key_modelSafeDispatcher of starknet::Store::<Iu_256_key_modelSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Iu_256_key_modelSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Iu_256_key_modelSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Iu_256_key_modelSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Iu_256_key_modelSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Iu_256_key_modelSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Iu_256_key_modelSafeDispatcher> {
type SubPointersType = Iu_256_key_modelSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Iu_256_key_modelSafeDispatcher>) -> Iu_256_key_modelSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Iu_256_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIu_256_key_modelSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIu_256_key_modelSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Iu_256_key_modelSafeDispatcher> {
type SubPointersType = MutableIu_256_key_modelSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Iu_256_key_modelSafeDispatcher>>) -> MutableIu_256_key_modelSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIu_256_key_modelSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IplayerDispatcherCopy of core::traits::Copy::<IplayerDispatcher>;
impl IplayerDispatcherDrop of core::traits::Drop::<IplayerDispatcher>;
impl IplayerDispatcherSerde of core::serde::Serde::<IplayerDispatcher> {
    fn serialize(self: @IplayerDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerDispatcher> {
        core::option::Option::Some(IplayerDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerDispatcher of starknet::Store::<IplayerDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IplayerDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IplayerDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerDispatcher> {
type SubPointersType = IplayerDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IplayerDispatcher>) -> IplayerDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IplayerDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIplayerDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIplayerDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IplayerDispatcher> {
type SubPointersType = MutableIplayerDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerDispatcher>>) -> MutableIplayerDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIplayerDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IplayerLibraryDispatcherCopy of core::traits::Copy::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherDrop of core::traits::Drop::<IplayerLibraryDispatcher>;
impl IplayerLibraryDispatcherSerde of core::serde::Serde::<IplayerLibraryDispatcher> {
    fn serialize(self: @IplayerLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerLibraryDispatcher> {
        core::option::Option::Some(IplayerLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerLibraryDispatcher of starknet::Store::<IplayerLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IplayerLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IplayerLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerLibraryDispatcher> {
type SubPointersType = IplayerLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IplayerLibraryDispatcher>) -> IplayerLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IplayerLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIplayerLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIplayerLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IplayerLibraryDispatcher> {
type SubPointersType = MutableIplayerLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerLibraryDispatcher>>) -> MutableIplayerLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIplayerLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IplayerSafeLibraryDispatcherCopy of core::traits::Copy::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherDrop of core::traits::Drop::<IplayerSafeLibraryDispatcher>;
impl IplayerSafeLibraryDispatcherSerde of core::serde::Serde::<IplayerSafeLibraryDispatcher> {
    fn serialize(self: @IplayerSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeLibraryDispatcher> {
        core::option::Option::Some(IplayerSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeLibraryDispatcher of starknet::Store::<IplayerSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IplayerSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IplayerSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerSafeLibraryDispatcher> {
type SubPointersType = IplayerSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IplayerSafeLibraryDispatcher>) -> IplayerSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IplayerSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIplayerSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIplayerSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IplayerSafeLibraryDispatcher> {
type SubPointersType = MutableIplayerSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerSafeLibraryDispatcher>>) -> MutableIplayerSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIplayerSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IplayerSafeDispatcherCopy of core::traits::Copy::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherDrop of core::traits::Drop::<IplayerSafeDispatcher>;
impl IplayerSafeDispatcherSerde of core::serde::Serde::<IplayerSafeDispatcher> {
    fn serialize(self: @IplayerSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IplayerSafeDispatcher> {
        core::option::Option::Some(IplayerSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIplayerSafeDispatcher of starknet::Store::<IplayerSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IplayerSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IplayerSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IplayerSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IplayerSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IplayerSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IplayerSafeDispatcher> {
type SubPointersType = IplayerSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IplayerSafeDispatcher>) -> IplayerSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IplayerSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIplayerSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIplayerSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IplayerSafeDispatcher> {
type SubPointersType = MutableIplayerSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IplayerSafeDispatcher>>) -> MutableIplayerSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIplayerSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_simple_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcher>;
impl Imodel_with_simple_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayDispatcher of starknet::Store::<Imodel_with_simple_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_simple_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_simple_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arrayDispatcher> {
type SubPointersType = Imodel_with_simple_arrayDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arrayDispatcher>) -> Imodel_with_simple_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_simple_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_simple_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_simple_arrayDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_simple_arrayDispatcher> {
type SubPointersType = MutableImodel_with_simple_arrayDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arrayDispatcher>>) -> MutableImodel_with_simple_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_simple_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_simple_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcher>;
impl Imodel_with_simple_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arrayLibraryDispatcher of starknet::Store::<Imodel_with_simple_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_simple_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arrayLibraryDispatcher> {
type SubPointersType = Imodel_with_simple_arrayLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arrayLibraryDispatcher>) -> Imodel_with_simple_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_simple_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_simple_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_simple_arrayLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_simple_arrayLibraryDispatcher> {
type SubPointersType = MutableImodel_with_simple_arrayLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arrayLibraryDispatcher>>) -> MutableImodel_with_simple_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_simple_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_simple_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcher>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_simple_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arraySafeLibraryDispatcher> {
type SubPointersType = Imodel_with_simple_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arraySafeLibraryDispatcher>) -> Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_simple_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_simple_arraySafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arraySafeLibraryDispatcher>>) -> MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_simple_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcher>;
impl Imodel_with_simple_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_simple_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_simple_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_simple_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_simple_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_simple_arraySafeDispatcher of starknet::Store::<Imodel_with_simple_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_simple_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_simple_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_simple_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_simple_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_simple_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_simple_arraySafeDispatcher> {
type SubPointersType = Imodel_with_simple_arraySafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_simple_arraySafeDispatcher>) -> Imodel_with_simple_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_simple_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_simple_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_simple_arraySafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_simple_arraySafeDispatcher> {
type SubPointersType = MutableImodel_with_simple_arraySafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_simple_arraySafeDispatcher>>) -> MutableImodel_with_simple_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_simple_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_byte_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcher>;
impl Imodel_with_byte_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayDispatcher of starknet::Store::<Imodel_with_byte_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_byte_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_byte_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arrayDispatcher> {
type SubPointersType = Imodel_with_byte_arrayDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arrayDispatcher>) -> Imodel_with_byte_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_byte_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_byte_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_byte_arrayDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_byte_arrayDispatcher> {
type SubPointersType = MutableImodel_with_byte_arrayDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arrayDispatcher>>) -> MutableImodel_with_byte_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_byte_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_byte_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcher>;
impl Imodel_with_byte_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arrayLibraryDispatcher of starknet::Store::<Imodel_with_byte_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_byte_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arrayLibraryDispatcher> {
type SubPointersType = Imodel_with_byte_arrayLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arrayLibraryDispatcher>) -> Imodel_with_byte_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_byte_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_byte_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_byte_arrayLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_byte_arrayLibraryDispatcher> {
type SubPointersType = MutableImodel_with_byte_arrayLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arrayLibraryDispatcher>>) -> MutableImodel_with_byte_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_byte_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_byte_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcher>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_byte_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arraySafeLibraryDispatcher> {
type SubPointersType = Imodel_with_byte_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arraySafeLibraryDispatcher>) -> Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_byte_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_byte_arraySafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arraySafeLibraryDispatcher>>) -> MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_byte_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcher>;
impl Imodel_with_byte_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_byte_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_byte_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_byte_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_byte_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_byte_arraySafeDispatcher of starknet::Store::<Imodel_with_byte_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_byte_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_byte_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_byte_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_byte_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_byte_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_byte_arraySafeDispatcher> {
type SubPointersType = Imodel_with_byte_arraySafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_byte_arraySafeDispatcher>) -> Imodel_with_byte_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_byte_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_byte_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_byte_arraySafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_byte_arraySafeDispatcher> {
type SubPointersType = MutableImodel_with_byte_arraySafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_byte_arraySafeDispatcher>>) -> MutableImodel_with_byte_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_byte_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_complex_arrayDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcher>;
impl Imodel_with_complex_arrayDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayDispatcher of starknet::Store::<Imodel_with_complex_arrayDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_complex_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_complex_arrayDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arrayDispatcher> {
type SubPointersType = Imodel_with_complex_arrayDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arrayDispatcher>) -> Imodel_with_complex_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_complex_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_complex_arrayDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_complex_arrayDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_complex_arrayDispatcher> {
type SubPointersType = MutableImodel_with_complex_arrayDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arrayDispatcher>>) -> MutableImodel_with_complex_arrayDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_complex_arrayDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_complex_arrayLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcher>;
impl Imodel_with_complex_arrayLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arrayLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arrayLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arrayLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arrayLibraryDispatcher of starknet::Store::<Imodel_with_complex_arrayLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arrayLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arrayLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arrayLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_complex_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arrayLibraryDispatcher> {
type SubPointersType = Imodel_with_complex_arrayLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arrayLibraryDispatcher>) -> Imodel_with_complex_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_complex_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_complex_arrayLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_complex_arrayLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_complex_arrayLibraryDispatcher> {
type SubPointersType = MutableImodel_with_complex_arrayLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arrayLibraryDispatcher>>) -> MutableImodel_with_complex_arrayLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_complex_arrayLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_complex_arraySafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcher>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeLibraryDispatcher of starknet::Store::<Imodel_with_complex_arraySafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arraySafeLibraryDispatcher> {
type SubPointersType = Imodel_with_complex_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arraySafeLibraryDispatcher>) -> Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_complex_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_complex_arraySafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arraySafeLibraryDispatcher>>) -> MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_complex_arraySafeDispatcherCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcher>;
impl Imodel_with_complex_arraySafeDispatcherSerde of core::serde::Serde::<Imodel_with_complex_arraySafeDispatcher> {
    fn serialize(self: @Imodel_with_complex_arraySafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_complex_arraySafeDispatcher> {
        core::option::Option::Some(Imodel_with_complex_arraySafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_complex_arraySafeDispatcher of starknet::Store::<Imodel_with_complex_arraySafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_complex_arraySafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_complex_arraySafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_complex_arraySafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_complex_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_complex_arraySafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_complex_arraySafeDispatcher> {
type SubPointersType = Imodel_with_complex_arraySafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_complex_arraySafeDispatcher>) -> Imodel_with_complex_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_complex_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_complex_arraySafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_complex_arraySafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_complex_arraySafeDispatcher> {
type SubPointersType = MutableImodel_with_complex_arraySafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_complex_arraySafeDispatcher>>) -> MutableImodel_with_complex_arraySafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_complex_arraySafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tupleDispatcherCopy of core::traits::Copy::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherDrop of core::traits::Drop::<Imodel_with_tupleDispatcher>;
impl Imodel_with_tupleDispatcherSerde of core::serde::Serde::<Imodel_with_tupleDispatcher> {
    fn serialize(self: @Imodel_with_tupleDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleDispatcher> {
        core::option::Option::Some(Imodel_with_tupleDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleDispatcher of starknet::Store::<Imodel_with_tupleDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tupleDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tupleDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleDispatcher> {
type SubPointersType = Imodel_with_tupleDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleDispatcher>) -> Imodel_with_tupleDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tupleDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tupleDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_tupleDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tupleDispatcher> {
type SubPointersType = MutableImodel_with_tupleDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleDispatcher>>) -> MutableImodel_with_tupleDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tupleDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tupleLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcher>;
impl Imodel_with_tupleLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleLibraryDispatcher of starknet::Store::<Imodel_with_tupleLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tupleLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tupleLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleLibraryDispatcher> {
type SubPointersType = Imodel_with_tupleLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleLibraryDispatcher>) -> Imodel_with_tupleLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tupleLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tupleLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_tupleLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tupleLibraryDispatcher> {
type SubPointersType = MutableImodel_with_tupleLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleLibraryDispatcher>>) -> MutableImodel_with_tupleLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tupleLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tupleSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcher>;
impl Imodel_with_tupleSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeLibraryDispatcher of starknet::Store::<Imodel_with_tupleSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tupleSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleSafeLibraryDispatcher> {
type SubPointersType = Imodel_with_tupleSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleSafeLibraryDispatcher>) -> Imodel_with_tupleSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tupleSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tupleSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_tupleSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tupleSafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_tupleSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleSafeLibraryDispatcher>>) -> MutableImodel_with_tupleSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tupleSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tupleSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcher>;
impl Imodel_with_tupleSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tupleSafeDispatcher> {
    fn serialize(self: @Imodel_with_tupleSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tupleSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tupleSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tupleSafeDispatcher of starknet::Store::<Imodel_with_tupleSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tupleSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tupleSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tupleSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tupleSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tupleSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tupleSafeDispatcher> {
type SubPointersType = Imodel_with_tupleSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tupleSafeDispatcher>) -> Imodel_with_tupleSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tupleSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tupleSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_tupleSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tupleSafeDispatcher> {
type SubPointersType = MutableImodel_with_tupleSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tupleSafeDispatcher>>) -> MutableImodel_with_tupleSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tupleSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcher>;
impl Imodel_with_tuple_no_primitivesDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tuple_no_primitivesDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesDispatcher> {
type SubPointersType = Imodel_with_tuple_no_primitivesDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesDispatcher>) -> Imodel_with_tuple_no_primitivesDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tuple_no_primitivesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tuple_no_primitivesDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_tuple_no_primitivesDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tuple_no_primitivesDispatcher> {
type SubPointersType = MutableImodel_with_tuple_no_primitivesDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesDispatcher>>) -> MutableImodel_with_tuple_no_primitivesDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tuple_no_primitivesDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
type SubPointersType = Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesLibraryDispatcher>) -> Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tuple_no_primitivesLibraryDispatcher> {
type SubPointersType = MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesLibraryDispatcher>>) -> MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeLibraryDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
type SubPointersType = Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>) -> Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher> {
type SubPointersType = MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcher>>) -> MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl Imodel_with_tuple_no_primitivesSafeDispatcherCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcher>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSerde of core::serde::Serde::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn serialize(self: @Imodel_with_tuple_no_primitivesSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        core::option::Option::Some(Imodel_with_tuple_no_primitivesSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreImodel_with_tuple_no_primitivesSafeDispatcher of starknet::Store::<Imodel_with_tuple_no_primitivesSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<Imodel_with_tuple_no_primitivesSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            Imodel_with_tuple_no_primitivesSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: Imodel_with_tuple_no_primitivesSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<Imodel_with_tuple_no_primitivesSafeDispatcher> {
type SubPointersType = Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<Imodel_with_tuple_no_primitivesSafeDispatcher>) -> Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<Imodel_with_tuple_no_primitivesSafeDispatcher> {
type SubPointersType = MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<Imodel_with_tuple_no_primitivesSafeDispatcher>>) -> MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl Ibad_model_multiple_versionsDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsDispatcherSubPointers>;
impl Ibad_model_multiple_versionsDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_multiple_versionsDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_multiple_versionsDispatcherSubPointers>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_multiple_versionsLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_multiple_versionsSafeLibraryDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_multiple_versionsSafeDispatcherSubPointers>;
impl Ibad_model_multiple_versionsSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_multiple_versionsSafeDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_multiple_versionsSafeDispatcherSubPointers>;
impl MutableIbad_model_multiple_versionsSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_multiple_versionsSafeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_bad_version_typeDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_bad_version_typeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_bad_version_typeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_bad_version_typeSafeLibraryDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_bad_version_typeSafeDispatcherSubPointers>;
impl Ibad_model_bad_version_typeSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_bad_version_typeSafeDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_bad_version_typeSafeDispatcherSubPointers>;
impl MutableIbad_model_bad_version_typeSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_bad_version_typeSafeDispatcherSubPointers>;
impl Ibad_model_no_version_valueDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueDispatcherSubPointers>;
impl Ibad_model_no_version_valueDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_no_version_valueDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_no_version_valueDispatcherSubPointers>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueLibraryDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_no_version_valueLibraryDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_no_version_valueLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_no_version_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_no_version_valueSafeDispatcherSubPointers>;
impl Ibad_model_no_version_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_no_version_valueSafeDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_no_version_valueSafeDispatcherSubPointers>;
impl MutableIbad_model_no_version_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_no_version_valueSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_arg_with_valueDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_arg_with_valueLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_arg_with_valueSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_arg_with_valueSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_argDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argDispatcherSubPointers>;
impl Ibad_model_unexpected_argDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_argDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_argDispatcherSubPointers>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_argLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_argLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_argSafeLibraryDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_unexpected_argSafeDispatcherSubPointers>;
impl Ibad_model_unexpected_argSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_unexpected_argSafeDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_unexpected_argSafeDispatcherSubPointers>;
impl MutableIbad_model_unexpected_argSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_unexpected_argSafeDispatcherSubPointers>;
impl Ibad_model_not_supported_versionDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionDispatcherSubPointers>;
impl Ibad_model_not_supported_versionDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_not_supported_versionDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_not_supported_versionDispatcherSubPointers>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_not_supported_versionLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_not_supported_versionSafeLibraryDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersDrop of core::traits::Drop::<Ibad_model_not_supported_versionSafeDispatcherSubPointers>;
impl Ibad_model_not_supported_versionSafeDispatcherSubPointersCopy of core::traits::Copy::<Ibad_model_not_supported_versionSafeDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIbad_model_not_supported_versionSafeDispatcherSubPointers>;
impl MutableIbad_model_not_supported_versionSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIbad_model_not_supported_versionSafeDispatcherSubPointers>;
impl Imodelv_0DispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0DispatcherSubPointers>;
impl Imodelv_0DispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0DispatcherSubPointers>;
impl MutableImodelv_0DispatcherSubPointersDrop of core::traits::Drop::<MutableImodelv_0DispatcherSubPointers>;
impl MutableImodelv_0DispatcherSubPointersCopy of core::traits::Copy::<MutableImodelv_0DispatcherSubPointers>;
impl Imodelv_0LibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0LibraryDispatcherSubPointers>;
impl Imodelv_0LibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0LibraryDispatcherSubPointers>;
impl MutableImodelv_0LibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodelv_0LibraryDispatcherSubPointers>;
impl MutableImodelv_0LibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodelv_0LibraryDispatcherSubPointers>;
impl Imodelv_0SafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0SafeLibraryDispatcherSubPointers>;
impl Imodelv_0SafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0SafeLibraryDispatcherSubPointers>;
impl MutableImodelv_0SafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodelv_0SafeLibraryDispatcherSubPointers>;
impl MutableImodelv_0SafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodelv_0SafeLibraryDispatcherSubPointers>;
impl Imodelv_0SafeDispatcherSubPointersDrop of core::traits::Drop::<Imodelv_0SafeDispatcherSubPointers>;
impl Imodelv_0SafeDispatcherSubPointersCopy of core::traits::Copy::<Imodelv_0SafeDispatcherSubPointers>;
impl MutableImodelv_0SafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodelv_0SafeDispatcherSubPointers>;
impl MutableImodelv_0SafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodelv_0SafeDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_bad_namespace_formatDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_bad_namespace_formatDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_bad_namespace_formatLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_bad_namespace_formatSafeLibraryDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl Imodel_with_bad_namespace_formatSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_bad_namespace_formatSafeDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_short_string_namespaceDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_short_string_namespaceDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_short_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_short_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_short_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl MutableImodel_with_short_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_short_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceDispatcherSubPointers>;
impl Imodel_with_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_string_namespaceDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_string_namespaceDispatcherSubPointers>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_string_namespaceLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_string_namespaceSafeLibraryDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_string_namespaceSafeDispatcherSubPointers>;
impl Imodel_with_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_string_namespaceSafeDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_string_namespaceSafeDispatcherSubPointers>;
impl MutableImodel_with_string_namespaceSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_string_namespaceSafeDispatcherSubPointers>;
impl IpositionDispatcherSubPointersDrop of core::traits::Drop::<IpositionDispatcherSubPointers>;
impl IpositionDispatcherSubPointersCopy of core::traits::Copy::<IpositionDispatcherSubPointers>;
impl MutableIpositionDispatcherSubPointersDrop of core::traits::Drop::<MutableIpositionDispatcherSubPointers>;
impl MutableIpositionDispatcherSubPointersCopy of core::traits::Copy::<MutableIpositionDispatcherSubPointers>;
impl IpositionLibraryDispatcherSubPointersDrop of core::traits::Drop::<IpositionLibraryDispatcherSubPointers>;
impl IpositionLibraryDispatcherSubPointersCopy of core::traits::Copy::<IpositionLibraryDispatcherSubPointers>;
impl MutableIpositionLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIpositionLibraryDispatcherSubPointers>;
impl MutableIpositionLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIpositionLibraryDispatcherSubPointers>;
impl IpositionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IpositionSafeLibraryDispatcherSubPointers>;
impl IpositionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IpositionSafeLibraryDispatcherSubPointers>;
impl MutableIpositionSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIpositionSafeLibraryDispatcherSubPointers>;
impl MutableIpositionSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIpositionSafeLibraryDispatcherSubPointers>;
impl IpositionSafeDispatcherSubPointersDrop of core::traits::Drop::<IpositionSafeDispatcherSubPointers>;
impl IpositionSafeDispatcherSubPointersCopy of core::traits::Copy::<IpositionSafeDispatcherSubPointers>;
impl MutableIpositionSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIpositionSafeDispatcherSubPointers>;
impl MutableIpositionSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIpositionSafeDispatcherSubPointers>;
impl IrolesDispatcherSubPointersDrop of core::traits::Drop::<IrolesDispatcherSubPointers>;
impl IrolesDispatcherSubPointersCopy of core::traits::Copy::<IrolesDispatcherSubPointers>;
impl MutableIrolesDispatcherSubPointersDrop of core::traits::Drop::<MutableIrolesDispatcherSubPointers>;
impl MutableIrolesDispatcherSubPointersCopy of core::traits::Copy::<MutableIrolesDispatcherSubPointers>;
impl IrolesLibraryDispatcherSubPointersDrop of core::traits::Drop::<IrolesLibraryDispatcherSubPointers>;
impl IrolesLibraryDispatcherSubPointersCopy of core::traits::Copy::<IrolesLibraryDispatcherSubPointers>;
impl MutableIrolesLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIrolesLibraryDispatcherSubPointers>;
impl MutableIrolesLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIrolesLibraryDispatcherSubPointers>;
impl IrolesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IrolesSafeLibraryDispatcherSubPointers>;
impl IrolesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IrolesSafeLibraryDispatcherSubPointers>;
impl MutableIrolesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIrolesSafeLibraryDispatcherSubPointers>;
impl MutableIrolesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIrolesSafeLibraryDispatcherSubPointers>;
impl IrolesSafeDispatcherSubPointersDrop of core::traits::Drop::<IrolesSafeDispatcherSubPointers>;
impl IrolesSafeDispatcherSubPointersCopy of core::traits::Copy::<IrolesSafeDispatcherSubPointers>;
impl MutableIrolesSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIrolesSafeDispatcherSubPointers>;
impl MutableIrolesSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIrolesSafeDispatcherSubPointers>;
impl Ionly_key_modelDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelDispatcherSubPointers>;
impl Ionly_key_modelDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelDispatcherSubPointers>;
impl MutableIonly_key_modelDispatcherSubPointersDrop of core::traits::Drop::<MutableIonly_key_modelDispatcherSubPointers>;
impl MutableIonly_key_modelDispatcherSubPointersCopy of core::traits::Copy::<MutableIonly_key_modelDispatcherSubPointers>;
impl Ionly_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelLibraryDispatcherSubPointers>;
impl Ionly_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelLibraryDispatcherSubPointers>;
impl MutableIonly_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIonly_key_modelLibraryDispatcherSubPointers>;
impl MutableIonly_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIonly_key_modelLibraryDispatcherSubPointers>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelSafeLibraryDispatcherSubPointers>;
impl Ionly_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelSafeLibraryDispatcherSubPointers>;
impl MutableIonly_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIonly_key_modelSafeLibraryDispatcherSubPointers>;
impl MutableIonly_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIonly_key_modelSafeLibraryDispatcherSubPointers>;
impl Ionly_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<Ionly_key_modelSafeDispatcherSubPointers>;
impl Ionly_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<Ionly_key_modelSafeDispatcherSubPointers>;
impl MutableIonly_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIonly_key_modelSafeDispatcherSubPointers>;
impl MutableIonly_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIonly_key_modelSafeDispatcherSubPointers>;
impl Iu_256_key_modelDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelDispatcherSubPointers>;
impl Iu_256_key_modelDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelDispatcherSubPointers>;
impl MutableIu_256_key_modelDispatcherSubPointersDrop of core::traits::Drop::<MutableIu_256_key_modelDispatcherSubPointers>;
impl MutableIu_256_key_modelDispatcherSubPointersCopy of core::traits::Copy::<MutableIu_256_key_modelDispatcherSubPointers>;
impl Iu_256_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelLibraryDispatcherSubPointers>;
impl Iu_256_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelLibraryDispatcherSubPointers>;
impl MutableIu_256_key_modelLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIu_256_key_modelLibraryDispatcherSubPointers>;
impl MutableIu_256_key_modelLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIu_256_key_modelLibraryDispatcherSubPointers>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl Iu_256_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl MutableIu_256_key_modelSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl MutableIu_256_key_modelSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIu_256_key_modelSafeLibraryDispatcherSubPointers>;
impl Iu_256_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<Iu_256_key_modelSafeDispatcherSubPointers>;
impl Iu_256_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<Iu_256_key_modelSafeDispatcherSubPointers>;
impl MutableIu_256_key_modelSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIu_256_key_modelSafeDispatcherSubPointers>;
impl MutableIu_256_key_modelSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIu_256_key_modelSafeDispatcherSubPointers>;
impl IplayerDispatcherSubPointersDrop of core::traits::Drop::<IplayerDispatcherSubPointers>;
impl IplayerDispatcherSubPointersCopy of core::traits::Copy::<IplayerDispatcherSubPointers>;
impl MutableIplayerDispatcherSubPointersDrop of core::traits::Drop::<MutableIplayerDispatcherSubPointers>;
impl MutableIplayerDispatcherSubPointersCopy of core::traits::Copy::<MutableIplayerDispatcherSubPointers>;
impl IplayerLibraryDispatcherSubPointersDrop of core::traits::Drop::<IplayerLibraryDispatcherSubPointers>;
impl IplayerLibraryDispatcherSubPointersCopy of core::traits::Copy::<IplayerLibraryDispatcherSubPointers>;
impl MutableIplayerLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIplayerLibraryDispatcherSubPointers>;
impl MutableIplayerLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIplayerLibraryDispatcherSubPointers>;
impl IplayerSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IplayerSafeLibraryDispatcherSubPointers>;
impl IplayerSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IplayerSafeLibraryDispatcherSubPointers>;
impl MutableIplayerSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIplayerSafeLibraryDispatcherSubPointers>;
impl MutableIplayerSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIplayerSafeLibraryDispatcherSubPointers>;
impl IplayerSafeDispatcherSubPointersDrop of core::traits::Drop::<IplayerSafeDispatcherSubPointers>;
impl IplayerSafeDispatcherSubPointersCopy of core::traits::Copy::<IplayerSafeDispatcherSubPointers>;
impl MutableIplayerSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIplayerSafeDispatcherSubPointers>;
impl MutableIplayerSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIplayerSafeDispatcherSubPointers>;
impl Imodel_with_simple_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arrayDispatcherSubPointers>;
impl Imodel_with_simple_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arrayDispatcherSubPointers>;
impl MutableImodel_with_simple_arrayDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_simple_arrayDispatcherSubPointers>;
impl MutableImodel_with_simple_arrayDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_simple_arrayDispatcherSubPointers>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_simple_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_simple_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_simple_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_simple_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_simple_arraySafeDispatcherSubPointers>;
impl Imodel_with_simple_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_simple_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_simple_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_simple_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_simple_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_simple_arraySafeDispatcherSubPointers>;
impl Imodel_with_byte_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arrayDispatcherSubPointers>;
impl Imodel_with_byte_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arrayDispatcherSubPointers>;
impl MutableImodel_with_byte_arrayDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_byte_arrayDispatcherSubPointers>;
impl MutableImodel_with_byte_arrayDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_byte_arrayDispatcherSubPointers>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_byte_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_byte_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_byte_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_byte_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_byte_arraySafeDispatcherSubPointers>;
impl Imodel_with_byte_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_byte_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_byte_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_byte_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_byte_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_byte_arraySafeDispatcherSubPointers>;
impl Imodel_with_complex_arrayDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arrayDispatcherSubPointers>;
impl Imodel_with_complex_arrayDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arrayDispatcherSubPointers>;
impl MutableImodel_with_complex_arrayDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_complex_arrayDispatcherSubPointers>;
impl MutableImodel_with_complex_arrayDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_complex_arrayDispatcherSubPointers>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_complex_arrayLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl MutableImodel_with_complex_arrayLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_complex_arrayLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_complex_arraySafeLibraryDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_complex_arraySafeDispatcherSubPointers>;
impl Imodel_with_complex_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_complex_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_complex_arraySafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_complex_arraySafeDispatcherSubPointers>;
impl MutableImodel_with_complex_arraySafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_complex_arraySafeDispatcherSubPointers>;
impl Imodel_with_tupleDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleDispatcherSubPointers>;
impl Imodel_with_tupleDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleDispatcherSubPointers>;
impl MutableImodel_with_tupleDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tupleDispatcherSubPointers>;
impl MutableImodel_with_tupleDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tupleDispatcherSubPointers>;
impl Imodel_with_tupleLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleLibraryDispatcherSubPointers>;
impl Imodel_with_tupleLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleLibraryDispatcherSubPointers>;
impl MutableImodel_with_tupleLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tupleLibraryDispatcherSubPointers>;
impl MutableImodel_with_tupleLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tupleLibraryDispatcherSubPointers>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tupleSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_tupleSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_tupleSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tupleSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tupleSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tupleSafeDispatcherSubPointers>;
impl Imodel_with_tupleSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tupleSafeDispatcherSubPointers>;
impl MutableImodel_with_tupleSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tupleSafeDispatcherSubPointers>;
impl MutableImodel_with_tupleSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tupleSafeDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tuple_no_primitivesDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tuple_no_primitivesLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tuple_no_primitivesSafeLibraryDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersDrop of core::traits::Drop::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;
impl Imodel_with_tuple_no_primitivesSafeDispatcherSubPointersCopy of core::traits::Copy::<Imodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;
impl MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableImodel_with_tuple_no_primitivesSafeDispatcherSubPointers>;

//! > expected_diagnostics
error: A Dojo model must have zero or one dojo::model attribute.
 --> /tmp/plugin_test/model/src/lib.cairo:1:1
#[dojo::model(version: 0)]
^************************^

error: Too many 'version' attributes for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:9:1
#[dojo::model(version: 0, version: 0)]
^************************************^

error: The argument 'version' of dojo::model must be an integer
 --> /tmp/plugin_test/model/src/lib.cairo:16:24
#[dojo::model(version: hello)]
                       ^***^

error: Unexpected argument 'version' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:23:15
#[dojo::model(version)]
              ^*****^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:30:15
#[dojo::model(my_arg: 1)]
              ^*******^

error: Unexpected argument 'my_arg' for dojo::model
 --> /tmp/plugin_test/model/src/lib.cairo:37:15
#[dojo::model(my_arg)]
              ^****^

error: dojo::model version 2 not supported
 --> /tmp/plugin_test/model/src/lib.cairo:44:24
#[dojo::model(version: 2)]
                       ^

error: Model must define at least one #[key] attribute
 --> /tmp/plugin_test/model/src/lib.cairo:87:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:92:8
struct OnlyKeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> /tmp/plugin_test/model/src/lib.cairo:100:5
    id: u256
    ^^

error: Model must define at least one member that is not a key
 --> /tmp/plugin_test/model/src/lib.cairo:98:8
struct U256KeyModel {
       ^**********^
