//! > Test expansion of the derive(Model).

//! > test_runner_name
test_expand_plugin

//! > cairo_code
use core::serde::Serde;

#[derive(Introspect, Copy, Drop, Serde)]
struct Vec3 {
    x: u32,
    y: u32,
    z: u8,
}

#[derive(Model, Copy, Drop, Serde)]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

trait PositionTrait {
    fn is_zero(self: Position) -> bool;
    fn is_equal(self: Position, b: Position) -> bool;
}

impl PositionImpl of PositionTrait {
    fn is_zero(self: Position) -> bool {
        match self.x - self.y {
            0 => bool::True(()),
            _ => bool::False(()),
        }
    }

    fn is_equal(self: Position, b: Position) -> bool {
        self.x == b.x && self.y == b.y
    }
}

#[derive(Model, Serde)]
struct Roles {
    role_ids: Array<u8>
}

#[derive(Model, Serde)]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[derive(Model, Serde)]
struct U256KeyModel {
    #[key]
    id: u256
}

use starknet::ContractAddress;

#[derive(Model, Copy, Drop, Serde)]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}

//! > generated_cairo_code
use core::serde::Serde;


#[derive(Introspect, Copy, Drop, Serde)]
struct Vec3 {
    x: u32,
    y: u32,
    z: u8,
}

impl Vec3Introspect of dojo::database::introspect::Introspect<Vec3> {
    #[inline(always)]
    fn size() -> usize {
        3
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        layout.append(32);
        layout.append(32);
        layout.append(8);
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Vec3',
                attrs: array![].span(),
                children: array![
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'x',
                            ty: dojo::database::introspect::Ty::Primitive('u32'),
                            attrs: array![].span()
                        }
                    ),
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'y',
                            ty: dojo::database::introspect::Ty::Primitive('u32'),
                            attrs: array![].span()
                        }
                    ),
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'z',
                            ty: dojo::database::introspect::Ty::Primitive('u8'),
                            attrs: array![].span()
                        }
                    )
                ]
                    .span()
            }
        )
    }
}



#[derive(Model, Copy, Drop, Serde)]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

impl PositionModel of dojo::model::Model<Position> {
    #[inline(always)]
    fn name(self: @Position) -> felt252 {
        'Position'
    }

    #[inline(always)]
    fn keys(self: @Position) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();
        array::ArrayTrait::append(ref serialized, *self.id);
        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Position) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();
        core::serde::Serde::serialize(self.v, ref serialized);
        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Position) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Position) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}


impl PositionIntrospect of dojo::database::introspect::Introspect<Position> {
    #[inline(always)]
    fn size() -> usize {
        dojo::database::introspect::Introspect::<Vec3>::size()
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        dojo::database::introspect::Introspect::<Vec3>::layout(ref layout);
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Position',
                attrs: array![].span(),
                children: array![
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'id',
                            ty: dojo::database::introspect::Ty::Primitive('felt252'),
                            attrs: array!['key'].span()
                        }
                    ),
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'v',
                            ty: dojo::database::introspect::Introspect::<Vec3>::ty(),
                            attrs: array![].span()
                        }
                    )
                ]
                    .span()
            }
        )
    }
}


#[starknet::interface]
trait IPosition<T> {
    fn name(self: @T) -> felt252;
}

#[starknet::contract]
mod position {
    use super::Position;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'Position'
    }

    #[abi(embed_v0)]
    fn unpacked_size(self: @ContractState) -> usize {
        dojo::database::introspect::Introspect::<Position>::size()
    }

    #[abi(embed_v0)]
    fn packed_size(self: @ContractState) -> usize {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
        let mut layout_span = layout.span();
        dojo::packing::calculate_packed_size(ref layout_span)
    }

    #[abi(embed_v0)]
    fn layout(self: @ContractState) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[abi(embed_v0)]
    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
        dojo::database::introspect::Introspect::<Position>::ty()
    }
}



trait PositionTrait {
    fn is_zero(self: Position) -> bool;
    fn is_equal(self: Position, b: Position) -> bool;
}


impl PositionImpl of PositionTrait {
    fn is_zero(self: Position) -> bool {
        match self.x - self.y {
            0 => bool::True(()),
            _ => bool::False(()),
        }
    }

    fn is_equal(self: Position, b: Position) -> bool {
        self.x == b.x && self.y == b.y
    }
}


#[derive(Model, Serde)]
struct Roles {
    role_ids: Array<u8>
}

impl RolesModel of dojo::model::Model<Roles> {
    #[inline(always)]
    fn name(self: @Roles) -> felt252 {
        'Roles'
    }

    #[inline(always)]
    fn keys(self: @Roles) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();

        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Roles) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();
        core::serde::Serde::serialize(self.role_ids, ref serialized);
        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Roles) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Roles) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}


impl RolesIntrospect of dojo::database::introspect::Introspect<Roles> {
    #[inline(always)]
    fn size() -> usize {
        dojo::database::introspect::Introspect::<Array<u8>>::size()
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        dojo::database::introspect::Introspect::<Array<u8>>::layout(ref layout);
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Roles',
                attrs: array![].span(),
                children: array![
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'role_ids',
                            ty: dojo::database::introspect::Introspect::<Array<u8>>::ty(),
                            attrs: array![].span()
                        }
                    )
                ]
                    .span()
            }
        )
    }
}


#[starknet::interface]
trait IRoles<T> {
    fn name(self: @T) -> felt252;
}

#[starknet::contract]
mod roles {
    use super::Roles;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'Roles'
    }

    #[abi(embed_v0)]
    fn unpacked_size(self: @ContractState) -> usize {
        dojo::database::introspect::Introspect::<Roles>::size()
    }

    #[abi(embed_v0)]
    fn packed_size(self: @ContractState) -> usize {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
        let mut layout_span = layout.span();
        dojo::packing::calculate_packed_size(ref layout_span)
    }

    #[abi(embed_v0)]
    fn layout(self: @ContractState) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[abi(embed_v0)]
    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
        dojo::database::introspect::Introspect::<Roles>::ty()
    }
}



use starknet::ContractAddress;


#[derive(Model, Copy, Drop, Serde)]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}
impl PlayerModel of dojo::model::Model<Player> {
    #[inline(always)]
    fn name(self: @Player) -> felt252 {
        'Player'
    }

    #[inline(always)]
    fn keys(self: @Player) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();
        array::ArrayTrait::append(ref serialized, *self.game);
        core::serde::Serde::serialize(self.player, ref serialized);
        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn values(self: @Player) -> Span<felt252> {
        let mut serialized = ArrayTrait::new();
        array::ArrayTrait::append(ref serialized, *self.name);
        array::ArrayTrait::span(@serialized)
    }

    #[inline(always)]
    fn layout(self: @Player) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[inline(always)]
    fn packed_size(self: @Player) -> usize {
        let mut layout = self.layout();
        dojo::packing::calculate_packed_size(ref layout)
    }
}


impl PlayerIntrospect of dojo::database::introspect::Introspect<Player> {
    #[inline(always)]
    fn size() -> usize {
        1
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        layout.append(251);
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(
            dojo::database::introspect::Struct {
                name: 'Player',
                attrs: array![].span(),
                children: array![
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'game',
                            ty: dojo::database::introspect::Ty::Primitive('felt252'),
                            attrs: array!['key'].span()
                        }
                    ),
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'player',
                            ty: dojo::database::introspect::Ty::Primitive('ContractAddress'),
                            attrs: array!['key'].span()
                        }
                    ),
                    dojo::database::introspect::serialize_member(
                        @dojo::database::introspect::Member {
                            name: 'name',
                            ty: dojo::database::introspect::Ty::Primitive('felt252'),
                            attrs: array![].span()
                        }
                    )
                ]
                    .span()
            }
        )
    }
}


#[starknet::interface]
trait IPlayer<T> {
    fn name(self: @T) -> felt252;
}

#[starknet::contract]
mod player {
    use super::Player;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'Player'
    }

    #[abi(embed_v0)]
    fn unpacked_size(self: @ContractState) -> usize {
        dojo::database::introspect::Introspect::<Player>::size()
    }

    #[abi(embed_v0)]
    fn packed_size(self: @ContractState) -> usize {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
        let mut layout_span = layout.span();
        dojo::packing::calculate_packed_size(ref layout_span)
    }

    #[abi(embed_v0)]
    fn layout(self: @ContractState) -> Span<u8> {
        let mut layout = ArrayTrait::new();
        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
        array::ArrayTrait::span(@layout)
    }

    #[abi(embed_v0)]
    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
        dojo::database::introspect::Introspect::<Player>::ty()
    }
}

//! > expected_diagnostics
error: Model must define at least one #[key] attribute
 --> test_src/lib.cairo:36:8
struct Roles {
       ^***^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:41:8
struct OnlyKeyModel {
       ^**********^

error: Model must define at least one member that is not a key
 --> test_src/lib.cairo:47:8
struct U256KeyModel {
       ^**********^

error: Key is only supported for core types that are 1 felt long once serialized. `u256` is a struct of 2 u128, hence not supported.
 --> test_src/lib.cairo:47:8
struct U256KeyModel {
       ^**********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:73:13
            #[starknet::contract]
            ^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:69:13
            #[starknet::contract]
            ^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:68:13
            #[starknet::contract]
            ^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:68:13
            #[starknet::contract]
            ^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:77:13
            #[starknet::contract]
            ^*******************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:78:17
                #[storage]
                ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:81:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Position]:109:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:74:17
                #[storage]
                ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:77:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Roles]:105:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:73:17
                #[storage]
                ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:76:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[OnlyKeyModel]:104:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:73:17
                #[storage]
                ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:76:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[U256KeyModel]:104:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:82:17
                #[storage]
                ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:85:17
                #[abi(embed_v0)]
                ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo[Player]:113:17
                #[abi(embed_v0)]
                ^**************^

//! > expanded_cairo_code
use core::serde::Serde;

#[derive(Introspect, Copy, Drop, Serde)]
struct Vec3 {
    x: u32,
    y: u32,
    z: u8,
}

#[derive(Model, Copy, Drop, Serde)]
struct Position {
    #[key]
    id: felt252,
    v: Vec3,
}

trait PositionTrait {
    fn is_zero(self: Position) -> bool;
    fn is_equal(self: Position, b: Position) -> bool;
}

impl PositionImpl of PositionTrait {
    fn is_zero(self: Position) -> bool {
        match self.x - self.y {
            0 => bool::True(()),
            _ => bool::False(()),
        }
    }

    fn is_equal(self: Position, b: Position) -> bool {
        self.x == b.x && self.y == b.y
    }
}

#[derive(Model, Serde)]
struct Roles {
    role_ids: Array<u8>
}

#[derive(Model, Serde)]
struct OnlyKeyModel {
    #[key]
    id: felt252
}

#[derive(Model, Serde)]
struct U256KeyModel {
    #[key]
    id: u256
}

use starknet::ContractAddress;

#[derive(Model, Copy, Drop, Serde)]
struct Player {
    #[key]
    game: felt252,
    #[key]
    player: ContractAddress,

    name: felt252, 
}
impl Vec3Copy of core::traits::Copy::<Vec3>;
impl Vec3Drop of core::traits::Drop::<Vec3>;
impl Vec3Serde of core::serde::Serde::<Vec3> {
    fn serialize(self: @Vec3, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.x, ref output);
        core::serde::Serde::serialize(self.y, ref output);
        core::serde::Serde::serialize(self.z, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Vec3> {
        core::option::Option::Some(Vec3 {
            x: core::serde::Serde::deserialize(ref serialized)?,
            y: core::serde::Serde::deserialize(ref serialized)?,
            z: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

impl Vec3Introspect<> of dojo::database::introspect::Introspect<Vec3<>> {
    #[inline(always)]
    fn size() -> usize {
        3
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        layout.append(32);
layout.append(32);
layout.append(8);

    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'Vec3',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'x',
                ty: dojo::database::introspect::Ty::Primitive('u32'),
                attrs: array![].span()
            }), dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'y',
                ty: dojo::database::introspect::Ty::Primitive('u32'),
                attrs: array![].span()
            }), dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'z',
                ty: dojo::database::introspect::Ty::Primitive('u8'),
                attrs: array![].span()
            })].span()
        })
    }
}
impl PositionCopy of core::traits::Copy::<Position>;
impl PositionDrop of core::traits::Drop::<Position>;
impl PositionSerde of core::serde::Serde::<Position> {
    fn serialize(self: @Position, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.id, ref output);
        core::serde::Serde::serialize(self.v, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Position> {
        core::option::Option::Some(Position {
            id: core::serde::Serde::deserialize(ref serialized)?,
            v: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

            impl PositionModel of dojo::model::Model<Position> {
                #[inline(always)]
                fn name(self: @Position) -> felt252 {
                    'Position'
                }

                #[inline(always)]
                fn keys(self: @Position) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::array::ArrayTrait::append(ref serialized, *self.id);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn values(self: @Position) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::serde::Serde::serialize(self.v, ref serialized);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn layout(self: @Position) -> Span<u8> {
                    let mut layout = core::array::ArrayTrait::new();
                    dojo::database::introspect::Introspect::<Position>::layout(ref layout);
                    core::array::ArrayTrait::span(@layout)
                }

                #[inline(always)]
                fn packed_size(self: @Position) -> usize {
                    let mut layout = self.layout();
                    dojo::packing::calculate_packed_size(ref layout)
                }
            }

            
impl PositionIntrospect<> of dojo::database::introspect::Introspect<Position<>> {
    #[inline(always)]
    fn size() -> usize {
        dojo::database::introspect::Introspect::<Vec3>::size() + 0
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        dojo::database::introspect::Introspect::<Vec3>::layout(ref layout);

    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'Position',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'id',
                ty: dojo::database::introspect::Ty::Primitive('felt252'),
                attrs: array!['key'].span()
            }), dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'v',
                ty: dojo::database::introspect::Introspect::<Vec3>::ty(),
                attrs: array![].span()
            })].span()
        })
    }
}
        

            #[starknet::interface]
            trait Iposition<T> {
                fn ensure_abi(self: @T, model: Position);
            }

            #[starknet::contract]
            mod position {
                use super::Position;
                use super::Iposition;

                #[storage]
                struct Storage {}

                #[abi(embed_v0)]
                impl DojoModelImpl of dojo::model::IDojoModel<ContractState>{
                    fn name(self: @ContractState) -> felt252 {
                        'Position'
                    }

                    fn unpacked_size(self: @ContractState) -> usize {
                        dojo::database::introspect::Introspect::<Position>::size()
                    }

                    fn packed_size(self: @ContractState) -> usize {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
                        let mut layout_span = layout.span();
                        dojo::packing::calculate_packed_size(ref layout_span)
                    }

                    fn layout(self: @ContractState) -> Span<u8> {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Position>::layout(ref layout);
                        core::array::ArrayTrait::span(@layout)
                    }

                    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
                        dojo::database::introspect::Introspect::<Position>::ty()
                    }
                }

                #[abi(embed_v0)]
                impl positionImpl of Iposition<ContractState>{
                    fn ensure_abi(self: @ContractState, model: Position) {
                    }
                }
            }
impl RolesSerde of core::serde::Serde::<Roles> {
    fn serialize(self: @Roles, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.role_ids, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Roles> {
        core::option::Option::Some(Roles {
            role_ids: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

            impl RolesModel of dojo::model::Model<Roles> {
                #[inline(always)]
                fn name(self: @Roles) -> felt252 {
                    'Roles'
                }

                #[inline(always)]
                fn keys(self: @Roles) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn values(self: @Roles) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::serde::Serde::serialize(self.role_ids, ref serialized);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn layout(self: @Roles) -> Span<u8> {
                    let mut layout = core::array::ArrayTrait::new();
                    dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
                    core::array::ArrayTrait::span(@layout)
                }

                #[inline(always)]
                fn packed_size(self: @Roles) -> usize {
                    let mut layout = self.layout();
                    dojo::packing::calculate_packed_size(ref layout)
                }
            }

            
impl RolesIntrospect<> of dojo::database::introspect::Introspect<Roles<>> {
    #[inline(always)]
    fn size() -> usize {
        dojo::database::introspect::Introspect::<Array<u8>>::size() + 0
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        dojo::database::introspect::Introspect::<Array<u8>>::layout(ref layout);

    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'Roles',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'role_ids',
                ty: dojo::database::introspect::Introspect::<Array<u8>>::ty(),
                attrs: array![].span()
            })].span()
        })
    }
}
        

            #[starknet::interface]
            trait Iroles<T> {
                fn ensure_abi(self: @T, model: Roles);
            }

            #[starknet::contract]
            mod roles {
                use super::Roles;
                use super::Iroles;

                #[storage]
                struct Storage {}

                #[abi(embed_v0)]
                impl DojoModelImpl of dojo::model::IDojoModel<ContractState>{
                    fn name(self: @ContractState) -> felt252 {
                        'Roles'
                    }

                    fn unpacked_size(self: @ContractState) -> usize {
                        dojo::database::introspect::Introspect::<Roles>::size()
                    }

                    fn packed_size(self: @ContractState) -> usize {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
                        let mut layout_span = layout.span();
                        dojo::packing::calculate_packed_size(ref layout_span)
                    }

                    fn layout(self: @ContractState) -> Span<u8> {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Roles>::layout(ref layout);
                        core::array::ArrayTrait::span(@layout)
                    }

                    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
                        dojo::database::introspect::Introspect::<Roles>::ty()
                    }
                }

                #[abi(embed_v0)]
                impl rolesImpl of Iroles<ContractState>{
                    fn ensure_abi(self: @ContractState, model: Roles) {
                    }
                }
            }
impl OnlyKeyModelSerde of core::serde::Serde::<OnlyKeyModel> {
    fn serialize(self: @OnlyKeyModel, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<OnlyKeyModel> {
        core::option::Option::Some(OnlyKeyModel {
            id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

            impl OnlyKeyModelModel of dojo::model::Model<OnlyKeyModel> {
                #[inline(always)]
                fn name(self: @OnlyKeyModel) -> felt252 {
                    'OnlyKeyModel'
                }

                #[inline(always)]
                fn keys(self: @OnlyKeyModel) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::array::ArrayTrait::append(ref serialized, *self.id);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn values(self: @OnlyKeyModel) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn layout(self: @OnlyKeyModel) -> Span<u8> {
                    let mut layout = core::array::ArrayTrait::new();
                    dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
                    core::array::ArrayTrait::span(@layout)
                }

                #[inline(always)]
                fn packed_size(self: @OnlyKeyModel) -> usize {
                    let mut layout = self.layout();
                    dojo::packing::calculate_packed_size(ref layout)
                }
            }

            
impl OnlyKeyModelIntrospect<> of dojo::database::introspect::Introspect<OnlyKeyModel<>> {
    #[inline(always)]
    fn size() -> usize {
        0
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'OnlyKeyModel',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'id',
                ty: dojo::database::introspect::Ty::Primitive('felt252'),
                attrs: array!['key'].span()
            })].span()
        })
    }
}
        

            #[starknet::interface]
            trait Ionly_key_model<T> {
                fn ensure_abi(self: @T, model: OnlyKeyModel);
            }

            #[starknet::contract]
            mod only_key_model {
                use super::OnlyKeyModel;
                use super::Ionly_key_model;

                #[storage]
                struct Storage {}

                #[abi(embed_v0)]
                impl DojoModelImpl of dojo::model::IDojoModel<ContractState>{
                    fn name(self: @ContractState) -> felt252 {
                        'OnlyKeyModel'
                    }

                    fn unpacked_size(self: @ContractState) -> usize {
                        dojo::database::introspect::Introspect::<OnlyKeyModel>::size()
                    }

                    fn packed_size(self: @ContractState) -> usize {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
                        let mut layout_span = layout.span();
                        dojo::packing::calculate_packed_size(ref layout_span)
                    }

                    fn layout(self: @ContractState) -> Span<u8> {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<OnlyKeyModel>::layout(ref layout);
                        core::array::ArrayTrait::span(@layout)
                    }

                    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
                        dojo::database::introspect::Introspect::<OnlyKeyModel>::ty()
                    }
                }

                #[abi(embed_v0)]
                impl only_key_modelImpl of Ionly_key_model<ContractState>{
                    fn ensure_abi(self: @ContractState, model: OnlyKeyModel) {
                    }
                }
            }
impl U256KeyModelSerde of core::serde::Serde::<U256KeyModel> {
    fn serialize(self: @U256KeyModel, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.id, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<U256KeyModel> {
        core::option::Option::Some(U256KeyModel {
            id: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

            impl U256KeyModelModel of dojo::model::Model<U256KeyModel> {
                #[inline(always)]
                fn name(self: @U256KeyModel) -> felt252 {
                    'U256KeyModel'
                }

                #[inline(always)]
                fn keys(self: @U256KeyModel) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::serde::Serde::serialize(self.id, ref serialized);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn values(self: @U256KeyModel) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn layout(self: @U256KeyModel) -> Span<u8> {
                    let mut layout = core::array::ArrayTrait::new();
                    dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
                    core::array::ArrayTrait::span(@layout)
                }

                #[inline(always)]
                fn packed_size(self: @U256KeyModel) -> usize {
                    let mut layout = self.layout();
                    dojo::packing::calculate_packed_size(ref layout)
                }
            }

            
impl U256KeyModelIntrospect<> of dojo::database::introspect::Introspect<U256KeyModel<>> {
    #[inline(always)]
    fn size() -> usize {
        0
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        
    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'U256KeyModel',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'id',
                ty: dojo::database::introspect::Ty::Primitive('u256'),
                attrs: array!['key'].span()
            })].span()
        })
    }
}
        

            #[starknet::interface]
            trait Iu_256_key_model<T> {
                fn ensure_abi(self: @T, model: U256KeyModel);
            }

            #[starknet::contract]
            mod u_256_key_model {
                use super::U256KeyModel;
                use super::Iu_256_key_model;

                #[storage]
                struct Storage {}

                #[abi(embed_v0)]
                impl DojoModelImpl of dojo::model::IDojoModel<ContractState>{
                    fn name(self: @ContractState) -> felt252 {
                        'U256KeyModel'
                    }

                    fn unpacked_size(self: @ContractState) -> usize {
                        dojo::database::introspect::Introspect::<U256KeyModel>::size()
                    }

                    fn packed_size(self: @ContractState) -> usize {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
                        let mut layout_span = layout.span();
                        dojo::packing::calculate_packed_size(ref layout_span)
                    }

                    fn layout(self: @ContractState) -> Span<u8> {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<U256KeyModel>::layout(ref layout);
                        core::array::ArrayTrait::span(@layout)
                    }

                    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
                        dojo::database::introspect::Introspect::<U256KeyModel>::ty()
                    }
                }

                #[abi(embed_v0)]
                impl u_256_key_modelImpl of Iu_256_key_model<ContractState>{
                    fn ensure_abi(self: @ContractState, model: U256KeyModel) {
                    }
                }
            }
impl PlayerCopy of core::traits::Copy::<Player>;
impl PlayerDrop of core::traits::Drop::<Player>;
impl PlayerSerde of core::serde::Serde::<Player> {
    fn serialize(self: @Player, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.game, ref output);
        core::serde::Serde::serialize(self.player, ref output);
        core::serde::Serde::serialize(self.name, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<Player> {
        core::option::Option::Some(Player {
            game: core::serde::Serde::deserialize(ref serialized)?,
            player: core::serde::Serde::deserialize(ref serialized)?,
            name: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}

            impl PlayerModel of dojo::model::Model<Player> {
                #[inline(always)]
                fn name(self: @Player) -> felt252 {
                    'Player'
                }

                #[inline(always)]
                fn keys(self: @Player) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::array::ArrayTrait::append(ref serialized, *self.game);core::serde::Serde::serialize(self.player, ref serialized);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn values(self: @Player) -> Span<felt252> {
                    let mut serialized = core::array::ArrayTrait::new();
                    core::array::ArrayTrait::append(ref serialized, *self.name);
                    core::array::ArrayTrait::span(@serialized)
                }

                #[inline(always)]
                fn layout(self: @Player) -> Span<u8> {
                    let mut layout = core::array::ArrayTrait::new();
                    dojo::database::introspect::Introspect::<Player>::layout(ref layout);
                    core::array::ArrayTrait::span(@layout)
                }

                #[inline(always)]
                fn packed_size(self: @Player) -> usize {
                    let mut layout = self.layout();
                    dojo::packing::calculate_packed_size(ref layout)
                }
            }

            
impl PlayerIntrospect<> of dojo::database::introspect::Introspect<Player<>> {
    #[inline(always)]
    fn size() -> usize {
        1
    }

    #[inline(always)]
    fn layout(ref layout: Array<u8>) {
        layout.append(251);

    }

    #[inline(always)]
    fn ty() -> dojo::database::introspect::Ty {
        dojo::database::introspect::Ty::Struct(dojo::database::introspect::Struct {
            name: 'Player',
            attrs: array![].span(),
            children: array![dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'game',
                ty: dojo::database::introspect::Ty::Primitive('felt252'),
                attrs: array!['key'].span()
            }), dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'player',
                ty: dojo::database::introspect::Ty::Primitive('ContractAddress'),
                attrs: array!['key'].span()
            }), dojo::database::introspect::serialize_member(@dojo::database::introspect::Member {
                name: 'name',
                ty: dojo::database::introspect::Ty::Primitive('felt252'),
                attrs: array![].span()
            })].span()
        })
    }
}
        

            #[starknet::interface]
            trait Iplayer<T> {
                fn ensure_abi(self: @T, model: Player);
            }

            #[starknet::contract]
            mod player {
                use super::Player;
                use super::Iplayer;

                #[storage]
                struct Storage {}

                #[abi(embed_v0)]
                impl DojoModelImpl of dojo::model::IDojoModel<ContractState>{
                    fn name(self: @ContractState) -> felt252 {
                        'Player'
                    }

                    fn unpacked_size(self: @ContractState) -> usize {
                        dojo::database::introspect::Introspect::<Player>::size()
                    }

                    fn packed_size(self: @ContractState) -> usize {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
                        let mut layout_span = layout.span();
                        dojo::packing::calculate_packed_size(ref layout_span)
                    }

                    fn layout(self: @ContractState) -> Span<u8> {
                        let mut layout = core::array::ArrayTrait::new();
                        dojo::database::introspect::Introspect::<Player>::layout(ref layout);
                        core::array::ArrayTrait::span(@layout)
                    }

                    fn schema(self: @ContractState) -> dojo::database::introspect::Ty {
                        dojo::database::introspect::Introspect::<Player>::ty()
                    }
                }

                #[abi(embed_v0)]
                impl playerImpl of Iplayer<ContractState>{
                    fn ensure_abi(self: @ContractState, model: Player) {
                    }
                }
            }
