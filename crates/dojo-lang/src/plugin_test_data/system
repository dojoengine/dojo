//! > Test expansion of the #[system].

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::contract]
mod spawn {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract]
mod proxy {
    fn execute(value: felt252) -> felt252 {
        value
    }
}

#[dojo::contract]
mod ctxnamed {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract]
mod withevent {
    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        TestEvent: TestEvent,
    }

    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }
}

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

#[dojo::contract]
mod withcomponent {
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event,
    }
}
#[dojo::interface]
trait IEmptyTrait;

#[dojo::interface]
trait IFaultyTrait {
    /// Even if it looks weird, the expected pattern for a constant in a trait is
    /// `const <name>: <type>;`
    /// See:
    /// 
    /// https://github.com/starkware-libs/cairo/blob/600553d34a1af93ff7fb038ac677efdd3fd07010/crates/cairo-lang-parser/src/parser.rs#L835
    const ONE: u8;

    fn do_ref_self(ref self: TContractState);

    #[my_attr]
    fn do_with_attrs(p1: u8) -> u16;
}

#[starknet::interface]
trait IAllowedRefSelf<T> {
    fn spawn(ref self: T);
}

#[dojo::contract(allow_ref_self)]
mod ContractAllowedRefSelf {
    #[abi(embed_v0)]
    impl AllowedImpl of IAllowedRefSelf<ContractState> {
        fn spawn(ref self: ContractState) {}
    }
}

#[dojo::interface]
trait INominalTrait {
    fn do_no_param();
    fn do_no_param_but_self(self: @TContractState);
    fn do_params(p1: dojo_examples::models::Direction, p2: u8);
    fn do_params_and_self(self: @TContractState, p2: u8);
    fn do_return_value(p1: u8) -> u16;
}

#[dojo::interface]
trait IWorldTrait {
    fn do_with_ref_self(ref self: ContractState) -> felt252;
    fn do_with_several_world_dispatchers(
        world: IWorldDispatcher, vec: Vec2, another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(another_world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_not_named_world(
        self: @ContractState, another_world: IWorldDispatcher
    );
    fn do_with_world_not_first(vec: Vec2, world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_not_first(
        self: @ContractState, vec: Vec2, world: IWorldDispatcher
    ) -> felt252;
}

#[dojo::contract]
mod MyFaultyContract {
    #[abi(embed_v0)]
    impl TestWorldImpl of IWorldTrait<ContractState> {
        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }

        fn do_with_several_world_dispatchers(
            world: IWorldDispatcher, vec: Vec2, another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_named_world(another_world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_not_named_world(
            self: @ContractState, another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(vec: Vec2, world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_not_first(
            self: @ContractState, vec: Vec2, world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }
    }
}

#[dojo::contract]
mod MyNominalContract {
    #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestWorldImpl of IWorldTrait<ContractState> {
        fn do(vec: Vec2) -> felt252 {
            'land'
        }

        fn do_with_self(self: @ContractState, vec: Vec2) -> felt252 {
            'land'
        }

        fn do_with_world_first(world: IWorldDispatcher, vec: Vec2) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_first(
            self: @ContractState, world: IWorldDispatcher, vec: Vec2
        ) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }
}

//! > generated_cairo_code
#[starknet::contract]
mod spawn {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'spawn'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx: Context, name: felt252) {
        return ();
    }
}


#[starknet::contract]
mod proxy {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'proxy'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }


    #[abi(embed_v0)]
    fn execute(self: @ContractState, value: felt252) -> felt252 {
        value
    }
}


#[starknet::contract]
mod ctxnamed {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'ctxnamed'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx2: Context, name: felt252) {
        return ();
    }
}

//! > expected_diagnostics
error: Unsupported attribute.
 --> test_src/lib.cairo:42:1
#[starknet::component]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:48:1
#[starknet::component]
^********************^

error: Anything other than functions is not supported in a dojo::interface
 --> test_src/lib.cairo:85:5
    const ONE: u8;
    ^************^

error: Functions of dojo::interface cannot have `ref self` parameter.
 --> test_src/lib.cairo:87:5
    fn do_ref_self(ref self: TContractState);
    ^***************************************^

error: Functions of dojo::contract cannot have 'ref self' parameter.
 --> test_src/lib.cairo:135:9
        fn do_with_ref_self(ref self: ContractState) -> felt252 {
        ^*******************************************************^

error: Only one parameter of type IWorldDispatcher is allowed.
 --> test_src/lib.cairo:139:9
        fn do_with_several_world_dispatchers(
        ^***********************************^

error: The IWorldDispatcher parameter must be named 'world'.
 --> test_src/lib.cairo:145:42
        fn do_with_world_not_named_world(another_world: IWorldDispatcher) -> felt252 {
                                         ^*****************************^

error: The IWorldDispatcher parameter must be named 'world'.
 --> test_src/lib.cairo:150:35
            self: @ContractState, another_world: IWorldDispatcher
                                  ^*****************************^

error: The IWorldDispatcher parameter must be the first parameter of the function (self excluded).
 --> test_src/lib.cairo:155:47
        fn do_with_world_not_first(vec: Vec2, world: IWorldDispatcher) -> felt252 {
                                              ^*********************^

error: The IWorldDispatcher parameter must be the first parameter of the function (self excluded).
 --> test_src/lib.cairo:160:46
            self: @ContractState, vec: Vec2, world: IWorldDispatcher
                                             ^*********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:89:5
    #[my_attr]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:44:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo:50:5
    #[storage]
    ^********^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:1:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:18:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:56:5
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    ^*********************************************************************************************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:57:5
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);
    ^*********************************************************************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:100:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:98:1
#[dojo::contract(allow_ref_self)]
^*******************************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:133:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:131:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:174:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:167:1
#[dojo::contract]
^***************^

//! > expanded_cairo_code

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

#[starknet::interface]
trait IAllowedRefSelf<T> {
    fn spawn(ref self: T);
}

                #[starknet::contract]
                mod spawn {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'spawn'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod proxy {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'proxy'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        fn execute(value: felt252) -> felt252 {
        value
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod ctxnamed {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'ctxnamed'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod withevent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'withevent'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        TestEvent: TestEvent
            }
            
    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }

            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
impl TestEventDrop of core::traits::Drop::<TestEvent>;
            
                }

                #[starknet::contract]
                mod withcomponent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'withcomponent'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
                        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage
            }
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::interface]
                trait IEmptyTrait<TContractState> {}

                #[starknet::interface]
                trait IFaultyTrait<TContractState> {
                    
    fn do_ref_self(ref self: TContractState);

    #[my_attr]
    fn do_with_attrs(self: @TContractState, p1: u8) -> u16;

                }

                #[starknet::contract]
                mod ContractAllowedRefSelf {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'ContractAllowedRefSelf'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
    impl AllowedImpl of IAllowedRefSelf<ContractState> {
        fn spawn(ref self: ContractState) {}
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::interface]
                trait INominalTrait<TContractState> {
                        fn do_no_param(self: @TContractState);
    fn do_no_param_but_self(self: @TContractState);
    fn do_params(self: @TContractState, p1: dojo_examples::models::Direction, p2: u8);
    fn do_params_and_self(self: @TContractState, p2: u8);
    fn do_return_value(self: @TContractState, p1: u8) -> u16;

                }

                #[starknet::interface]
                trait IWorldTrait<TContractState> {
                        fn do_with_ref_self(self: @TContractState, ref self: ContractState) -> felt252;
    fn do_with_several_world_dispatchers(
self: @TContractState,         world: IWorldDispatcher, vec: Vec2, another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(self: @TContractState, another_world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_not_named_world(
self: @TContractState,         self: @ContractState, another_world: IWorldDispatcher
    );
    fn do_with_world_not_first(self: @TContractState, vec: Vec2, world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_not_first(
self: @TContractState,         self: @ContractState, vec: Vec2, world: IWorldDispatcher
    ) -> felt252;

                }

                #[starknet::contract]
                mod MyFaultyContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'MyFaultyContract'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
    impl TestWorldImpl of IWorldTrait<ContractState> {
        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }

        fn do_with_several_world_dispatchers(
self: @ContractState,             world: IWorldDispatcher, vec: Vec2, another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_named_world(self: @ContractState, another_world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_not_named_world(
            self: @ContractState, another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(self: @ContractState, vec: Vec2, world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_not_first(
            self: @ContractState, vec: Vec2, world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod MyNominalContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::world::IDojoResourceProvider;

                    #[abi(embed_v0)]
                    impl DojoResourceProviderImpl of IDojoResourceProvider<ContractState> {
                        fn dojo_resource(self: @ContractState) -> felt252 {
                            'MyNominalContract'
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestWorldImpl of IWorldTrait<ContractState> {
        fn do(self: @ContractState, vec: Vec2) -> felt252 {
            'land'
        }

        fn do_with_self(self: @ContractState, vec: Vec2) -> felt252 {
            'land'
        }

        fn do_with_world_first(self: @ContractState, vec: Vec2) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_with_self_and_world_first(
            self: @ContractState, vec: Vec2
        ) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }

            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl ActionDrop of core::traits::Drop::<Action>;
    trait InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252;
    }
impl EventDrop of core::traits::Drop::<Event>;
            
                }
