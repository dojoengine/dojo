//! > Test expansion of the #[system].

//! > test_runner_name
test_expand_plugin

//! > test_id
system

//! > cairo_code
#[dojo::contract(namespace: "My@Namespace")]
mod bad_namespace_format {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: 'my_namespace')]
mod spawn {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: "my_namespace")]
mod proxy {
    fn execute(value: felt252) -> felt252 {
        value
    }
}

#[dojo::contract]
mod ctxnamed {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract]
mod withevent {
    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        TestEvent: TestEvent,
    }

    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }
}

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

#[dojo::contract]
mod withcomponent {
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event,
    }
}
#[dojo::interface]
trait IEmptyTrait;

#[dojo::interface]
trait IFaultyTrait {
    const ONE: u8;

    #[my_attr]
    fn do_with_attrs(p1: u8) -> u16;
}

#[dojo::interface]
trait INominalTrait {
    fn do_no_param() -> felt252;
    fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252;
    fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252;
    fn do_params_no_world(p1: felt252, p2: u8) -> felt252;
    fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252;
    fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252;

    fn do_with_self(self: @ContractState) -> felt252;
    fn do_with_ref_self(ref self: ContractState) -> felt252;
}

#[dojo::interface]
trait IFaultyTrait {
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    fn do_with_ref_self_and_world_inv(
        ref world: IWorldDispatcher, ref self: ContractState
    ) -> felt252;
    fn do_with_several_world_dispatchers(
        world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252;
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
}

#[dojo::contract]
mod MyFaultyContract {
    #[abi(embed_v0)]
    impl TestFaultyImpl of IFaultyTrait<ContractState> {
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world(
            ref self: ContractState, ref world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world_inv(
            ref world: IWorldDispatcher, ref self: ContractState
        ) -> felt252 {
            'land'
        }

        fn do_with_several_world_dispatchers(
            world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl InternalImplBad of InternalUtils<ContractState> {
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
            'land'
        }
    }
}

#[dojo::contract]
mod MyNominalContract {
    #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestNominalImpl of INominalTrait<ContractState> {
        fn do_no_param() -> felt252 {
            'land'
        }

        fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_params_no_world(p1: felt252, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_with_self(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }
}

#[dojo::contract]
mod init_test {
    fn dojo_init(
        world: IWorldDispatcher,
        actions_address: ContractAddress,
        actions_class: ClassHash,
        value: u8
    ) {
        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
    }
}

#[dojo::contract]
mod no_init_test {}

//! > generated_cairo_code
#[starknet::contract]
mod spawn {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'spawn'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx: Context, name: felt252) {
        return ();
    }
}


#[starknet::contract]
mod proxy {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'proxy'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }


    #[abi(embed_v0)]
    fn execute(self: @ContractState, value: felt252) -> felt252 {
        value
    }
}


#[starknet::contract]
mod ctxnamed {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'ctxnamed'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx2: Context, name: felt252) {
        return ();
    }
}

//! > expected_diagnostics
error: Anything other than functions is not supported in a dojo::interface
 --> /tmp/plugin_test/system/src/lib.cairo:90:5
    const ONE: u8;
    ^************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^***********************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^*********************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/system/src/lib.cairo:113:5
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    ^***************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/system/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^****************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:128:9
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
        ^************************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:132:9
        fn do_with_ref_self_and_world(
        ^****************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/system/src/lib.cairo:138:9
        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
        ^****************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/system/src/lib.cairo:142:9
        fn do_with_ref_self_and_world_inv(
        ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/system/src/lib.cairo:158:9
        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
        ^*****************************************************************************^

error: You cannot use `world` and `#[generate_trait]` together. Use `self` instead.
 --> /tmp/plugin_test/system/src/lib.cairo:165:9
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
        ^***************************************************************^

error: World parameter must be a snapshot if `ref` is not used.
 --> /tmp/plugin_test/system/src/lib.cairo:224:5
    fn dojo_init(
    ^***********^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/system/src/lib.cairo:105:5
    fn do_with_self(self: @ContractState) -> felt252;
    ^**********************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/system/src/lib.cairo:106:5
    fn do_with_ref_self(ref self: ContractState) -> felt252;
    ^*****************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/system/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^**********************************************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/system/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/system/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/system/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/system/src/lib.cairo:117:5
    fn do_with_several_world_dispatchers(
    ^***********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/system/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^***************************************************************************^

error: Generated trait must have generic args matching the impl's generic params.
 --> /tmp/plugin_test/system/src/lib.cairo:163:5
    #[generate_trait]
    ^***************^

//! > expanded_cairo_code

#[starknet::component]
mod testcomponent1 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

#[starknet::component]
mod testcomponent2 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        StorageStorageBase {
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        StorageStorageBaseMut {
        }
    }
}

pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ComponentState<TContractState>) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
}

                #[starknet::contract]
                pub mod bad_namespace_format {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "bad_namespace_format"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-bad_namespace_format"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2014299465256018364248618312205774234949844604916563661777686628154176783488
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1674441257224597091124008266787844860104091058063661385750024717220711878589
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod spawn {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "spawn"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-spawn"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2776321589048333240377325502911505147617911439383944762363370901236132332849
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            68455752117050128185302950891816466897876546944174376812212671562113328733
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod proxy {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "proxy"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-proxy"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            379211399603323842291430789821178524592027629543381998047225121027704003915
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1940415311068338004979133415474511940700681073349244306389458906719593210527
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        fn execute(value: felt252) -> felt252 {
        value
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod ctxnamed {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "ctxnamed"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-ctxnamed"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1120614286815912604239420768209466007446460277061516527925636408561239543041
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1088922133313711214547564678240399488767278073212336739350382494993498982824
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod withevent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "withevent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-withevent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2196275886623691942883456540767114081898043897719876113518403014973431884540
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3549898308100844368972151697544420289462059777504886668025232769583717017648
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
                        TestEvent: TestEvent
            }
            
    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::TestEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("TestEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("TestEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::TestEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl EventTestEventIntoEvent of Into<TestEvent, Event> {
    fn into(self: TestEvent) -> Event {
        Event::TestEvent(self)
    }
}
impl TestEventDrop of core::traits::Drop::<TestEvent>;
impl TestEventIsEvent of starknet::Event<TestEvent> {
    fn append_keys_and_data(
        self: @TestEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
            core::serde::Serde::serialize(self.address, ref data);
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<TestEvent> {
                let address = core::serde::Serde::deserialize(
                    ref data
                )?;
        Option::Some(TestEvent {address, })
    }
}
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod withcomponent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "withcomponent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-withcomponent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            999850881662666048155666650426666132968026605763740651763663703103974774091
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3051237314154062498758064027519150695325862034415997374893619833554034627226
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
                        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event
            }
            
                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
                        #[substorage(v0)]
        pub testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        pub testcomponent2_storage: testcomponent2::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
    pub testcomponent1_storage: starknet::storage::FlattenedStorage<testcomponent1::Storage>,
    pub testcomponent2_storage: starknet::storage::FlattenedStorage<testcomponent2::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        let testcomponent1_storage_value = starknet::storage::FlattenedStorage {};
        let testcomponent2_storage_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
           testcomponent1_storage: testcomponent1_storage_value,
           testcomponent2_storage: testcomponent2_storage_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
    pub testcomponent1_storage: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<testcomponent1::Storage>>,
    pub testcomponent2_storage: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<testcomponent2::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        let testcomponent1_storage_value = starknet::storage::FlattenedStorage {};
        let testcomponent2_storage_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
           testcomponent1_storage: testcomponent1_storage_value,
           testcomponent2_storage: testcomponent2_storage_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
        pub testcomponent1_storage: testcomponent1::ComponentState<ContractState>,
        pub testcomponent2_storage: testcomponent2::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
            testcomponent1_storage: testcomponent1::unsafe_new_component_state::<ContractState>(),
            testcomponent2_storage: testcomponent2::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl HasComponentImpl_testcomponent1 of testcomponent1::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent1::ComponentState<ContractState> {
                 @testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent1::ComponentState<ContractState> {
        testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent1::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent1::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent1::Event>>(ref self: testcomponent1::ComponentState<ContractState>, event: S) {
        let event: testcomponent1::Event = core::traits::Into::into(event);
        let mut contract = testcomponent1::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent1_event(event));
    }
}
impl HasComponentImpl_testcomponent2 of testcomponent2::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent2::ComponentState<ContractState> {
                 @testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent2::ComponentState<ContractState> {
        testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent2::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent2::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent2::Event>>(ref self: testcomponent2::ComponentState<ContractState>, event: S) {
        let event: testcomponent2::Event = core::traits::Into::into(event);
        let mut contract = testcomponent2::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent2_event(event));
    }
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent1_event(val) => {
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent2_event(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("testcomponent2_event"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        {
            let mut keys = keys;
            let mut data = data;
            match starknet::Event::deserialize(ref keys, ref data) {
                Option::Some(val) => {
                    return Option::Some(Event::testcomponent1_event(val));
                },
                Option::None => {},
            };
        }
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("testcomponent2_event") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::testcomponent2_event(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl Eventtestcomponent1_eventIntoEvent of Into<testcomponent1::Event, Event> {
    fn into(self: testcomponent1::Event) -> Event {
        Event::testcomponent1_event(self)
    }
}
impl Eventtestcomponent2_eventIntoEvent of Into<testcomponent2::Event, Event> {
    fn into(self: testcomponent2::Event) -> Event {
        Event::testcomponent2_event(self)
    }
}
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
                
                }

                #[starknet::interface]
                pub trait IEmptyTrait<TContractState> {}

                #[starknet::interface]
                pub trait IFaultyTrait<TContractState> {
                    fn do_with_attrs(self: @TContractState, p1: u8) -> u16;
                }

                #[starknet::interface]
                pub trait INominalTrait<TContractState> {
                    fn do_no_param(self: @TContractState) -> felt252;fn do_no_param_but_world(self: @TContractState) -> felt252;fn do_no_param_but_world_ref(ref self: TContractState) -> felt252;fn do_params_no_world(self: @TContractState, p1: felt252, p2: u8) -> felt252;fn do_params_and_world(self: @TContractState, p2: u8) -> felt252;fn do_params_and_world_ref(ref self: TContractState, p2: u8) -> felt252;fn do_with_self(self: @ContractState) -> felt252;fn do_with_ref_self(ref self: ContractState) -> felt252;
                }

                #[starknet::interface]
                pub trait IFaultyTrait<TContractState> {
                    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;fn do_with_self_and_world_inv(self: @TContractState, self: @ContractState) -> felt252;fn do_with_ref_self_and_world_inv(ref self: TContractState, ref self: ContractState
) -> felt252;fn do_with_several_world_dispatchers(self: @TContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252;fn do_with_world_not_named_world(self: @TContractState, another_world: @IWorldDispatcher) -> felt252;fn do_with_world_not_first(self: @TContractState, vec: Vec2, ref world: IWorldDispatcher) -> felt252;
                }

                #[starknet::contract]
                pub mod MyFaultyContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "MyFaultyContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-MyFaultyContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            3439743807865759203015037013733809315384408083697880336790137144257764256358
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3304414327641815709216225681190245445308480446755012097234787467696641395890
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
 impl TestFaultyImpl  of IFaultyTrait<ContractState>  {fn do_with_self_and_world(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self_and_world(            ref self: ContractState) -> felt252  {            'land'
}fn do_with_self_and_world_inv(self: @ContractState, self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_ref_self_and_world_inv(ref self: ContractState, ref self: ContractState
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_several_world_dispatchers(self: @ContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_world_not_named_world(self: @ContractState, another_world: @IWorldDispatcher) -> felt252  {            'land'
}fn do_with_world_not_first(self: @ContractState, vec: Vec2) -> felt252  {            'land'
}}
    #[generate_trait]
 impl InternalImplBad  of InternalUtils<ContractState>  {fn bad_func_using_generate(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}}
                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
    trait InternalUtils{fn bad_func_using_generate(self: @ContractState) -> felt252;
}
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world_inv(@contract_state, __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let mut __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world_inv(ref contract_state, ref __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<ContractState>::serialize(@__arg_self, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_several_world_dispatchers(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let mut __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_several_world_dispatchers(@contract_state, __arg_vec, ref __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<IWorldDispatcher>::serialize(@__arg_another_world, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_named_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_named_world(@contract_state, __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_first(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_first(@contract_state, __arg_vec);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world as do_with_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world as do_with_ref_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world_inv as do_with_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv as do_with_ref_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_several_world_dispatchers as do_with_several_world_dispatchers;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_named_world as do_with_world_not_named_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_first as do_with_world_not_first;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod MyNominalContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "MyNominalContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-MyNominalContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1172628497499445169993220559087829230676589931723677494032285307738203070578
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1466845198188516049094649763342542731381088471625065496527510975945391631525
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
 impl TestNominalImpl  of INominalTrait<ContractState>  {fn do_no_param(self: @ContractState) -> felt252  {            'land'
}fn do_no_param_but_world(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_no_param_but_world_ref(ref self: ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_no_world(self: @ContractState, p1: felt252, p2: u8) -> felt252  {            'land'
}fn do_params_and_world(self: @ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_and_world_ref(ref self: ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_self(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self(ref self: ContractState) -> felt252  {            'land'
}}
    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }

                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
impl ActionDrop of core::traits::Drop::<Action>;
    trait InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252;
    }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world_ref(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_no_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p1 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<felt252>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_no_world(@contract_state, __arg_p1, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world(@contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world_ref(ref contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_self(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_ref_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_ref_self(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestNominalImpl__do_no_param as do_no_param;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world as do_no_param_but_world;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world_ref as do_no_param_but_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_params_no_world as do_params_no_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world as do_params_and_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world_ref as do_params_and_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_with_self as do_with_self;
    pub use super::__wrapper__TestNominalImpl__do_with_ref_self as do_with_ref_self;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1673722391095039242574232979635399085098867563460816803458086922970092209409
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3030310726300416277764466172753931798577418912153146471062249714457767216078
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    #[starknet::interface]
            pub trait IDojoInit<ContractState> {
                fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
            }
            
            #[abi(embed_v0)]
            pub impl IDojoInitImpl of IDojoInit<ContractState> {
            fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {let world = self.world_dispatcher.read();if starknet::get_caller_address() != self.world().contract_address { core::panics::panic_with_byte_array(@format!("Only the world can init contract `{}`, but caller is `{:?}`", self.tag(), starknet::get_caller_address())); }        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
}
}
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
            pub trait IDojoInitDispatcherTrait<T> {
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
            pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                fn dojo_init(self: IDojoInitDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
            pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                fn dojo_init(self: IDojoInitLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

            pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
            pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                fn dojo_init(self: IDojoInitSafeLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
            pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                fn dojo_init(self: IDojoInitSafeDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_actions_address = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractAddress>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_actions_class = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ClassHash>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    let __arg_value = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #3'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, __arg_actions_address, __arg_actions_class, __arg_value);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }

                #[starknet::contract]
                pub mod no_init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn name(self: @ContractState) -> ByteArray {
                            "no_init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_test"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_test-no_init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2188407785440294979090510634648735461326850740369373015349552249835679156474
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            1452123528942907587532668415362544424816022573043154497385993678618948064048
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1612380646418854749267717900057829622040529970486094087524750323429009828706
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
                    #[starknet::interface]
                    pub trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    pub impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            if starknet::get_caller_address() != self.world().contract_address {
                                core::panics::panic_with_byte_array(
                                    @format!("Only the world can init contract `{}`, but caller is `{:?}`",
                                    self.tag(),
                                    starknet::get_caller_address(),
                                ));
                            }
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
                    pub trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

                    pub trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                    pub struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
        pub world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
        pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct StorageStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::FlattenedStorage<dojo::contract::upgradeable::upgradeable::Storage>,
}
impl StorageStorageImpl of starknet::storage::StorageTrait<Storage> {
    type BaseType = StorageStorageBase;
    fn storage(self: starknet::storage::FlattenedStorage<Storage>) -> StorageStorageBase {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBase {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct StorageStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable::<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageStorageMutImpl of starknet::storage::StorageTraitMut<Storage> {
    type BaseType = StorageStorageBaseMut;
    fn storage_mut(self: starknet::storage::FlattenedStorage<starknet::storage::Mutable::<Storage>>) -> StorageStorageBaseMut {
        let world_dispatcher_value = starknet::storage::StorageBase {__base_address__: selector!("world_dispatcher")};
        let upgradeable_value = starknet::storage::FlattenedStorage {};
        StorageStorageBaseMut {
           world_dispatcher: world_dispatcher_value,
           upgradeable: upgradeable_value,
        }
    }
}

pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = starknet::storage::FlattenedStorage<Storage>;
    fn snapshot_deref(self: @ContractState) -> starknet::storage::FlattenedStorage<Storage> {
        starknet::storage::FlattenedStorage {}
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> ;
    fn deref_mut(ref self: ContractState) -> starknet::storage::FlattenedStorage<starknet::storage::Mutable<Storage>> {
        starknet::storage::FlattenedStorage {}
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__name as name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitDispatcher> {
    type SubPointersType = IDojoInitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> IDojoInitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitLibraryDispatcher> {
    type SubPointersType = IDojoInitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> IDojoInitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeLibraryDispatcher> {
    type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> IDojoInitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IDojoInitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IDojoInitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IDojoInitSafeDispatcher> {
    type SubPointersType = IDojoInitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> IDojoInitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IDojoInitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl StorageStorageBaseDrop of core::traits::Drop::<StorageStorageBase>;
impl StorageStorageBaseCopy of core::traits::Copy::<StorageStorageBase>;
impl StorageStorageBaseMutDrop of core::traits::Drop::<StorageStorageBaseMut>;
impl StorageStorageBaseMutCopy of core::traits::Copy::<StorageStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointersMut>;
impl IDojoInitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointersMut>;
            
                }
                pub trait IEmptyTraitDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitLibraryDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitLibraryDispatcher> {

}

                pub trait IEmptyTraitSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitSafeLibraryDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitSafeDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeDispatcher> {

}
                pub trait IFaultyTraitDispatcherTrait<T> {
                    fn do_with_attrs(self: T, p1: u8) -> u16;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitLibraryDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_with_attrs(self: T, p1: u8) -> starknet::SyscallResult<u16>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeLibraryDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
                pub trait INominalTraitDispatcherTrait<T> {
                    fn do_no_param(self: T) -> felt252;
fn do_no_param_but_world(self: T) -> felt252;
fn do_no_param_but_world_ref(self: T) -> felt252;
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> felt252;
fn do_params_and_world(self: T, p2: u8) -> felt252;
fn do_params_and_world_ref(self: T, p2: u8) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitDispatcher> {
                    fn do_no_param(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitLibraryDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitLibraryDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait INominalTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_no_param(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world_ref(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world_ref(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitSafeLibraryDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeLibraryDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitSafeDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeDispatcher> {
                    fn do_no_param(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
                pub trait IFaultyTraitDispatcherTrait<T> {
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> felt252;
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitLibraryDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitLibraryDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeLibraryDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeLibraryDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
impl IEmptyTraitDispatcherCopy of core::traits::Copy::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherDrop of core::traits::Drop::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherSerde of core::serde::Serde::<IEmptyTraitDispatcher> {
    fn serialize(self: @IEmptyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitDispatcher> {
        core::option::Option::Some(IEmptyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitDispatcher of starknet::Store::<IEmptyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IEmptyTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IEmptyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitDispatcher> {
    type SubPointersType = IEmptyTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitDispatcher>) -> IEmptyTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IEmptyTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IEmptyTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IEmptyTraitDispatcher> {
    type SubPointersType = IEmptyTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitDispatcher>>) -> IEmptyTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IEmptyTraitLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitLibraryDispatcher of starknet::Store::<IEmptyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IEmptyTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IEmptyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitLibraryDispatcher> {
    type SubPointersType = IEmptyTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitLibraryDispatcher>) -> IEmptyTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IEmptyTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IEmptyTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IEmptyTraitLibraryDispatcher> {
    type SubPointersType = IEmptyTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitLibraryDispatcher>>) -> IEmptyTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IEmptyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeLibraryDispatcher of starknet::Store::<IEmptyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IEmptyTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IEmptyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitSafeLibraryDispatcher> {
    type SubPointersType = IEmptyTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitSafeLibraryDispatcher>) -> IEmptyTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IEmptyTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IEmptyTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IEmptyTraitSafeLibraryDispatcher> {
    type SubPointersType = IEmptyTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitSafeLibraryDispatcher>>) -> IEmptyTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IEmptyTraitSafeDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeDispatcher> {
    fn serialize(self: @IEmptyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeDispatcher of starknet::Store::<IEmptyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IEmptyTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IEmptyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitSafeDispatcher> {
    type SubPointersType = IEmptyTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitSafeDispatcher>) -> IEmptyTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IEmptyTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IEmptyTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IEmptyTraitSafeDispatcher> {
    type SubPointersType = IEmptyTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitSafeDispatcher>>) -> IEmptyTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IEmptyTraitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitDispatcher> {
    type SubPointersType = IFaultyTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitDispatcher>) -> IFaultyTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IFaultyTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitDispatcher> {
    type SubPointersType = IFaultyTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitDispatcher>>) -> IFaultyTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitLibraryDispatcher> {
    type SubPointersType = IFaultyTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitLibraryDispatcher>) -> IFaultyTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IFaultyTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitLibraryDispatcher> {
    type SubPointersType = IFaultyTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitLibraryDispatcher>>) -> IFaultyTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeLibraryDispatcher> {
    type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeLibraryDispatcher>) -> IFaultyTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitSafeLibraryDispatcher> {
    type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeLibraryDispatcher>>) -> IFaultyTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeDispatcher> {
    type SubPointersType = IFaultyTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeDispatcher>) -> IFaultyTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IFaultyTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitSafeDispatcher> {
    type SubPointersType = IFaultyTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeDispatcher>>) -> IFaultyTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl INominalTraitDispatcherCopy of core::traits::Copy::<INominalTraitDispatcher>;
impl INominalTraitDispatcherDrop of core::traits::Drop::<INominalTraitDispatcher>;
impl INominalTraitDispatcherSerde of core::serde::Serde::<INominalTraitDispatcher> {
    fn serialize(self: @INominalTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitDispatcher> {
        core::option::Option::Some(INominalTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitDispatcher of starknet::Store::<INominalTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct INominalTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl INominalTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitDispatcher> {
    type SubPointersType = INominalTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitDispatcher>) -> INominalTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct INominalTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl INominalTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<INominalTraitDispatcher> {
    type SubPointersType = INominalTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitDispatcher>>) -> INominalTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl INominalTraitLibraryDispatcherCopy of core::traits::Copy::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherDrop of core::traits::Drop::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherSerde of core::serde::Serde::<INominalTraitLibraryDispatcher> {
    fn serialize(self: @INominalTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitLibraryDispatcher> {
        core::option::Option::Some(INominalTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitLibraryDispatcher of starknet::Store::<INominalTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct INominalTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl INominalTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitLibraryDispatcher> {
    type SubPointersType = INominalTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitLibraryDispatcher>) -> INominalTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct INominalTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl INominalTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<INominalTraitLibraryDispatcher> {
    type SubPointersType = INominalTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitLibraryDispatcher>>) -> INominalTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl INominalTraitSafeLibraryDispatcherCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherSerde of core::serde::Serde::<INominalTraitSafeLibraryDispatcher> {
    fn serialize(self: @INominalTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeLibraryDispatcher> {
        core::option::Option::Some(INominalTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeLibraryDispatcher of starknet::Store::<INominalTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct INominalTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl INominalTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitSafeLibraryDispatcher> {
    type SubPointersType = INominalTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitSafeLibraryDispatcher>) -> INominalTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct INominalTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl INominalTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<INominalTraitSafeLibraryDispatcher> {
    type SubPointersType = INominalTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitSafeLibraryDispatcher>>) -> INominalTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl INominalTraitSafeDispatcherCopy of core::traits::Copy::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherDrop of core::traits::Drop::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherSerde of core::serde::Serde::<INominalTraitSafeDispatcher> {
    fn serialize(self: @INominalTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeDispatcher> {
        core::option::Option::Some(INominalTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeDispatcher of starknet::Store::<INominalTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct INominalTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl INominalTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitSafeDispatcher> {
    type SubPointersType = INominalTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitSafeDispatcher>) -> INominalTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct INominalTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl INominalTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<INominalTraitSafeDispatcher> {
    type SubPointersType = INominalTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitSafeDispatcher>>) -> INominalTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                INominalTraitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitDispatcher> {
    type SubPointersType = IFaultyTraitDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitDispatcher>) -> IFaultyTraitDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IFaultyTraitDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitDispatcher> {
    type SubPointersType = IFaultyTraitDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitDispatcher>>) -> IFaultyTraitDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitLibraryDispatcher> {
    type SubPointersType = IFaultyTraitLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitLibraryDispatcher>) -> IFaultyTraitLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IFaultyTraitLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitLibraryDispatcher> {
    type SubPointersType = IFaultyTraitLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitLibraryDispatcher>>) -> IFaultyTraitLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeLibraryDispatcherSubPointers {
    pub class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeLibraryDispatcher> {
    type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeLibraryDispatcher>) -> IFaultyTraitSafeLibraryDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeLibraryDispatcherSubPointersMut {
    pub class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitSafeLibraryDispatcher> {
    type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeLibraryDispatcher>>) -> IFaultyTraitSafeLibraryDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let class_hash_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointersMut {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeDispatcherSubPointers {
    pub contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeDispatcher> {
    type SubPointersType = IFaultyTraitSafeDispatcherSubPointers;
    fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeDispatcher>) -> IFaultyTraitSafeDispatcherSubPointers {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
pub struct IFaultyTraitSafeDispatcherSubPointersMut {
    pub contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl IFaultyTraitSafeDispatcherSubPointersMutImpl of starknet::storage::SubPointersMut<IFaultyTraitSafeDispatcher> {
    type SubPointersType = IFaultyTraitSafeDispatcherSubPointersMut;
    fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeDispatcher>>) -> IFaultyTraitSafeDispatcherSubPointersMut {
        let base_address = self.__storage_pointer_address__;
        let mut current_offset = self.__storage_pointer_offset__;
        let contract_address_value = starknet::storage::StoragePointer {
            __storage_pointer_address__: base_address,
            __storage_pointer_offset__: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointersMut {
           contract_address: contract_address_value,
        }
    }
}
impl IEmptyTraitDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitDispatcherSubPointers>;
impl IEmptyTraitDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitDispatcherSubPointers>;
impl IEmptyTraitDispatcherSubPointersMutDrop of core::traits::Drop::<IEmptyTraitDispatcherSubPointersMut>;
impl IEmptyTraitDispatcherSubPointersMutCopy of core::traits::Copy::<IEmptyTraitDispatcherSubPointersMut>;
impl IEmptyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcherSubPointers>;
impl IEmptyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcherSubPointers>;
impl IEmptyTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcherSubPointersMut>;
impl IEmptyTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcherSubPointersMut>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcherSubPointers>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcherSubPointers>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcherSubPointersMut>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcherSubPointersMut>;
impl IEmptyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitSafeDispatcherSubPointers>;
impl IEmptyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitSafeDispatcherSubPointers>;
impl IEmptyTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IEmptyTraitSafeDispatcherSubPointersMut>;
impl IEmptyTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IEmptyTraitSafeDispatcherSubPointersMut>;
impl IFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointersMut>;
impl IFaultyTraitDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointersMut>;
impl IFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointersMut>;
impl IFaultyTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointersMut>;
impl IFaultyTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointersMut>;
impl INominalTraitDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitDispatcherSubPointers>;
impl INominalTraitDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitDispatcherSubPointers>;
impl INominalTraitDispatcherSubPointersMutDrop of core::traits::Drop::<INominalTraitDispatcherSubPointersMut>;
impl INominalTraitDispatcherSubPointersMutCopy of core::traits::Copy::<INominalTraitDispatcherSubPointersMut>;
impl INominalTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitLibraryDispatcherSubPointers>;
impl INominalTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitLibraryDispatcherSubPointers>;
impl INominalTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<INominalTraitLibraryDispatcherSubPointersMut>;
impl INominalTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<INominalTraitLibraryDispatcherSubPointersMut>;
impl INominalTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcherSubPointers>;
impl INominalTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcherSubPointers>;
impl INominalTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcherSubPointersMut>;
impl INominalTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcherSubPointersMut>;
impl INominalTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitSafeDispatcherSubPointers>;
impl INominalTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitSafeDispatcherSubPointers>;
impl INominalTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<INominalTraitSafeDispatcherSubPointersMut>;
impl INominalTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<INominalTraitSafeDispatcherSubPointersMut>;
impl IFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointersMut>;
impl IFaultyTraitDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointersMut>;
impl IFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointersMut>;
impl IFaultyTraitLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointersMut>;
impl IFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersMutDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointersMut>;
impl IFaultyTraitSafeDispatcherSubPointersMutCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointersMut>;
