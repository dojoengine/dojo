//! > Test expansion of the #[system].

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::contract(namespace: "My@Namespace")]
mod bad_namespace_format {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: 'my_namespace')]
mod spawn {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: "my_namespace")]
mod proxy {
    fn execute(value: felt252) -> felt252 {
        value
    }
}

#[dojo::contract]
mod ctxnamed {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract]
mod withevent {
    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        TestEvent: TestEvent,
    }

    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }
}

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

#[dojo::contract]
mod withcomponent {
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event,
    }
}
#[dojo::interface]
trait IEmptyTrait;

#[dojo::interface]
trait IFaultyTrait {
    const ONE: u8;

    #[my_attr]
    fn do_with_attrs(p1: u8) -> u16;
}

#[dojo::interface]
trait INominalTrait {
    fn do_no_param() -> felt252;
    fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252;
    fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252;
    fn do_params_no_world(p1: felt252, p2: u8) -> felt252;
    fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252;
    fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252;

    fn do_with_self(self: @ContractState) -> felt252;
    fn do_with_ref_self(ref self: ContractState) -> felt252;
}

#[dojo::interface]
trait IFaultyTrait {
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    fn do_with_ref_self_and_world_inv(
        ref world: IWorldDispatcher, ref self: ContractState
    ) -> felt252;
    fn do_with_several_world_dispatchers(
        world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252;
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
}

#[dojo::contract]
mod MyFaultyContract {
    #[abi(embed_v0)]
    impl TestFaultyImpl of IFaultyTrait<ContractState> {
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world(
            ref self: ContractState, ref world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world_inv(
            ref world: IWorldDispatcher, ref self: ContractState
        ) -> felt252 {
            'land'
        }

        fn do_with_several_world_dispatchers(
            world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl InternalImplBad of InternalUtils<ContractState> {
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
            'land'
        }
    }
}

#[dojo::contract]
mod MyNominalContract {
    #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestNominalImpl of INominalTrait<ContractState> {
        fn do_no_param() -> felt252 {
            'land'
        }

        fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_params_no_world(p1: felt252, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_with_self(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }
}

#[dojo::contract]
mod init_test {
    fn dojo_init(
        world: IWorldDispatcher,
        actions_address: ContractAddress,
        actions_class: ClassHash,
        value: u8
    ) {
        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
    }
}

#[dojo::contract]
mod no_init_test {}

//! > generated_cairo_code
#[starknet::contract]
mod spawn {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'spawn'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx: Context, name: felt252) {
        return ();
    }
}


#[starknet::contract]
mod proxy {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'proxy'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }


    #[abi(embed_v0)]
    fn execute(self: @ContractState, value: felt252) -> felt252 {
        value
    }
}


#[starknet::contract]
mod ctxnamed {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'ctxnamed'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx2: Context, name: felt252) {
        return ();
    }
}

//! > expected_diagnostics
error: The contract namespace 'My@Namespace' can only contain characters (a-z/A-Z), numbers (0-9) and underscore (_)
 --> test_src/lib.cairo:1:1
#[dojo::contract(namespace: "My@Namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:52:1
#[starknet::component]
^********************^

error: Unsupported attribute.
 --> test_src/lib.cairo:58:1
#[starknet::component]
^********************^

error: Anything other than functions is not supported in a dojo::interface
 --> test_src/lib.cairo:90:5
    const ONE: u8;
    ^************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^***********************************************************************************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^*********************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> test_src/lib.cairo:113:5
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    ^***************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> test_src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^****************************************************************************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:128:9
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
        ^************************************************************************************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:132:9
        fn do_with_ref_self_and_world(
        ^****************************^

error: You cannot use `self` and `world` parameters together.
 --> test_src/lib.cairo:138:9
        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
        ^****************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> test_src/lib.cairo:142:9
        fn do_with_ref_self_and_world_inv(
        ^********************************^

error: World parameter must be the first parameter.
 --> test_src/lib.cairo:158:9
        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
        ^*****************************************************************************^

error: You cannot use `world` and `#[generate_trait]` together. Use `self` instead.
 --> test_src/lib.cairo:165:9
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
        ^***************************************************************^

error: World parameter must be a snapshot if `ref` is not used.
 --> test_src/lib.cairo:224:5
    fn dojo_init(
    ^***********^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:92:5
    #[my_attr]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:54:5
    #[storage]
    ^********^

error: Unsupported attribute.
 --> test_src/lib.cairo:60:5
    #[storage]
    ^********^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:11:1
#[dojo::contract(namespace: 'my_namespace')]
^******************************************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:21:1
#[dojo::contract(namespace: "my_namespace")]
^******************************************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:28:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:38:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:66:5
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    ^*********************************************************************************************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:67:5
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);
    ^*********************************************************************************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:64:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:126:5
    #[abi(embed_v0)]
    ^**************^

error: Generated trait must have generic args matching the impl's generic params.
 --> test_src/lib.cairo:164:29
    impl InternalImplBad of InternalUtils<ContractState> {
                            ^**************************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:124:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:178:5
    #[abi(embed_v0)]
    ^**************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:171:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:222:1
#[dojo::contract]
^***************^

error: Unknown inline item macro: 'component'.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

error: Unsupported attribute.
 --> test_src/lib.cairo:239:1
#[dojo::contract]
^***************^

//! > expanded_cairo_code
#[dojo::contract(namespace: "My@Namespace")]
mod bad_namespace_format {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

                #[starknet::contract]
                mod spawn {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "spawn"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            2776321589048333240377325502911505147617911439383944762363370901236132332849
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "my_namespace"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            1685136890688416384941629523783652800960468745356230625531475538826800548713
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "my_namespace-spawn"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod proxy {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "proxy"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            379211399603323842291430789821178524592027629543381998047225121027704003915
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "my_namespace"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            1685136890688416384941629523783652800960468745356230625531475538826800548713
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "my_namespace-proxy"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        fn execute(value: felt252) -> felt252 {
        value
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod ctxnamed {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "ctxnamed"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            1120614286815912604239420768209466007446460277061516527925636408561239543041
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-ctxnamed"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod withevent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withevent"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            2196275886623691942883456540767114081898043897719876113518403014973431884540
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-withevent"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        TestEvent: TestEvent
            }
            
    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
impl TestEventDrop of core::traits::Drop::<TestEvent>;
            
                }

                #[starknet::contract]
                mod withcomponent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withcomponent"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            999850881662666048155666650426666132968026605763740651763663703103974774091
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-withcomponent"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
                        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage
            }
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event
            }
            
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
impl EventDrop of core::traits::Drop::<Event>;
                
                }

                #[starknet::interface]
                trait IEmptyTrait<TContractState> {}

                #[starknet::interface]
                trait IFaultyTrait<TContractState> {
                    
    #[my_attr]
    fn do_with_attrs(self: @TContractState, p1: u8) -> u16;

                }

                #[starknet::interface]
                trait INominalTrait<TContractState> {
                        fn do_no_param(self: @TContractState) -> felt252;
    fn do_no_param_but_world(self: @TContractState) -> felt252;
    fn do_no_param_but_world_ref(ref self: TContractState) -> felt252;
    fn do_params_no_world(self: @TContractState, p1: felt252, p2: u8) -> felt252;
    fn do_params_and_world(self: @TContractState, p2: u8) -> felt252;
    fn do_params_and_world_ref(ref self: TContractState, p2: u8) -> felt252;

    fn do_with_self(self: @ContractState) -> felt252;
    fn do_with_ref_self(ref self: ContractState) -> felt252;

                }

                #[starknet::interface]
                trait IFaultyTrait<TContractState> {
                        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_inv(self: @TContractState, self: @ContractState) -> felt252;
    fn do_with_ref_self_and_world_inv(
ref self: TContractState, ref self: ContractState
    ) -> felt252;
    fn do_with_several_world_dispatchers(
self: @TContractState, vec: Vec2, ref another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(self: @TContractState, another_world: @IWorldDispatcher) -> felt252;
    fn do_with_world_not_first(self: @TContractState, vec: Vec2, ref world: IWorldDispatcher) -> felt252;

                }

                #[starknet::contract]
                mod MyFaultyContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyFaultyContract"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            3439743807865759203015037013733809315384408083697880336790137144257764256358
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-MyFaultyContract"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
    impl TestFaultyImpl of IFaultyTrait<ContractState> {
        fn do_with_self_and_world(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world(
            ref self: ContractState        ) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_inv(self: @ContractState, self: @ContractState) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_with_ref_self_and_world_inv(
ref self: ContractState, ref self: ContractState
        ) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_with_several_world_dispatchers(
self: @ContractState, vec: Vec2, ref another_world: IWorldDispatcher
        ) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_with_world_not_named_world(self: @ContractState, another_world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(self: @ContractState, vec: Vec2) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl InternalImplBad of InternalUtils<ContractState> {
        fn bad_func_using_generate(self: @ContractState) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
    trait InternalUtils{
        fn bad_func_using_generate(self: @ContractState) -> felt252;
    }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod MyNominalContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyNominalContract"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            1172628497499445169993220559087829230676589931723677494032285307738203070578
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-MyNominalContract"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestNominalImpl of INominalTrait<ContractState> {
        fn do_no_param(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_no_param_but_world(self: @ContractState) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_no_param_but_world_ref(ref self: ContractState) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_params_no_world(self: @ContractState, p1: felt252, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world(self: @ContractState, p2: u8) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_params_and_world_ref(ref self: ContractState, p2: u8) -> felt252 {
let world = self.world_dispatcher.read();
            'land'
        }

        fn do_with_self(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl ActionDrop of core::traits::Drop::<Action>;
    trait InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252;
    }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "init_test"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            1673722391095039242574232979635399085098867563460816803458086922970092209409
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-init_test"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
                #[starknet::interface]
                trait IDojoInit<ContractState> {
                    fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
                }

                #[abi(embed_v0)]
                impl IDojoInitImpl of IDojoInit<ContractState> {
                    fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
                        let world = self.world_dispatcher.read();
                        assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        {
        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
    }

                    }
                }
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }

                #[starknet::contract]
                mod no_init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "no_init_test"
                        }
                        fn selector(self: @ContractState) -> felt252 {
                            2188407785440294979090510634648735461326850740369373015349552249835679156474
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "dojo_plugin"
                        }

                        fn namespace_selector(self: @ContractState) -> felt252 {
                            3437408695301308226171664635441698996501144546809569617702850025816833723775
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "dojo_plugin-no_init_test"
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
            
            #[storage]
            struct Storage {
                world_dispatcher: IWorldDispatcher,
                #[substorage(v0)]
                upgradeable: dojo::components::upgradeable::upgradeable::Storage,
            }
impl EventDrop of core::traits::Drop::<Event>;
            
                }
