//! > Test expansion of the component contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
use array::ArrayTrait;

#[derive(Component)]
struct Position {
    x: felt252,
    y: felt252,
}

#[derive(Component)]
struct Player {
    name: felt252, 
}

#[system]
mod SpawnSystem {
    use traits::Into;   
    use starknet::contract_address::ContractAddressIntoFelt252;

    use dojo::commands::Spawn;

    use super::Position;
    use super::IPositionDispatcher;
    use super::IPositionDispatcherTrait;
    use super::Player;
    use super::IPlayerDispatcher;
    use super::IPlayerDispatcherTrait;

    fn execute(name: felt252) {
        let uuid = commands::uuid();
        let player = commands::spawn((420, (69, uuid)).into(), (
            Player { name: name },
            Position { x: 0, y: 0 },
        ));

        let literal = commands::spawn(420.into(), (
            Player { name: name },
            Position { x: 0, y: 0 },
        ));

        let player_id = starknet::get_caller_address();
        let player = commands::spawn(player_id.into(), (
            Player { name: name },
            Position { x: 0, y: 0 },
        ));

        let invalid_args = commands::spawn((
            Player { name: name },
            Position { x: 0, y: 0 },
        ));

        // let invalid_path = Spawn::spawn((0, 0, 0, 0, 0), (
        //     Player { name: name },
        //     Position { x: 0, y: 0 },
        // ));
        return ();
    }
}

#[system]
mod MoveSystem {
    use traits::Into;
    use array::ArrayTrait;
    use dojo::query::Query;
    use super::Position;
    use super::IPositionDispatcher;
    use super::IPositionDispatcherTrait;
    use super::Player;
    use super::IPlayerDispatcher;
    use super::IPlayerDispatcherTrait;

    fn move_inner(positions: @Array<usize>, index: u32, count: u32) {
        return move_inner(positions, index + 1_u32, count - 1_u32);
    }

    fn execute(player_id: felt252) {
        let positions_query = Query::<(Position, Player)>::ids();
        let players_query = Query::<Player>::ids();
        let player = Query::<Player>::entity(player_id.into());
        let player_position = Query::<(Position, Player)>::entity(player_id.into());

        let mut bar = 123;
        let mut foo = ArrayTrait::<felt252>::new();
        foo.append(bar);

        move_inner(@positions_query, 0_u32, positions_query.len());

        if bar == 123 {
            return ();
        } else if bar == 0 {
            return ();
        } else {
            return ();
        }
    }
}

//! > generated_cairo_code
use array::ArrayTrait;

#[derive(Copy, Drop)]
struct Position {
    x: felt252,
    y: felt252,
}

#[abi]
trait IPosition {
    fn set(key: felt252, value: Position);
    fn get(key: felt252) -> Position;
    fn get_is_writer_authorized(writer: starknet::ContractAddress) -> bool;
}

#[contract]
mod PositionComponent {
    use option::OptionTrait;
    use array::ArrayTrait;
    use box::BoxTrait;
    use starknet::SyscallResult;
    use starknet::ContractAddress;
    use traits::Into;
    use traits::TryInto;

    use super::Position;

    impl PositionSerde of serde::Serde::<Position> {
        fn serialize(ref serialized: Array::<felt252>, input: Position) {
            serde::Serde::<felt252>::serialize(ref serialized, input.x);
            serde::Serde::<felt252>::serialize(ref serialized, input.y);
        }
        fn deserialize(ref serialized: Span::<felt252>) -> Option::<Position> {
            Option::Some(
                Position {
                    x: serde::Serde::<felt252>::deserialize(ref serialized)?,
                    y: serde::Serde::<felt252>::deserialize(ref serialized)?,
                }
            )
        }
    }

    impl StorageAccessPosition of starknet::StorageAccess::<Position> {
        fn read(
            address_domain: u32, base: starknet::StorageBaseAddress
        ) -> starknet::SyscallResult::<Position> {
            Result::Ok(
                Position {
                    x: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                    )?,
                    y: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8)
                    )?,
                }
            )
        }
        fn write(
            address_domain: u32, base: starknet::StorageBaseAddress, value: Position
        ) -> starknet::SyscallResult::<()> {
            starknet::storage_write_syscall(
                address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8), value.x
            )?;
            starknet::storage_write_syscall(
                address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8), value.y
            )
        }
    }


    struct Storage {
        state: LegacyMap::<felt252, Position>, 
        authorized_writers: LegacyMap::<ContractAddress, bool>,
    }

    // Initialize Position.
    #[external]
    fn initialize(writers: Array<ContractAddress>) {
        initialize_inner(@writers, 0_usize);
    }

    fn initialize_inner(writers: @Array<ContractAddress>, i: usize) {
        match writers.get(i) {
            Option::Some(w) => {
                authorized_writers::write(*w.unbox(), true);
                initialize_inner(writers, i + 1_usize);
            },
            Option::None(()) => (),
        }
    }

    // Set the state of an entity.
    #[external]
    fn set(key: felt252, value: Position) {
        let caller_address = starknet::get_caller_address();
        let is_authorized = authorized_writers::read(caller_address);
        assert(is_authorized, 'Unauthorized writer.');
        state::write(key, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(key: felt252) -> Position {
        return state::read(key);
    }

    // True if the writer is authorized to modify entities state.
    #[view]
    fn get_is_writer_authorized(writer: ContractAddress) -> bool {
        return authorized_writers::read(writer);
    }
}

#[derive(Copy, Drop)]
struct Player {
    name: felt252, 
}

#[abi]
trait IPlayer {
    fn set(key: felt252, value: Player);
    fn get(key: felt252) -> Player;
    fn get_is_writer_authorized(writer: starknet::ContractAddress) -> bool;
}

#[contract]
mod PlayerComponent {
    use option::OptionTrait;
    use array::ArrayTrait;
    use box::BoxTrait;
    use starknet::SyscallResult;
    use starknet::ContractAddress;
    use traits::Into;
    use traits::TryInto;

    use super::Player;

    impl PlayerSerde of serde::Serde::<Player> {
        fn serialize(ref serialized: Array::<felt252>, input: Player) {
            serde::Serde::<felt252>::serialize(ref serialized, input.name);
        }
        fn deserialize(ref serialized: Span::<felt252>) -> Option::<Player> {
            Option::Some(Player { name: serde::Serde::<felt252>::deserialize(ref serialized)?,  })
        }
    }

    impl StorageAccessPlayer of starknet::StorageAccess::<Player> {
        fn read(
            address_domain: u32, base: starknet::StorageBaseAddress
        ) -> starknet::SyscallResult::<Player> {
            Result::Ok(
                Player {
                    name: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                    )?,
                }
            )
        }
        fn write(
            address_domain: u32, base: starknet::StorageBaseAddress, value: Player
        ) -> starknet::SyscallResult::<()> {
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 0_u8),
                value.name
            )
        }
    }


    struct Storage {
        state: LegacyMap::<felt252, Player>, 
        authorized_writers: LegacyMap::<ContractAddress, bool>,
    }

    // Initialize Player.
    #[external]
    fn initialize(writers: Array<ContractAddress>) {
        initialize_inner(@writers, 0_usize);
    }

    fn initialize_inner(writers: @Array<ContractAddress>, i: usize) {
        match writers.get(i) {
            Option::Some(w) => {
                authorized_writers::write(*w.unbox(), true);
                initialize_inner(writers, i + 1_usize);
            },
            Option::None(()) => (),
        }
    }

    // Set the state of an entity.
    #[external]
    fn set(key: felt252, value: Player) {
        let caller_address = starknet::get_caller_address();
        let is_authorized = authorized_writers::read(caller_address);
        assert(is_authorized, 'Unauthorized writer.');
        state::write(key, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(key: felt252) -> Player {
        return state::read(key);
    }

    // True if the writer is authorized to modify entities state.
    #[view]
    fn get_is_writer_authorized(writer: ContractAddress) -> bool {
        return authorized_writers::read(writer);
    }
}

#[contract]
mod SpawnSystem {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;
    use dojo::storage::StorageKey;
    use dojo::storage::StorageKeyTrait;
    use dojo::storage::Felt252IntoStorageKey;
    use dojo::storage::TupleSize1IntoStorageKey;
    use dojo::storage::TupleSize2IntoStorageKey;
    use dojo::storage::TupleSize3IntoStorageKey;
    use dojo::storage::TupleSize1IntoPartitionedStorageKey;
    use dojo::storage::TupleSize2IntoPartitionedStorageKey;
    use dojo::storage::ContractAddressIntoStorageKey;


    use traits::Into;
    use starknet::contract_address::ContractAddressIntoFelt252;

    use dojo::commands::Spawn;

    use super::Position;
    use super::IPositionDispatcher;
    use super::IPositionDispatcherTrait;
    use super::Player;
    use super::IPlayerDispatcher;
    use super::IPlayerDispatcherTrait;

    #[external]
    fn execute(name: felt252) {
        let world_address = starknet::contract_address_const::<0x0>();
        let uuid = IWorldDispatcher { contract_address: world_address }.uuid();
        let __player_sk: dojo::storage::StorageKey = (420, (69, uuid)).into();
        let __player_sk_id = __player_sk.id();
        IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.set(__player_sk_id, Player { name: name });
        IPositionDispatcher {
            contract_address: starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        }.set(__player_sk_id, Position { x: 0, y: 0 });
        let __literal_sk: dojo::storage::StorageKey = 420.into();
        let __literal_sk_id = __literal_sk.id();
        IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.set(__literal_sk_id, Player { name: name });
        IPositionDispatcher {
            contract_address: starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        }.set(__literal_sk_id, Position { x: 0, y: 0 });

        let player_id = starknet::get_caller_address();
        let __player_sk: dojo::storage::StorageKey = player_id.into();
        let __player_sk_id = __player_sk.id();
        IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.set(__player_sk_id, Player { name: name });
        IPositionDispatcher {
            contract_address: starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        }.set(__player_sk_id, Position { x: 0, y: 0 });

        // let invalid_path = Spawn::spawn((0, 0, 0, 0, 0), (
        //     Player { name: name },
        //     Position { x: 0, y: 0 },
        // ));
        return ();
    }
}

#[contract]
mod MoveSystem {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;
    use dojo::storage::StorageKey;
    use dojo::storage::StorageKeyTrait;
    use dojo::storage::Felt252IntoStorageKey;
    use dojo::storage::TupleSize1IntoStorageKey;
    use dojo::storage::TupleSize2IntoStorageKey;
    use dojo::storage::TupleSize3IntoStorageKey;
    use dojo::storage::TupleSize1IntoPartitionedStorageKey;
    use dojo::storage::TupleSize2IntoPartitionedStorageKey;
    use dojo::storage::ContractAddressIntoStorageKey;


    use traits::Into;
    use array::ArrayTrait;
    use dojo::query::Query;
    use super::Position;
    use super::IPositionDispatcher;
    use super::IPositionDispatcherTrait;
    use super::Player;
    use super::IPlayerDispatcher;
    use super::IPlayerDispatcherTrait;

    fn move_inner(positions: @Array<usize>, index: u32, count: u32) {
        return move_inner(positions, index + 1_u32, count - 1_u32);
    }

    #[external]
    fn execute(player_id: felt252) {
        let world_address = starknet::contract_address_const::<0x0>();
        let positions_query = ArrayTrait::<usize>::new();
        let __positions_query_position_ids = IWorldDispatcher {
            contract_address: world_address
        }.entities(
            starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>(),
            0
        );

        let __positions_query_player_ids = IWorldDispatcher {
            contract_address: world_address
        }.entities(
            starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>(),
            0
        );
        let players_query = ArrayTrait::<usize>::new();
        let __players_query_player_ids = IWorldDispatcher {
            contract_address: world_address
        }.entities(
            starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>(),
            0
        );
        let __player_sk: dojo::storage::StorageKey = player_id.into();
        let __player_sk_id = __player_sk.id();
        let __player_player = IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.get(__player_sk_id);
        let player = __player_player;
        let __player_position_sk: dojo::storage::StorageKey = player_id.into();
        let __player_position_sk_id = __player_position_sk.id();
        let __player_position_position = IPositionDispatcher {
            contract_address: starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        }.get(__player_position_sk_id);

        let __player_position_player = IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.get(__player_position_sk_id);
        let player_position = (__player_position_position, __player_position_player);

        let mut bar = 123;
        let mut foo = ArrayTrait::<felt252>::new();
        foo.append(bar);

        move_inner(@positions_query, 0_u32, positions_query.len());

        if bar == 123 {
            return ();
        } else if bar == 0 {
            return ();
        } else {
            return ();
        }
    }
}

//! > expected_diagnostics
error: Plugin diagnostic: Invalid arguements. Expected "(storage_key, (components,))"
 --> lib.cairo:46:43
        let invalid_args = commands::spawn((
                                          ^^
