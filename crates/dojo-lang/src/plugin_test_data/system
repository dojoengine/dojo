//! > Test expansion of the #[system].

//! > test_runner_name
test_expand_plugin

//! > cairo_code
#[dojo::contract(namespace: "My@Namespace")]
mod bad_namespace_format {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: 'my_namespace')]
mod spawn {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract(namespace: "my_namespace")]
mod proxy {
    fn execute(value: felt252) -> felt252 {
        value
    }
}

#[dojo::contract]
mod ctxnamed {
    use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }
}

#[dojo::contract]
mod withevent {
    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        TestEvent: TestEvent,
    }

    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }
}

#[starknet::component]
mod testcomponent1 {
    #[storage]
    struct Storage {}
}

#[starknet::component]
mod testcomponent2 {
    #[storage]
    struct Storage {}
}

#[dojo::contract]
mod withcomponent {
    component!(path: testcomponent1, storage: testcomponent1_storage, event: testcomponent1_event);
    component!(path: testcomponent2, storage: testcomponent2_storage, event: testcomponent2_event);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        testcomponent1_storage: testcomponent1::Storage,
        #[substorage(v0)]
        testcomponent2_storage: testcomponent2::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event,
    }
}
#[dojo::interface]
trait IEmptyTrait;

#[dojo::interface]
trait IFaultyTrait {
    const ONE: u8;

    #[my_attr]
    fn do_with_attrs(p1: u8) -> u16;
}

#[dojo::interface]
trait INominalTrait {
    fn do_no_param() -> felt252;
    fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252;
    fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252;
    fn do_params_no_world(p1: felt252, p2: u8) -> felt252;
    fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252;
    fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252;

    fn do_with_self(self: @ContractState) -> felt252;
    fn do_with_ref_self(ref self: ContractState) -> felt252;
}

#[dojo::interface]
trait IFaultyTrait {
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    fn do_with_ref_self_and_world_inv(
        ref world: IWorldDispatcher, ref self: ContractState
    ) -> felt252;
    fn do_with_several_world_dispatchers(
        world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
    ) -> felt252;
    fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252;
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
}

#[dojo::contract]
mod MyFaultyContract {
    #[abi(embed_v0)]
    impl TestFaultyImpl of IFaultyTrait<ContractState> {
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world(
            ref self: ContractState, ref world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self_and_world_inv(
            ref world: IWorldDispatcher, ref self: ContractState
        ) -> felt252 {
            'land'
        }

        fn do_with_several_world_dispatchers(
            world: @IWorldDispatcher, vec: Vec2, ref another_world: IWorldDispatcher
        ) -> felt252 {
            'land'
        }

        fn do_with_world_not_named_world(another_world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl InternalImplBad of InternalUtils<ContractState> {
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
            'land'
        }
    }
}

#[dojo::contract]
mod MyNominalContract {
    #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
    impl TestNominalImpl of INominalTrait<ContractState> {
        fn do_no_param() -> felt252 {
            'land'
        }

        fn do_no_param_but_world(world: @IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_no_param_but_world_ref(ref world: IWorldDispatcher) -> felt252 {
            'land'
        }

        fn do_params_no_world(p1: felt252, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world(world: @IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_params_and_world_ref(ref world: IWorldDispatcher, p2: u8) -> felt252 {
            'land'
        }

        fn do_with_self(self: @ContractState) -> felt252 {
            'land'
        }

        fn do_with_ref_self(ref self: ContractState) -> felt252 {
            'land'
        }
    }

    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }
}

#[dojo::contract]
mod init_test {
    fn dojo_init(
        world: IWorldDispatcher,
        actions_address: ContractAddress,
        actions_class: ClassHash,
        value: u8
    ) {
        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
    }
}

#[dojo::contract]
mod no_init_test {}

//! > generated_cairo_code
#[starknet::contract]
mod spawn {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'spawn'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx: Context, name: felt252) {
        return ();
    }
}


#[starknet::contract]
mod proxy {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'proxy'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }


    #[abi(embed_v0)]
    fn execute(self: @ContractState, value: felt252) -> felt252 {
        value
    }
}


#[starknet::contract]
mod ctxnamed {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    #[storage]
    struct Storage {
        world_dispatcher: IWorldDispatcher,
    }

    #[abi(embed_v0)]
    fn name(self: @ContractState) -> felt252 {
        'ctxnamed'
    }

    #[abi(embed_v0)]
    impl Upgradeable of dojo::upgradable::IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: starknet::ClassHash) {
            let caller = starknet::get_caller_address();
            assert(
                self.world_dispatcher.read().contract_address == caller, 'only World can upgrade'
            );
            dojo::upgradable::UpgradeableTrait::upgrade(new_class_hash);
        }
    }

    use traits::Into;
    use dojo::world::Context;

    #[abi(embed_v0)]
    fn execute(self: @ContractState, ctx2: Context, name: felt252) {
        return ();
    }
}

//! > expected_diagnostics
error: Anything other than functions is not supported in a dojo::interface
 --> /tmp/plugin_test/src/lib.cairo:90:5
    const ONE: u8;
    ^************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^***********************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^*********************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:113:5
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    ^***************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^****************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:128:9
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
        ^************************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:132:9
        fn do_with_ref_self_and_world(
        ^****************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:138:9
        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
        ^****************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:142:9
        fn do_with_ref_self_and_world_inv(
        ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:158:9
        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
        ^*****************************************************************************^

error: You cannot use `world` and `#[generate_trait]` together. Use `self` instead.
 --> /tmp/plugin_test/src/lib.cairo:165:9
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
        ^***************************************************************^

error: World parameter must be a snapshot if `ref` is not used.
 --> /tmp/plugin_test/src/lib.cairo:224:5
    fn dojo_init(
    ^***********^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:105:5
    fn do_with_self(self: @ContractState) -> felt252;
    ^**********************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:106:5
    fn do_with_ref_self(ref self: ContractState) -> felt252;
    ^*****************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^**********************************************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:117:5
    fn do_with_several_world_dispatchers(
    ^***********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^***************************************************************************^

error: Generated trait must have generic args matching the impl's generic params.
 --> /tmp/plugin_test/src/lib.cairo:163:5
    #[generate_trait]
    ^***************^

//! > expanded_cairo_code

#[starknet::component]
mod testcomponent1 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;
impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;
}

#[starknet::component]
mod testcomponent2 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


#[phantom]
pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;
impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;
}

                #[starknet::contract]
                mod bad_namespace_format {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "bad_namespace_format"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-bad_namespace_format"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2014299465256018364248618312205774234949844604916563661777686628154176783488
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2931670046498875274448874829231097042977275875153600823491451406128208153107
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod spawn {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "spawn"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-spawn"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2776321589048333240377325502911505147617911439383944762363370901236132332849
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2472087249524108479557800499207886557849609293388925195637428170796835731505
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod proxy {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "proxy"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-proxy"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            379211399603323842291430789821178524592027629543381998047225121027704003915
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3522586352349720867166847576673128733430338006217587257445073829693434546448
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        fn execute(value: felt252) -> felt252 {
        value
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod ctxnamed {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "ctxnamed"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-ctxnamed"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1120614286815912604239420768209466007446460277061516527925636408561239543041
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            882574079468045629402181499911470715863025356910172410020020548741739455774
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod withevent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withevent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-withevent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2196275886623691942883456540767114081898043897719876113518403014973431884540
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2302995054894169641868030754357260737170491794196617685355614288827933407674
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
                        TestEvent: TestEvent
            }
            
    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::TestEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("TestEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("TestEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::TestEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl EventTestEventIntoEvent of Into<TestEvent, Event> {
    fn into(self: TestEvent) -> Event {
        Event::TestEvent(self)
    }
}
impl TestEventDrop of core::traits::Drop::<TestEvent>;
impl TestEventIsEvent of starknet::Event<TestEvent> {
    fn append_keys_and_data(
        self: @TestEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
            core::serde::Serde::serialize(self.address, ref data);
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<TestEvent> {
                let address = core::serde::Serde::deserialize(
                    ref data
                )?;
        Option::Some(TestEvent {address, })
    }
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod withcomponent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withcomponent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-withcomponent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            999850881662666048155666650426666132968026605763740651763663703103974774091
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            795804664978713707757807985251114311939501109833092725925763852713460388378
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
                        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event
            }
            
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
          pub testcomponent1_storage: testcomponent1::Storage,
          pub testcomponent2_storage: testcomponent2::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
    pub testcomponent1_storage: starknet::storage::StorageBase<testcomponent1::Storage>,
    pub testcomponent2_storage: starknet::storage::StorageBase<testcomponent2::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
    pub testcomponent1_storage: starknet::storage::StorageBase<starknet::storage::Mutable<testcomponent1::Storage>>,
    pub testcomponent2_storage: starknet::storage::StorageBase<starknet::storage::Mutable<testcomponent2::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
           testcomponent1_storage: starknet::storage::StorageBase{ address: selector!("testcomponent1_storage") },
           testcomponent2_storage: starknet::storage::StorageBase{ address: selector!("testcomponent2_storage") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
           testcomponent1_storage: starknet::storage::StorageBase{ address: selector!("testcomponent1_storage") },
           testcomponent2_storage: starknet::storage::StorageBase{ address: selector!("testcomponent2_storage") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
        pub testcomponent1_storage: testcomponent1::ComponentState<ContractState>,
        pub testcomponent2_storage: testcomponent2::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
            testcomponent1_storage: testcomponent1::unsafe_new_component_state::<ContractState>(),
            testcomponent2_storage: testcomponent2::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl HasComponentImpl_testcomponent1 of testcomponent1::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent1::ComponentState<ContractState> {
                 @testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent1::ComponentState<ContractState> {
        testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent1::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent1::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent1::Event>>(ref self: testcomponent1::ComponentState<ContractState>, event: S) {
        let event: testcomponent1::Event = core::traits::Into::into(event);
        let mut contract = testcomponent1::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent1_event(event));
    }
}
impl HasComponentImpl_testcomponent2 of testcomponent2::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent2::ComponentState<ContractState> {
                 @testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent2::ComponentState<ContractState> {
        testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent2::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent2::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent2::Event>>(ref self: testcomponent2::ComponentState<ContractState>, event: S) {
        let event: testcomponent2::Event = core::traits::Into::into(event);
        let mut contract = testcomponent2::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent2_event(event));
    }
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent1_event(val) => {
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent2_event(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("testcomponent2_event"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        {
            let mut keys = keys;
            let mut data = data;
            match starknet::Event::deserialize(ref keys, ref data) {
                Option::Some(val) => {
                    return Option::Some(Event::testcomponent1_event(val));
                },
                Option::None => {},
            };
        }
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("testcomponent2_event") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::testcomponent2_event(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl Eventtestcomponent1_eventIntoEvent of Into<testcomponent1::Event, Event> {
    fn into(self: testcomponent1::Event) -> Event {
        Event::testcomponent1_event(self)
    }
}
impl Eventtestcomponent2_eventIntoEvent of Into<testcomponent2::Event, Event> {
    fn into(self: testcomponent2::Event) -> Event {
        Event::testcomponent2_event(self)
    }
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
                
                }

                #[starknet::interface]
                pub trait IEmptyTrait<TContractState> {}

                #[starknet::interface]
                pub trait IFaultyTrait<TContractState> {
                    fn do_with_attrs(self: @TContractState, p1: u8) -> u16;
                }

                #[starknet::interface]
                pub trait INominalTrait<TContractState> {
                    fn do_no_param(self: @TContractState) -> felt252;fn do_no_param_but_world(self: @TContractState) -> felt252;fn do_no_param_but_world_ref(ref self: TContractState) -> felt252;fn do_params_no_world(self: @TContractState, p1: felt252, p2: u8) -> felt252;fn do_params_and_world(self: @TContractState, p2: u8) -> felt252;fn do_params_and_world_ref(ref self: TContractState, p2: u8) -> felt252;fn do_with_self(self: @ContractState) -> felt252;fn do_with_ref_self(ref self: ContractState) -> felt252;
                }

                #[starknet::interface]
                pub trait IFaultyTrait<TContractState> {
                    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;fn do_with_self_and_world_inv(self: @TContractState, self: @ContractState) -> felt252;fn do_with_ref_self_and_world_inv(ref self: TContractState, ref self: ContractState
) -> felt252;fn do_with_several_world_dispatchers(self: @TContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252;fn do_with_world_not_named_world(self: @TContractState, another_world: @IWorldDispatcher) -> felt252;fn do_with_world_not_first(self: @TContractState, vec: Vec2, ref world: IWorldDispatcher) -> felt252;
                }

                #[starknet::contract]
                mod MyFaultyContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyFaultyContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-MyFaultyContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            3439743807865759203015037013733809315384408083697880336790137144257764256358
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1862046669446530718410691364259438011386499031689246339557998041337203828246
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
 impl TestFaultyImpl  of IFaultyTrait<ContractState>  {fn do_with_self_and_world(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self_and_world(            ref self: ContractState) -> felt252  {            'land'
}fn do_with_self_and_world_inv(self: @ContractState, self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_ref_self_and_world_inv(ref self: ContractState, ref self: ContractState
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_several_world_dispatchers(self: @ContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_world_not_named_world(self: @ContractState, another_world: @IWorldDispatcher) -> felt252  {            'land'
}fn do_with_world_not_first(self: @ContractState, vec: Vec2) -> felt252  {            'land'
}}
    #[generate_trait]
 impl InternalImplBad  of InternalUtils<ContractState>  {fn bad_func_using_generate(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}}
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
    trait InternalUtils{fn bad_func_using_generate(self: @ContractState) -> felt252;
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world_inv(@contract_state, __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let mut __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world_inv(ref contract_state, ref __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<ContractState>::serialize(@__arg_self, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_several_world_dispatchers(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let mut __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_several_world_dispatchers(@contract_state, __arg_vec, ref __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<IWorldDispatcher>::serialize(@__arg_another_world, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_named_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_named_world(@contract_state, __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_first(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_first(@contract_state, __arg_vec);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world as do_with_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world as do_with_ref_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world_inv as do_with_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv as do_with_ref_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_several_world_dispatchers as do_with_several_world_dispatchers;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_named_world as do_with_world_not_named_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_first as do_with_world_not_first;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod MyNominalContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyNominalContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-MyNominalContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1172628497499445169993220559087829230676589931723677494032285307738203070578
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2020162355936884646880401248118384176803981589166410970216209297939905305278
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
 impl TestNominalImpl  of INominalTrait<ContractState>  {fn do_no_param(self: @ContractState) -> felt252  {            'land'
}fn do_no_param_but_world(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_no_param_but_world_ref(ref self: ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_no_world(self: @ContractState, p1: felt252, p2: u8) -> felt252  {            'land'
}fn do_params_and_world(self: @ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_and_world_ref(ref self: ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_self(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self(ref self: ContractState) -> felt252  {            'land'
}}
    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
impl ActionDrop of core::traits::Drop::<Action>;
    trait InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252;
    }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world_ref(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_no_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p1 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<felt252>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_no_world(@contract_state, __arg_p1, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world(@contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world_ref(ref contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_self(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_ref_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_ref_self(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestNominalImpl__do_no_param as do_no_param;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world as do_no_param_but_world;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world_ref as do_no_param_but_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_params_no_world as do_params_no_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world as do_params_and_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world_ref as do_params_and_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_with_self as do_with_self;
    pub use super::__wrapper__TestNominalImpl__do_with_ref_self as do_with_ref_self;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1673722391095039242574232979635399085098867563460816803458086922970092209409
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            799876284284394866912776672431802324689156187217902437477103298743064217162
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    #[starknet::interface]
            trait IDojoInit<ContractState> {
                fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
            }
            
            #[abi(embed_v0)]
            impl IDojoInitImpl of IDojoInit<ContractState> {
            fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {let world = self.world_dispatcher.read();assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
}
}
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                fn dojo_init(self: IDojoInitDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                fn dojo_init(self: IDojoInitLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                fn dojo_init(self: IDojoInitSafeLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                fn dojo_init(self: IDojoInitSafeDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_actions_address = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractAddress>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_actions_class = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ClassHash>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    let __arg_value = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #3'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, __arg_actions_address, __arg_actions_class, __arg_value);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }

                #[starknet::contract]
                mod no_init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;
                    use starknet::storage::{
                        StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess, StoragePointerWriteAccess
                    };

                    #[abi(embed_v0)]
                    pub impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "no_init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-no_init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2188407785440294979090510634648735461326850740369373015349552249835679156474
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3269287263937103915837903451864388946886384011514094502724942119672327217364
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::contract::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::contract::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::contract::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::contract::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


#[phantom]
pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::contract::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::contract::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::contract::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::contract::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(core::pedersen::Pedersen, core::RangeCheck, core::integer::Bitwise, core::ec::EcOp, core::poseidon::Poseidon, core::SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, core::gas::GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::contract::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::contract::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::contract::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::contract::upgradeable::upgradeable::Event>>(ref self: dojo::contract::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::contract::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::contract::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitDispatcher> {
type SubPointersType = IDojoInitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitDispatcher>) -> IDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitDispatcher> {
type SubPointersType = MutableIDojoInitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitDispatcher>>) -> MutableIDojoInitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = IDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitLibraryDispatcher>) -> IDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitLibraryDispatcher> {
type SubPointersType = MutableIDojoInitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitLibraryDispatcher>>) -> MutableIDojoInitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = IDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeLibraryDispatcher>) -> IDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIDojoInitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeLibraryDispatcher> {
type SubPointersType = MutableIDojoInitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeLibraryDispatcher>>) -> MutableIDojoInitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IDojoInitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = IDojoInitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IDojoInitSafeDispatcher>) -> IDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIDojoInitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIDojoInitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IDojoInitSafeDispatcher> {
type SubPointersType = MutableIDojoInitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IDojoInitSafeDispatcher>>) -> MutableIDojoInitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIDojoInitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitDispatcherSubPointers>;
impl IDojoInitDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitDispatcherSubPointers>;
impl MutableIDojoInitDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl MutableIDojoInitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl MutableIDojoInitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeLibraryDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<IDojoInitSafeDispatcherSubPointers>;
impl IDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<IDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIDojoInitSafeDispatcherSubPointers>;
impl MutableIDojoInitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIDojoInitSafeDispatcherSubPointers>;
            
                }
                pub trait IEmptyTraitDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitLibraryDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitLibraryDispatcher> {

}

                pub trait IEmptyTraitSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitSafeLibraryDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IEmptyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitSafeDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeDispatcher> {

}
                pub trait IFaultyTraitDispatcherTrait<T> {
                    fn do_with_attrs(self: T, p1: u8) -> u16;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitLibraryDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_with_attrs(self: T, p1: u8) -> starknet::SyscallResult<u16>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeLibraryDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
                pub trait INominalTraitDispatcherTrait<T> {
                    fn do_no_param(self: T) -> felt252;
fn do_no_param_but_world(self: T) -> felt252;
fn do_no_param_but_world_ref(self: T) -> felt252;
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> felt252;
fn do_params_and_world(self: T, p2: u8) -> felt252;
fn do_params_and_world_ref(self: T, p2: u8) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitDispatcher> {
                    fn do_no_param(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitLibraryDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitLibraryDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait INominalTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_no_param(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world_ref(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world_ref(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitSafeLibraryDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeLibraryDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct INominalTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitSafeDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeDispatcher> {
                    fn do_no_param(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
                pub trait IFaultyTraitDispatcherTrait<T> {
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> felt252;
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitLibraryDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitLibraryDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

                pub trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeLibraryDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeLibraryDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
                pub struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
impl IEmptyTraitDispatcherCopy of core::traits::Copy::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherDrop of core::traits::Drop::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherSerde of core::serde::Serde::<IEmptyTraitDispatcher> {
    fn serialize(self: @IEmptyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitDispatcher> {
        core::option::Option::Some(IEmptyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitDispatcher of starknet::Store::<IEmptyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IEmptyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IEmptyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitDispatcher> {
type SubPointersType = IEmptyTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitDispatcher>) -> IEmptyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IEmptyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIEmptyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIEmptyTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IEmptyTraitDispatcher> {
type SubPointersType = MutableIEmptyTraitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitDispatcher>>) -> MutableIEmptyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIEmptyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IEmptyTraitLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitLibraryDispatcher of starknet::Store::<IEmptyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IEmptyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IEmptyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitLibraryDispatcher> {
type SubPointersType = IEmptyTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitLibraryDispatcher>) -> IEmptyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IEmptyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIEmptyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIEmptyTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IEmptyTraitLibraryDispatcher> {
type SubPointersType = MutableIEmptyTraitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitLibraryDispatcher>>) -> MutableIEmptyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIEmptyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IEmptyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeLibraryDispatcher of starknet::Store::<IEmptyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IEmptyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IEmptyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitSafeLibraryDispatcher> {
type SubPointersType = IEmptyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitSafeLibraryDispatcher>) -> IEmptyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IEmptyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIEmptyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIEmptyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IEmptyTraitSafeLibraryDispatcher> {
type SubPointersType = MutableIEmptyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitSafeLibraryDispatcher>>) -> MutableIEmptyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIEmptyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IEmptyTraitSafeDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeDispatcher> {
    fn serialize(self: @IEmptyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeDispatcher of starknet::Store::<IEmptyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IEmptyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IEmptyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IEmptyTraitSafeDispatcher> {
type SubPointersType = IEmptyTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IEmptyTraitSafeDispatcher>) -> IEmptyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IEmptyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIEmptyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIEmptyTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IEmptyTraitSafeDispatcher> {
type SubPointersType = MutableIEmptyTraitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IEmptyTraitSafeDispatcher>>) -> MutableIEmptyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIEmptyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitDispatcher> {
type SubPointersType = IFaultyTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitDispatcher>) -> IFaultyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIFaultyTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitDispatcher> {
type SubPointersType = MutableIFaultyTraitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitDispatcher>>) -> MutableIFaultyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitLibraryDispatcher> {
type SubPointersType = IFaultyTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitLibraryDispatcher>) -> IFaultyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitLibraryDispatcher> {
type SubPointersType = MutableIFaultyTraitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitLibraryDispatcher>>) -> MutableIFaultyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeLibraryDispatcher> {
type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeLibraryDispatcher>) -> IFaultyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitSafeLibraryDispatcher> {
type SubPointersType = MutableIFaultyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeLibraryDispatcher>>) -> MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeDispatcher> {
type SubPointersType = IFaultyTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeDispatcher>) -> IFaultyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitSafeDispatcher> {
type SubPointersType = MutableIFaultyTraitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeDispatcher>>) -> MutableIFaultyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl INominalTraitDispatcherCopy of core::traits::Copy::<INominalTraitDispatcher>;
impl INominalTraitDispatcherDrop of core::traits::Drop::<INominalTraitDispatcher>;
impl INominalTraitDispatcherSerde of core::serde::Serde::<INominalTraitDispatcher> {
    fn serialize(self: @INominalTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitDispatcher> {
        core::option::Option::Some(INominalTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitDispatcher of starknet::Store::<INominalTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct INominalTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl INominalTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitDispatcher> {
type SubPointersType = INominalTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitDispatcher>) -> INominalTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                INominalTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableINominalTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableINominalTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<INominalTraitDispatcher> {
type SubPointersType = MutableINominalTraitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitDispatcher>>) -> MutableINominalTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableINominalTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl INominalTraitLibraryDispatcherCopy of core::traits::Copy::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherDrop of core::traits::Drop::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherSerde of core::serde::Serde::<INominalTraitLibraryDispatcher> {
    fn serialize(self: @INominalTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitLibraryDispatcher> {
        core::option::Option::Some(INominalTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitLibraryDispatcher of starknet::Store::<INominalTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct INominalTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl INominalTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitLibraryDispatcher> {
type SubPointersType = INominalTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitLibraryDispatcher>) -> INominalTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                INominalTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableINominalTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableINominalTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<INominalTraitLibraryDispatcher> {
type SubPointersType = MutableINominalTraitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitLibraryDispatcher>>) -> MutableINominalTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableINominalTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl INominalTraitSafeLibraryDispatcherCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherSerde of core::serde::Serde::<INominalTraitSafeLibraryDispatcher> {
    fn serialize(self: @INominalTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeLibraryDispatcher> {
        core::option::Option::Some(INominalTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeLibraryDispatcher of starknet::Store::<INominalTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct INominalTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl INominalTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitSafeLibraryDispatcher> {
type SubPointersType = INominalTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitSafeLibraryDispatcher>) -> INominalTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                INominalTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableINominalTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableINominalTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<INominalTraitSafeLibraryDispatcher> {
type SubPointersType = MutableINominalTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitSafeLibraryDispatcher>>) -> MutableINominalTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableINominalTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl INominalTraitSafeDispatcherCopy of core::traits::Copy::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherDrop of core::traits::Drop::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherSerde of core::serde::Serde::<INominalTraitSafeDispatcher> {
    fn serialize(self: @INominalTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeDispatcher> {
        core::option::Option::Some(INominalTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeDispatcher of starknet::Store::<INominalTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct INominalTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl INominalTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<INominalTraitSafeDispatcher> {
type SubPointersType = INominalTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<INominalTraitSafeDispatcher>) -> INominalTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                INominalTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableINominalTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableINominalTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<INominalTraitSafeDispatcher> {
type SubPointersType = MutableINominalTraitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<INominalTraitSafeDispatcher>>) -> MutableINominalTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableINominalTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitDispatcher> {
type SubPointersType = IFaultyTraitDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitDispatcher>) -> IFaultyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIFaultyTraitDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitDispatcher> {
type SubPointersType = MutableIFaultyTraitDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitDispatcher>>) -> MutableIFaultyTraitDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitLibraryDispatcher> {
type SubPointersType = IFaultyTraitLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitLibraryDispatcher>) -> IFaultyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIFaultyTraitLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitLibraryDispatcher> {
type SubPointersType = MutableIFaultyTraitLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitLibraryDispatcher>>) -> MutableIFaultyTraitLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::ClassHash>,
}
impl IFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeLibraryDispatcher> {
type SubPointersType = IFaultyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeLibraryDispatcher>) -> IFaultyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
    class_hash: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ClassHash>>,
}
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitSafeLibraryDispatcher> {
type SubPointersType = MutableIFaultyTraitSafeLibraryDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeLibraryDispatcher>>) -> MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let class_hash_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitSafeLibraryDispatcherSubPointers {
           class_hash: class_hash_value,
        }
    }
}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}

#[derive(Drop, Copy)]
struct IFaultyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::ContractAddress>,
}
impl IFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::SubPointers<IFaultyTraitSafeDispatcher> {
type SubPointersType = IFaultyTraitSafeDispatcherSubPointers;
   fn sub_pointers(self: starknet::storage::StoragePointer<IFaultyTraitSafeDispatcher>) -> IFaultyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                IFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
#[derive(Drop, Copy)]
struct MutableIFaultyTraitSafeDispatcherSubPointers {
    contract_address: starknet::storage::StoragePointer<starknet::storage::Mutable::<starknet::ContractAddress>>,
}
impl MutableIFaultyTraitSafeDispatcherSubPointersImpl of starknet::storage::MutableSubPointers<IFaultyTraitSafeDispatcher> {
type SubPointersType = MutableIFaultyTraitSafeDispatcherSubPointers;
   fn sub_pointers_mut(self: starknet::storage::StoragePointer<starknet::storage::Mutable::<IFaultyTraitSafeDispatcher>>) -> MutableIFaultyTraitSafeDispatcherSubPointers {
               let base_address = self.address;
        let mut current_offset = self.offset;
        let contract_address_value = starknet::storage::StoragePointer {
            address: base_address,
            offset: current_offset,
        };
                MutableIFaultyTraitSafeDispatcherSubPointers {
           contract_address: contract_address_value,
        }
    }
}
impl IEmptyTraitDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitDispatcherSubPointers>;
impl IEmptyTraitDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitDispatcherSubPointers>;
impl MutableIEmptyTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableIEmptyTraitDispatcherSubPointers>;
impl MutableIEmptyTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableIEmptyTraitDispatcherSubPointers>;
impl IEmptyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcherSubPointers>;
impl IEmptyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcherSubPointers>;
impl MutableIEmptyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIEmptyTraitLibraryDispatcherSubPointers>;
impl MutableIEmptyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIEmptyTraitLibraryDispatcherSubPointers>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcherSubPointers>;
impl IEmptyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIEmptyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIEmptyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIEmptyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIEmptyTraitSafeLibraryDispatcherSubPointers>;
impl IEmptyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IEmptyTraitSafeDispatcherSubPointers>;
impl IEmptyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IEmptyTraitSafeDispatcherSubPointers>;
impl MutableIEmptyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIEmptyTraitSafeDispatcherSubPointers>;
impl MutableIEmptyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIEmptyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointers>;
impl MutableIFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitDispatcherSubPointers>;
impl MutableIFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointers>;
impl MutableIFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitSafeDispatcherSubPointers>;
impl MutableIFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitSafeDispatcherSubPointers>;
impl INominalTraitDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitDispatcherSubPointers>;
impl INominalTraitDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitDispatcherSubPointers>;
impl MutableINominalTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableINominalTraitDispatcherSubPointers>;
impl MutableINominalTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableINominalTraitDispatcherSubPointers>;
impl INominalTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitLibraryDispatcherSubPointers>;
impl INominalTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitLibraryDispatcherSubPointers>;
impl MutableINominalTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableINominalTraitLibraryDispatcherSubPointers>;
impl MutableINominalTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableINominalTraitLibraryDispatcherSubPointers>;
impl INominalTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcherSubPointers>;
impl INominalTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcherSubPointers>;
impl MutableINominalTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableINominalTraitSafeLibraryDispatcherSubPointers>;
impl MutableINominalTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableINominalTraitSafeLibraryDispatcherSubPointers>;
impl INominalTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<INominalTraitSafeDispatcherSubPointers>;
impl INominalTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<INominalTraitSafeDispatcherSubPointers>;
impl MutableINominalTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableINominalTraitSafeDispatcherSubPointers>;
impl MutableINominalTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableINominalTraitSafeDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitDispatcherSubPointers>;
impl MutableIFaultyTraitDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitDispatcherSubPointers>;
impl MutableIFaultyTraitDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitSafeLibraryDispatcherSubPointers>;
impl MutableIFaultyTraitSafeLibraryDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitSafeLibraryDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<IFaultyTraitSafeDispatcherSubPointers>;
impl IFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<IFaultyTraitSafeDispatcherSubPointers>;
impl MutableIFaultyTraitSafeDispatcherSubPointersDrop of core::traits::Drop::<MutableIFaultyTraitSafeDispatcherSubPointers>;
impl MutableIFaultyTraitSafeDispatcherSubPointersCopy of core::traits::Copy::<MutableIFaultyTraitSafeDispatcherSubPointers>;
