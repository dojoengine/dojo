//! > Test expansion of the component contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
use array::ArrayTrait;
use dojo::query::Caller;
use dojo::query::Query;
use dojo::query::EntityID;
use dojo::query::With;

#[derive(Component)]
struct Position {
    x: felt252,
    y: felt252,
}

#[derive(Component)]
struct Player {
    name: felt252, 
}

#[system]
mod SpawnSystem {
    use dojo::commands::Spawn;
    use super::Position;
    use super::Player;

    #[execute]
    fn spawn(name: felt252) {
        let player_id = Spawn::<(Player, Position)>::bundle((
            Player { name: name },
            Position { x: 0, y: 0 },
        ));
        return ();
    }
}

#[system]
mod MoveSystem {
    use array::ArrayTrait;
    use dojo::query::QueryTrait;
    use super::Position;
    use super::Player;

    fn move_inner(positions: Array<usize>, index: u32, count: u32) {
        return move_inner(positions, index + 1_u32, count - 1_u32);
    }

    #[execute]
    fn move() {
        let positions_query = QueryTrait::<(Position, Player)>::ids();
        // let player_query: Query<(With::<Player, EntityID<Caller>>)>

        let mut bar = 123;
        let mut foo = ArrayTrait::<felt252>::new();
        foo.append(bar);

        move_inner(positions_query, 0_u32, positions_query.len());

        if bar == 123 {
            return ();
        } else if bar == 0 {
            return ();
        } else {
            return ();
        }
    }
}

//! > generated_cairo_code
use array::ArrayTrait;

use dojo::query::Caller;

use dojo::query::Query;

use dojo::query::EntityID;

use dojo::query::With;

use option::OptionTrait;

use starknet::SyscallResult;

use traits::Into;

use traits::TryInto;

#[derive(Copy, Drop)]
struct Position {
    x: felt252,
    y: felt252,
}

impl PositionSerde of serde::Serde::<Position> {
    fn serialize(ref serialized: Array::<felt252>, input: Position) {
        serde::Serde::<felt252>::serialize(ref serialized, input.x);
        serde::Serde::<felt252>::serialize(ref serialized, input.y);
    }
    fn deserialize(ref serialized: Span::<felt252>) -> Option::<Position> {
        Option::Some(
            Position {
                x: serde::Serde::<felt252>::deserialize(ref serialized)?,
                y: serde::Serde::<felt252>::deserialize(ref serialized)?,
            }
        )
    }
}

impl StorageAccessPosition of starknet::StorageAccess::<Position> {
    fn read(
        address_domain: felt252, base: starknet::StorageBaseAddress
    ) -> starknet::SyscallResult::<Position> {
        Result::Ok(
            Position {
                x: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                )?,
                y: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8)
                )?,
            }
        )
    }
    fn write(
        address_domain: felt252, base: starknet::StorageBaseAddress, value: Position
    ) -> starknet::SyscallResult::<()> {
        starknet::storage_write_syscall(
            address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8), value.x
        )?;
        starknet::storage_write_syscall(
            address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8), value.y
        )
    }
}

#[abi]
trait IPosition {
    fn set(entity_id: usize, value: Position);
    fn get(entity_id: usize) -> Position;
}

#[contract]
mod PositionComponent {
    use super::Position;
    use super::PositionSerde;
    use super::StorageAccessPosition;

    struct Storage {
        state: LegacyMap::<usize, Position>, 
    }

    // Initialize Position.
    #[external]
    fn initialize() {}

    // Set the state of an entity.
    #[external]
    fn set(entity_id: usize, value: Position) {
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: usize) -> Position {
        return state::read(entity_id);
    }
}

use option::OptionTrait;

use starknet::SyscallResult;

use traits::Into;

use traits::TryInto;

#[derive(Copy, Drop)]
struct Player {
    name: felt252, 
}

impl PlayerSerde of serde::Serde::<Player> {
    fn serialize(ref serialized: Array::<felt252>, input: Player) {
        serde::Serde::<felt252>::serialize(ref serialized, input.name);
    }
    fn deserialize(ref serialized: Span::<felt252>) -> Option::<Player> {
        Option::Some(Player { name: serde::Serde::<felt252>::deserialize(ref serialized)?,  })
    }
}

impl StorageAccessPlayer of starknet::StorageAccess::<Player> {
    fn read(
        address_domain: felt252, base: starknet::StorageBaseAddress
    ) -> starknet::SyscallResult::<Player> {
        Result::Ok(
            Player {
                name: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                )?,
            }
        )
    }
    fn write(
        address_domain: felt252, base: starknet::StorageBaseAddress, value: Player
    ) -> starknet::SyscallResult::<()> {
        starknet::storage_write_syscall(
            address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8), value.name
        )
    }
}

#[abi]
trait IPlayer {
    fn set(entity_id: usize, value: Player);
    fn get(entity_id: usize) -> Player;
}

#[contract]
mod PlayerComponent {
    use super::Player;
    use super::PlayerSerde;
    use super::StorageAccessPlayer;

    struct Storage {
        state: LegacyMap::<usize, Player>, 
    }

    // Initialize Player.
    #[external]
    fn initialize() {}

    // Set the state of an entity.
    #[external]
    fn set(entity_id: usize, value: Player) {
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: usize) -> Player {
        return state::read(entity_id);
    }
}

#[contract]
mod SpawnSystem {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;
    use super::IPlayerDispatcher;
    use super::IPlayerDispatcherTrait;
    use super::IPositionDispatcher;
    use super::IPositionDispatcherTrait;

    use dojo::commands::Spawn;
    use super::Position;
    use super::Player;
    #[external]
    fn execute(name: felt252) {
        let world_address = starknet::contract_address_const::<0x0>();
        let owner = starknet::get_caller_address();
        let entity_id = IWorldDispatcher { contract_address: world_address }.issue_entity(owner);
        IPlayerDispatcher {
            contract_address: starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        }.set(entity_id, Player { name: name });
        IPositionDispatcher {
            contract_address: starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        }.set(entity_id, Position { x: 0, y: 0 });
        return ();
    }
}

#[contract]
mod MoveSystem {
    use dojo::world;
    use dojo::world::IWorldDispatcher;
    use dojo::world::IWorldDispatcherTrait;

    use array::ArrayTrait;
    use dojo::query::QueryTrait;
    use super::Position;
    use super::Player;
    fn move_inner(positions: Array<usize>, index: u32, count: u32) {
        return move_inner(positions, index + 1_u32, count - 1_u32);
    }
    #[external]
    fn execute() {
        let world_address = starknet::contract_address_const::<0x0>();
        let positions_query = QueryTrait::<(Position, Player)>::ids();
        let position_ids = IWorldDispatcher {
            contract_address: world_address
        }.entities(
            starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>()
        );
        let player_ids = IWorldDispatcher {
            contract_address: world_address
        }.entities(
            starknet::contract_address_const::<0x45ae1fe01b0daa1b91e29c079ddcc83a8aae082c898bc23dfb766ab12b0403a>()
        );
        let mut bar = 123;
        let mut foo = ArrayTrait::<felt252>::new();
        foo.append(bar);
        move_inner(positions_query, 0_u32, positions_query.len());
        if bar == 123 {
            return ();
        } else if bar == 0 {
            return ();
        } else {
            return ();
        }
    }
}

//! > expected_diagnostics
error: The name `OptionTrait` is defined multiple times.
 --> Player:2:25
            use option::OptionTrait;
                        ^*********^

error: The name `SyscallResult` is defined multiple times.
 --> Player:3:27
            use starknet::SyscallResult;
                          ^***********^

error: The name `Into` is defined multiple times.
 --> Player:4:25
            use traits::Into;
                        ^**^

error: The name `TryInto` is defined multiple times.
 --> Player:5:25
            use traits::TryInto;
                        ^*****^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> contract:17:113
let mut bar = 123;let mut foo = ArrayTrait::<felt252>::new();foo.append(bar);move_inner(positions_query, 0_u32, positions_query.len());if bar == 123 {
                                                                                                                ^*******************^

error: Variable was previously moved. Trait has no implementation in context: core::traits::Copy::<core::array::Array::<core::integer::u32>>
 --> contract:15:25
                    let positions_query = QueryTrait::<(Position, Player)>::ids();let position_ids = IWorldDispatcher { contract_address: world_address }.entities(starknet::contract_address_const::<0x3718a0ff90de39b4acf137c1a27b0427c2c3f60c23c4f7c20b85c578d2c5897>());
                        ^*************^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:8:9
        serialize_array_u32_helper(ref serialized, ref input);
        ^***************************************************^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:17:69
fn serialize_array_u32_helper(ref serialized: Array::<felt252>, ref input: Array::<u32>) {
                                                                    ^***^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:37:42
    ref serialized: Span::<felt252>, mut curr_output: Array::<u32>, remaining: felt252
                                         ^*********^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:37:42
    ref serialized: Span::<felt252>, mut curr_output: Array::<u32>, remaining: felt252
                                         ^*********^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> contract:52:13
        ref entities: Array::<usize>
            ^******^
