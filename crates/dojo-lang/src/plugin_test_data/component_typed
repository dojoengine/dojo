//! > Test expansion of the component contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
use dojo::world::ComponentTrait;

#[derive(Component)]
struct Fighter {
    attack: u16,
    defense: u16,
    speed: u32,
    luck: u8,
    name: felt252
}

//! > generated_cairo_code
use dojo::world::ComponentTrait;

#[derive(Copy, Drop)]
struct Fighter {
    attack: u16,
    defense: u16,
    speed: u32,
    luck: u8,
    name: felt252
}

#[abi]
trait IFighter {
    fn set(entity_id: usize, value: Fighter);
    fn get(entity_id: usize) -> Fighter;
    fn get_is_writer_authorized(writer: starknet::ContractAddress) -> bool;
}

#[contract]
mod FighterComponent {
    use option::OptionTrait;
    use array::ArrayTrait;
    use box::BoxTrait;
    use starknet::SyscallResult;
    use starknet::ContractAddress;
    use traits::Into;
    use traits::TryInto;
    use super::Fighter;

    impl FighterSerde of serde::Serde::<Fighter> {
        fn serialize(ref serialized: Array::<felt252>, input: Fighter) {
            serde::Serde::<u16>::serialize(ref serialized, input.attack);
            serde::Serde::<u16>::serialize(ref serialized, input.defense);
            serde::Serde::<u32>::serialize(ref serialized, input.speed);
            serde::Serde::<u8>::serialize(ref serialized, input.luck);
            serde::Serde::<felt252>::serialize(ref serialized, input.name);
        }
        fn deserialize(ref serialized: Span::<felt252>) -> Option::<Fighter> {
            Option::Some(
                Fighter {
                    attack: serde::Serde::<u16>::deserialize(ref serialized)?,
                    defense: serde::Serde::<u16>::deserialize(ref serialized)?,
                    speed: serde::Serde::<u32>::deserialize(ref serialized)?,
                    luck: serde::Serde::<u8>::deserialize(ref serialized)?,
                    name: serde::Serde::<felt252>::deserialize(ref serialized)?,
                }
            )
        }
    }

    impl StorageAccessFighter of starknet::StorageAccess::<Fighter> {
        fn read(
            address_domain: u32, base: starknet::StorageBaseAddress
        ) -> starknet::SyscallResult::<Fighter> {
            Result::Ok(
                Fighter {
                    attack: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                    )?.try_into().unwrap(),
                    defense: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8)
                    )?.try_into().unwrap(),
                    speed: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 2_u8)
                    )?.try_into().unwrap(),
                    luck: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 3_u8)
                    )?.try_into().unwrap(),
                    name: starknet::storage_read_syscall(
                        address_domain, starknet::storage_address_from_base_and_offset(base, 4_u8)
                    )?,
                }
            )
        }
        fn write(
            address_domain: u32, base: starknet::StorageBaseAddress, value: Fighter
        ) -> starknet::SyscallResult::<()> {
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 0_u8),
                value.attack.into()
            )?;
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 1_u8),
                value.defense.into()
            )?;
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 2_u8),
                value.speed.into()
            )?;
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 3_u8),
                value.luck.into()
            )?;
            starknet::storage_write_syscall(
                address_domain,
                starknet::storage_address_from_base_and_offset(base, 4_u8),
                value.name
            )
        }
    }


    struct Storage {
        state: LegacyMap::<usize, Fighter>,
        authorized_writers: LegacyMap::<ContractAddress, bool>,
    }

    // Initialize Fighter.
    #[external]
    fn initialize(writers: Array<ContractAddress>) {
        initialize_inner(@writers, 0_usize);
    }

    fn initialize_inner(writers: @Array<ContractAddress>, i: usize) {
        match writers.get(i) {
            Option::Some(w) => {
                authorized_writers::write(*w.unbox(), true);
                initialize_inner(writers, i + 1_usize);
            },
            Option::None(()) => (),
        }
    }

    // Set the state of an entity.
    #[external]
    fn set(entity_id: usize, value: Fighter) {
        let caller_address = starknet::get_caller_address();
        let is_authorized = authorized_writers::read(caller_address);
        assert(is_authorized, 'Unauthorized writer.');
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: usize) -> Fighter {
        return state::read(entity_id);
    }

    // True if the writer is authorized to modify entities state.
    #[view]
    fn get_is_writer_authorized(writer: ContractAddress) -> bool {
        return authorized_writers::read(writer);
    }
}

//! > expected_diagnostics
