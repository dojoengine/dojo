//! > Test expansion of the component contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
use dojo::world::ComponentTrait;

#[derive(Component)]
struct Fighter {
    attack: u16,
    defense: u16,
    speed: u32,
    luck: u8,
    name: felt
}

//! > generated_cairo_code
use dojo::world::ComponentTrait;

use option::OptionTrait;

use starknet::SyscallResult;

use traits::Into;

use traits::TryInto;

#[derive(Copy, Drop)]
struct Fighter {
    attack: u16,
    defense: u16,
    speed: u32,
    luck: u8,
    name: felt
}

impl FighterSerde of serde::Serde::<Fighter> {
    fn serialize(ref serialized: Array::<felt>, input: Fighter) {
        serde::Serde::<u16>::serialize(ref serialized, input.attack);
        serde::Serde::<u16>::serialize(ref serialized, input.defense);
        serde::Serde::<u32>::serialize(ref serialized, input.speed);
        serde::Serde::<u8>::serialize(ref serialized, input.luck);
        serde::Serde::<felt>::serialize(ref serialized, input.name);
    }
    fn deserialize(ref serialized: Span::<felt>) -> Option::<Fighter> {
        Option::Some(
            Fighter {
                attack: serde::Serde::<u16>::deserialize(ref serialized)?,
                defense: serde::Serde::<u16>::deserialize(ref serialized)?,
                speed: serde::Serde::<u32>::deserialize(ref serialized)?,
                luck: serde::Serde::<u8>::deserialize(ref serialized)?,
                name: serde::Serde::<felt>::deserialize(ref serialized)?,
            }
        )
    }
}

impl StorageAccessFighter of starknet::StorageAccess::<Fighter> {
    fn read(
        address_domain: felt, base: starknet::StorageBaseAddress
    ) -> starknet::SyscallResult::<Fighter> {
        Result::Ok(
            Fighter {
                attack: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 0_u8)
                )?.try_into().unwrap(),
                defense: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8)
                )?.try_into().unwrap(),
                speed: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 2_u8)
                )?.try_into().unwrap(),
                luck: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 3_u8)
                )?.try_into().unwrap(),
                name: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 4_u8)
                )?,
            }
        )
    }
    fn write(
        address_domain: felt, base: starknet::StorageBaseAddress, value: Fighter
    ) -> starknet::SyscallResult::<()> {
        starknet::storage_write_syscall(
            address_domain,
            starknet::storage_address_from_base_and_offset(base, 0_u8),
            value.attack.into()
        )?;
        starknet::storage_write_syscall(
            address_domain,
            starknet::storage_address_from_base_and_offset(base, 1_u8),
            value.defense.into()
        )?;
        starknet::storage_write_syscall(
            address_domain,
            starknet::storage_address_from_base_and_offset(base, 2_u8),
            value.speed.into()
        )?;
        starknet::storage_write_syscall(
            address_domain,
            starknet::storage_address_from_base_and_offset(base, 3_u8),
            value.luck.into()
        )?;
        starknet::storage_write_syscall(
            address_domain, starknet::storage_address_from_base_and_offset(base, 4_u8), value.name
        )
    }
}

#[abi]
trait IFighter {
    fn set(entity_id: usize, value: Fighter);
    fn get(entity_id: usize) -> Fighter;
}

#[contract]
mod FighterComponent {
    use super::Fighter;
    use super::FighterSerde;
    use super::StorageAccessFighter;

    struct Storage {
        state: LegacyMap::<usize, Fighter>, 
    }

    // Initialize Fighter.
    #[external]
    fn initialize() {}

    // Set the state of an entity.
    #[external]
    fn set(entity_id: usize, value: Fighter) {
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: usize) -> Fighter {
        return state::read(entity_id);
    }
}

//! > expected_diagnostics
error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:8:9
        serialize_array_u32_helper(ref serialized, ref input);
        ^***************************************************^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:17:66
fn serialize_array_u32_helper(ref serialized: Array::<felt>, ref input: Array::<u32>) {
                                                                 ^***^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:37:39
    ref serialized: Span::<felt>, mut curr_output: Array::<u32>, remaining: felt
                                      ^*********^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> serde.cairo:37:39
    ref serialized: Span::<felt>, mut curr_output: Array::<u32>, remaining: felt
                                      ^*********^

error: Variable not dropped. Trait has no implementation in context: core::traits::Drop::<core::array::Array::<core::integer::u32>>
 --> contract:52:13
        ref entities: Array::<usize>
            ^******^
