//! > Test expansion of the component contract.

//! > test_runner_name
ExpandContractTestRunner

//! > cairo_code
use serde::Serde;

#[derive(Component, Copy, Drop, Serde, Packable)]
struct Position {
    x: felt252,
    y: felt252
}

trait PositionTrait {
    fn is_zero(self: Position) -> bool;
    fn is_equal(self: Position, b: Position) -> bool;
}

impl PositionImpl of PositionTrait {
    fn is_zero(self: Position) -> bool {
        match self.x - self.y {
            0 => bool::True(()),
            _ => bool::False(()),
        }
    }

    fn is_equal(self: Position, b: Position) -> bool {
        self.x == b.x && self.y == b.y
    }
}

#[derive(Component, Copy, Drop, Serde, Packable)]
struct Player {
    name: felt252, 
}

//! > generated_cairo_code
use serde::Serde;

trait PositionTrait {
    fn is_zero(self: Position) -> bool;
    fn is_equal(self: Position, b: Position) -> bool;
}

impl PositionImpl of PositionTrait {
    fn is_zero(self: Position) -> bool {
        match self.x - self.y {
            0 => bool::True(()),
            _ => bool::False(()),
        }
    }

    fn is_equal(self: Position, b: Position) -> bool {
        self.x == b.x && self.y == b.y
    }
}

struct Position {
    x: felt252,
    y: felt252
}

#[starknet::interface]
trait IPosition<T> {
    fn name(self: @T) -> felt252;
    fn len(self: @T) -> u8;
}

#[starknet::contract]
mod position {
    use super::Position;

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn schema(self: @ContractState) -> Array<(felt252, felt252, usize, u8)> {
        let mut arr = array::ArrayTrait::new();
        array::ArrayTrait::append(ref arr, ('x', 'felt252', 0, 0));
        array::ArrayTrait::append(ref arr, ('y', 'felt252', 1, 0));

        arr
    }


    #[external(v0)]
    fn name(self: @ContractState) -> felt252 {
        'Position'
    }

    #[external(v0)]
    fn len(self: @ContractState) -> usize {
        2_usize
    }

    #[external(v0)]
    fn is_indexed(self: @ContractState) -> bool {
        bool::False(())
    }
}

impl PackablePosition of dojo::Packable<Position> {
    #[inline(always)]
    fn pack(
        self: @Position, ref packing: felt252, ref packing_offset: u8, ref packed: Array<felt252>
    ) {
        dojo::Packable::pack(self.x, ref packing, ref packing_offset, ref packed);
        dojo::Packable::pack(self.y, ref packing, ref packing_offset, ref packed);
    }
    #[inline(always)]
    fn unpack(
        ref packed: Span<felt252>, ref unpacking: felt252, ref unpacking_offset: u8
    ) -> Option<Position> {
        option::Option::Some(
            Position {
                x: option::OptionTrait::unwrap(
                    dojo::Packable::<felt252>::unpack(
                        ref packed, ref unpacking, ref unpacking_offset
                    )
                ),
                y: option::OptionTrait::unwrap(
                    dojo::Packable::<felt252>::unpack(
                        ref packed, ref unpacking, ref unpacking_offset
                    )
                ),
            }
        )
    }
    #[inline(always)]
    fn size(self: @Position) -> usize {
        dojo::Packable::size(self.x) + dojo::Packable::size(self.y)
    }
}

struct Player {
    name: felt252, 
}

#[starknet::interface]
trait IPlayer<T> {
    fn name(self: @T) -> felt252;
    fn len(self: @T) -> u8;
}

#[starknet::contract]
mod player {
    use super::Player;

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn schema(self: @ContractState) -> Array<(felt252, felt252, usize, u8)> {
        let mut arr = array::ArrayTrait::new();
        array::ArrayTrait::append(ref arr, ('name', 'felt252', 0, 0));

        arr
    }


    #[external(v0)]
    fn name(self: @ContractState) -> felt252 {
        'Player'
    }

    #[external(v0)]
    fn len(self: @ContractState) -> usize {
        1_usize
    }

    #[external(v0)]
    fn is_indexed(self: @ContractState) -> bool {
        bool::False(())
    }
}

impl PackablePlayer of dojo::Packable<Player> {
    #[inline(always)]
    fn pack(
        self: @Player, ref packing: felt252, ref packing_offset: u8, ref packed: Array<felt252>
    ) {
        dojo::Packable::pack(self.name, ref packing, ref packing_offset, ref packed);
    }
    #[inline(always)]
    fn unpack(
        ref packed: Span<felt252>, ref unpacking: felt252, ref unpacking_offset: u8
    ) -> Option<Player> {
        option::Option::Some(
            Player {
                name: option::OptionTrait::unwrap(
                    dojo::Packable::<felt252>::unpack(
                        ref packed, ref unpacking, ref unpacking_offset
                    )
                ),
            }
        )
    }
    #[inline(always)]
    fn size(self: @Player) -> usize {
        dojo::Packable::size(self.name)
    }
}

//! > expected_diagnostics
