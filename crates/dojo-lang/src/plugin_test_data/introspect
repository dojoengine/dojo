//! > Test expansion of the derive(Introspect).

//! > test_runner_name
test_expand_plugin

//! > cairo_code
use core::serde::Serde;

#[derive(Copy, Drop, Serde, Introspect)]
struct Vec2 {
    x: u32,
    y: u32
}

#[derive(Serde, Copy, Drop, Introspect)]
enum PlainEnum {
    Left,
    Right,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithPrimitive {
    Left: u32,
    Right: u32,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithStruct {
    Left: Vec2,
    Right: Vec2,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithSimpleArray {
    Left: Array<u32>,
    Right: Array<u32>,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithByteArray {
    Left: ByteArray,
    Right: ByteArray,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithSimpleTuple {
    Left: (u8, u256),
    Right: (u8, u256),
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithComplexTuple {
    Left: (u8, Vec2),
    Right: (u8, Vec2),
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithPrimitive {
    Left: u32,
    Right: u32,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumCustom {
    Left: Vec2,
    Right: Vec2,
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumTupleMix {
    Left: (Vec2, u64, EnumCustom),
    Right: (Vec2, u64, EnumCustom),
}

#[derive(Serde, Copy, Drop, Introspect)]
enum EnumWithDifferentVariantData {
    One,
    Two: u32,
    Three: (Vec2, u64),
}

#[derive(Copy, Drop, Introspect)]
struct StructWithPrimitives {
    #[key]
    player: ContractAddress,
    before: u8,
    after: u16,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithStruct {
    #[key]
    player: ContractAddress,
    before: u8,
    after: Vec2,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithSimpleArray {
    #[key]
    player: ContractAddress,
    before: u8,
    after: Array<u32>,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithByteArray {
    #[key]
    player: ContractAddress,
    before: u8,
    after: ByteArray,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithComplexArray {
    #[key]
    player: ContractAddress,
    before: u8,
    after: Array<Vec2>,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithSimpleTuple {
    #[key]
    player: ContractAddress,
    before: u8,
    after: (u8, u256),
}

#[derive(Copy, Drop, Introspect)]
struct StructWithComplexTuple {
    #[key]
    player: ContractAddress,
    before: u8,
    after: (u8, Vec2, EnumCustom),
}

#[derive(Copy, Drop, Introspect)]
struct StructWithNestedArrays {
    #[key]
    player: ContractAddress,
    before: u8,
    after: Array<Array<Array<Vec2>>>,
}

#[derive(Copy, Drop, Introspect)]
struct StructWithNestedTuples {
    #[key]
    player: ContractAddress,
    before: u8,
    after: ((u8, u32), (Vec2, EnumCustom)),
}

#[derive(Copy, Drop, Introspect)]
struct StructWithNestedTuplesAndByteArray {
    #[key]
    player: ContractAddress,
    before: u8,
    after: ((u8, u32), (Vec2, ByteArray)),
}

#[derive(Copy, Drop, Introspect)]
struct StructWithNestedEverything {
    #[key]
    player: ContractAddress,
    before: u8,
    after: ((u8, u32), (Vec2, EnumCustom), (Array<(u32, Vec2)>, EnumCustom), (u16,))
}

#[derive(Copy, Drop, Serde, Introspect)]
struct GenericStruct<T> {
    t: T,
}

#[derive(Copy, Drop, Serde, Introspect)]
struct StructWithBadOption {
    x: Option<(u8, u16)>
}

#[derive(Copy, Drop, Serde, Introspect)]
enum EnumWithBadOption {
    first: Option<(u8, u16)>,
}

#[derive(Introspect, IntrospectPacked)]
enum EnumIncompatibleAttrs {}

#[derive(Introspect, IntrospectPacked)]
struct StructIncompatibleAttrs {}

#[derive(Introspect)]
#[derive(IntrospectPacked)]
struct StructIncompatibleAttrs2 {}

#[derive(Introspect)]
#[derive(IntrospectPacked)]
enum EnumIncompatibleAttrs2 {}

#[derive(IntrospectPacked)]
struct StructPacked1 {
    x: u8
}

#[derive(IntrospectPacked)]
struct StructPacked2 {
    x: u8,
    y: u256
}

#[derive(IntrospectPacked)]
struct StructPacked3 {
    x: u256,
    y: (u8, u32)
}

#[derive(IntrospectPacked)]
struct StructNotPackable1 {
    x: u8,
    y: Array<u32>
}

#[derive(IntrospectPacked)]
struct StructPackableWithInnerPacked {
    x: u8,
    y: StructPacked1
}

#[derive(IntrospectPacked)]
enum EnumPacked1 {
    a,
    b,
    c
}

#[derive(IntrospectPacked)]
enum EnumPacked2 {
    a: u8,
    b: u8,
    c: u8
}

#[derive(IntrospectPacked)]
enum EnumPacked3 {
    a: (u128, u128),
    b: u256,
}


#[derive(IntrospectPacked)]
enum EnumPackableWithInnerPacked {
    a: StructPacked1,
    b: StructPacked1,
}

#[derive(IntrospectPacked)]
enum EnumNotPackable1 {
    a: u8,
    b: u256,
}

//! > expanded_cairo_code

#[starknet::component]
mod testcomponent1 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;
impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;
}

#[starknet::component]
mod testcomponent2 {
#[event]
#[derive(Drop, starknet::Event)]
pub enum Event {}


pub struct Storage {
}

#[derive(Drop, Copy)]
pub struct ComponentStorageBase {
}
#[derive(Drop, Copy)]
pub struct ComponentStorageBaseMut {
}
impl StorageBaseImpl<TContractState> of starknet::storage::StorageBaseTrait<ComponentState<TContractState>> {
    type BaseType = ComponentStorageBase;
    type BaseMutType = ComponentStorageBaseMut;
    fn storage_base(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        ComponentStorageBase {
        }
    }
    fn storage_base_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        ComponentStorageBaseMut {
        }
    }
}
pub struct ComponentState<TContractState> {
}

impl ComponentStateDrop<TContractState> of Drop<ComponentState<TContractState>> {}
 
impl ComponentStateDeref<TContractState> of core::ops::SnapshotDeref<ComponentState<TContractState>> {
    type Target = ComponentStorageBase;
    fn snapshot_deref(self: @ComponentState<TContractState>) -> ComponentStorageBase {
        self.storage_base()
    }
}
impl ComponentStateDerefMut<TContractState> of core::ops::DerefMut<ComponentState<TContractState>> {
    type Target = ComponentStorageBaseMut;
    fn deref_mut(ref self: ComponentState<TContractState>) -> ComponentStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_component_state<TContractState>() -> ComponentState<TContractState> {
    ComponentState::<TContractState> {
    }
}


use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;
pub trait HasComponent<TContractState> {
    fn get_component(self: @TContractState) -> @ComponentState<TContractState>;
    fn get_component_mut(ref self: TContractState) -> ComponentState<TContractState>;
    fn get_contract(self: @ComponentState<TContractState>) -> @TContractState;
    fn get_contract_mut(ref self: ComponentState<TContractState>) -> TContractState;
    fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(ref self: ComponentState<TContractState>, event: S);
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        Option::None
    }
}
impl ComponentStorageBaseDrop of core::traits::Drop::<ComponentStorageBase>;
impl ComponentStorageBaseCopy of core::traits::Copy::<ComponentStorageBase>;
impl ComponentStorageBaseMutDrop of core::traits::Drop::<ComponentStorageBaseMut>;
impl ComponentStorageBaseMutCopy of core::traits::Copy::<ComponentStorageBaseMut>;
}

                #[starknet::contract]
                mod bad_namespace_format {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "bad_namespace_format"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-bad_namespace_format"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2014299465256018364248618312205774234949844604916563661777686628154176783488
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2931670046498875274448874829231097042977275875153600823491451406128208153107
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod spawn {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "spawn"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-spawn"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2776321589048333240377325502911505147617911439383944762363370901236132332849
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2472087249524108479557800499207886557849609293388925195637428170796835731505
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod proxy {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "proxy"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-proxy"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            379211399603323842291430789821178524592027629543381998047225121027704003915
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3522586352349720867166847576673128733430338006217587257445073829693434546448
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        fn execute(value: felt252) -> felt252 {
        value
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod ctxnamed {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "ctxnamed"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-ctxnamed"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1120614286815912604239420768209466007446460277061516527925636408561239543041
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            882574079468045629402181499911470715863025356910172410020020548741739455774
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        use traits::Into;
    use dojo::world::Context;

    fn execute(ctx2: Context, name: felt252) {
        return ();
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod withevent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withevent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-withevent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2196275886623691942883456540767114081898043897719876113518403014973431884540
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2302995054894169641868030754357260737170491794196617685355614288827933407674
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        TestEvent: TestEvent
            }
            
    #[derive(Drop, starknet::Event)]
    struct TestEvent {
        address: ContractAddress,
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::TestEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("TestEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("TestEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::TestEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl EventTestEventIntoEvent of Into<TestEvent, Event> {
    fn into(self: TestEvent) -> Event {
        Event::TestEvent(self)
    }
}
impl TestEventDrop of core::traits::Drop::<TestEvent>;
impl TestEventIsEvent of starknet::Event<TestEvent> {
    fn append_keys_and_data(
        self: @TestEvent, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
            core::serde::Serde::serialize(self.address, ref data);
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<TestEvent> {
                let address = core::serde::Serde::deserialize(
                    ref data
                )?;
        Option::Some(TestEvent {address, })
    }
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod withcomponent {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "withcomponent"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-withcomponent"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            999850881662666048155666650426666132968026605763740651763663703103974774091
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            795804664978713707757807985251114311939501109833092725925763852713460388378
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;
            
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
                        #[flat]
        testcomponent1_event: testcomponent1::Event,
        testcomponent2_event: testcomponent2::Event
            }
            
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
          pub testcomponent1_storage: testcomponent1::Storage,
          pub testcomponent2_storage: testcomponent2::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
    pub testcomponent1_storage: starknet::storage::StorageBase<testcomponent1::Storage>,
    pub testcomponent2_storage: starknet::storage::StorageBase<testcomponent2::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
    pub testcomponent1_storage: starknet::storage::StorageBase<starknet::storage::Mutable<testcomponent1::Storage>>,
    pub testcomponent2_storage: starknet::storage::StorageBase<starknet::storage::Mutable<testcomponent2::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
           testcomponent1_storage: starknet::storage::StorageBase{ address: selector!("testcomponent1_storage") },
           testcomponent2_storage: starknet::storage::StorageBase{ address: selector!("testcomponent2_storage") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
           testcomponent1_storage: starknet::storage::StorageBase{ address: selector!("testcomponent1_storage") },
           testcomponent2_storage: starknet::storage::StorageBase{ address: selector!("testcomponent2_storage") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
        pub testcomponent1_storage: testcomponent1::ComponentState<ContractState>,
        pub testcomponent2_storage: testcomponent2::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
            testcomponent1_storage: testcomponent1::unsafe_new_component_state::<ContractState>(),
            testcomponent2_storage: testcomponent2::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl HasComponentImpl_testcomponent1 of testcomponent1::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent1::ComponentState<ContractState> {
                 @testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent1::ComponentState<ContractState> {
        testcomponent1::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent1::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent1::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent1::Event>>(ref self: testcomponent1::ComponentState<ContractState>, event: S) {
        let event: testcomponent1::Event = core::traits::Into::into(event);
        let mut contract = testcomponent1::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent1_event(event));
    }
}
impl HasComponentImpl_testcomponent2 of testcomponent2::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @testcomponent2::ComponentState<ContractState> {
                 @testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> testcomponent2::ComponentState<ContractState> {
        testcomponent2::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @testcomponent2::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: testcomponent2::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, testcomponent2::Event>>(ref self: testcomponent2::ComponentState<ContractState>, event: S) {
        let event: testcomponent2::Event = core::traits::Into::into(event);
        let mut contract = testcomponent2::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::testcomponent2_event(event));
    }
}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent1_event(val) => {
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
            Event::testcomponent2_event(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("testcomponent2_event"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        {
            let mut keys = keys;
            let mut data = data;
            match starknet::Event::deserialize(ref keys, ref data) {
                Option::Some(val) => {
                    return Option::Some(Event::testcomponent1_event(val));
                },
                Option::None => {},
            };
        }
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        if __selector__ == selector!("testcomponent2_event") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::testcomponent2_event(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}
impl Eventtestcomponent1_eventIntoEvent of Into<testcomponent1::Event, Event> {
    fn into(self: testcomponent1::Event) -> Event {
        Event::testcomponent1_event(self)
    }
}
impl Eventtestcomponent2_eventIntoEvent of Into<testcomponent2::Event, Event> {
    fn into(self: testcomponent2::Event) -> Event {
        Event::testcomponent2_event(self)
    }
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
                
                }

                #[starknet::interface]
                trait IEmptyTrait<TContractState> {}

                #[starknet::interface]
                trait IFaultyTrait<TContractState> {
                    fn do_with_attrs(self: @TContractState, p1: u8) -> u16;
                }

                #[starknet::interface]
                trait INominalTrait<TContractState> {
                    fn do_no_param(self: @TContractState) -> felt252;fn do_no_param_but_world(self: @TContractState) -> felt252;fn do_no_param_but_world_ref(ref self: TContractState) -> felt252;fn do_params_no_world(self: @TContractState, p1: felt252, p2: u8) -> felt252;fn do_params_and_world(self: @TContractState, p2: u8) -> felt252;fn do_params_and_world_ref(ref self: TContractState, p2: u8) -> felt252;fn do_with_self(self: @ContractState) -> felt252;fn do_with_ref_self(ref self: ContractState) -> felt252;
                }

                #[starknet::interface]
                trait IFaultyTrait<TContractState> {
                    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;fn do_with_self_and_world_inv(self: @TContractState, self: @ContractState) -> felt252;fn do_with_ref_self_and_world_inv(ref self: TContractState, ref self: ContractState
) -> felt252;fn do_with_several_world_dispatchers(self: @TContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252;fn do_with_world_not_named_world(self: @TContractState, another_world: @IWorldDispatcher) -> felt252;fn do_with_world_not_first(self: @TContractState, vec: Vec2, ref world: IWorldDispatcher) -> felt252;
                }

                #[starknet::contract]
                mod MyFaultyContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyFaultyContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-MyFaultyContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            3439743807865759203015037013733809315384408083697880336790137144257764256358
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            1862046669446530718410691364259438011386499031689246339557998041337203828246
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[abi(embed_v0)]
 impl TestFaultyImpl  of IFaultyTrait<ContractState>  {fn do_with_self_and_world(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self_and_world(            ref self: ContractState) -> felt252  {            'land'
}fn do_with_self_and_world_inv(self: @ContractState, self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_ref_self_and_world_inv(ref self: ContractState, ref self: ContractState
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_several_world_dispatchers(self: @ContractState, vec: Vec2, ref another_world: IWorldDispatcher
) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_world_not_named_world(self: @ContractState, another_world: @IWorldDispatcher) -> felt252  {            'land'
}fn do_with_world_not_first(self: @ContractState, vec: Vec2) -> felt252  {            'land'
}}
    #[generate_trait]
 impl InternalImplBad  of InternalUtils<ContractState>  {fn bad_func_using_generate(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}}
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
    trait InternalUtils{fn bad_func_using_generate(self: @ContractState) -> felt252;
}
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_self_and_world_inv(@contract_state, __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let mut __arg_self = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractState>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_ref_self_and_world_inv(ref contract_state, ref __arg_self);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<ContractState>::serialize(@__arg_self, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_several_world_dispatchers(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let mut __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_several_world_dispatchers(@contract_state, __arg_vec, ref __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
            core::serde::Serde::<IWorldDispatcher>::serialize(@__arg_another_world, ref arr);
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_named_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_another_world = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<@IWorldDispatcher>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_named_world(@contract_state, __arg_another_world);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestFaultyImpl__do_with_world_not_first(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_vec = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<Vec2>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestFaultyImpl::do_with_world_not_first(@contract_state, __arg_vec);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world as do_with_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world as do_with_ref_self_and_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_self_and_world_inv as do_with_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_ref_self_and_world_inv as do_with_ref_self_and_world_inv;
    pub use super::__wrapper__TestFaultyImpl__do_with_several_world_dispatchers as do_with_several_world_dispatchers;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_named_world as do_with_world_not_named_world;
    pub use super::__wrapper__TestFaultyImpl__do_with_world_not_first as do_with_world_not_first;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod MyNominalContract {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "MyNominalContract"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-MyNominalContract"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1172628497499445169993220559087829230676589931723677494032285307738203070578
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            2020162355936884646880401248118384176803981589166410970216209297939905305278
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                        #[derive(Drop)]
    struct Action {
        damage: u8
    }

    #[abi(embed_v0)]
 impl TestNominalImpl  of INominalTrait<ContractState>  {fn do_no_param(self: @ContractState) -> felt252  {            'land'
}fn do_no_param_but_world(self: @ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_no_param_but_world_ref(ref self: ContractState) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_no_world(self: @ContractState, p1: felt252, p2: u8) -> felt252  {            'land'
}fn do_params_and_world(self: @ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_params_and_world_ref(ref self: ContractState, p2: u8) -> felt252  {let world = self.world_dispatcher.read();            'land'
}fn do_with_self(self: @ContractState) -> felt252  {            'land'
}fn do_with_ref_self(ref self: ContractState) -> felt252  {            'land'
}}
    #[generate_trait]
    impl ImplInternalNoContractState of InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252 {
            let _w = world;
            42
        }
    }

                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
impl ActionDrop of core::traits::Drop::<Action>;
    trait InternalNoContractState {
        fn func1(world: IWorldDispatcher) -> felt252;
    }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_no_param_but_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_no_param_but_world_ref(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_no_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p1 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<felt252>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_no_world(@contract_state, __arg_p1, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world(@contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_params_and_world_ref(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_p2 = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_params_and_world_ref(ref contract_state, __arg_p2);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_self(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__TestNominalImpl__do_with_ref_self(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = TestNominalImpl::do_with_ref_self(ref contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__TestNominalImpl__do_no_param as do_no_param;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world as do_no_param_but_world;
    pub use super::__wrapper__TestNominalImpl__do_no_param_but_world_ref as do_no_param_but_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_params_no_world as do_params_no_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world as do_params_and_world;
    pub use super::__wrapper__TestNominalImpl__do_params_and_world_ref as do_params_and_world_ref;
    pub use super::__wrapper__TestNominalImpl__do_with_self as do_with_self;
    pub use super::__wrapper__TestNominalImpl__do_with_ref_self as do_with_ref_self;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            1673722391095039242574232979635399085098867563460816803458086922970092209409
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            799876284284394866912776672431802324689156187217902437477103298743064217162
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    #[starknet::interface]
            trait IDojoInit<ContractState> {
                fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
            }
            
            #[abi(embed_v0)]
            impl IDojoInitImpl of IDojoInit<ContractState> {
            fn dojo_init(self: @ContractState,         actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {let world = self.world_dispatcher.read();assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');        emit!(
            world,
            ContractInitialized {
                contract_address: actions_address, contract_class: actions_class, value
            }
        );
}
}
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                fn dojo_init(self: IDojoInitDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                fn dojo_init(self: IDojoInitLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                fn dojo_init(self: T, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                fn dojo_init(self: IDojoInitSafeLibraryDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                fn dojo_init(self: IDojoInitSafeDispatcher, actions_address: ContractAddress,         actions_class: ClassHash,         value: u8
) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<ContractAddress>::serialize(@actions_address, ref __calldata__);
        core::serde::Serde::<ClassHash>::serialize(@actions_class, ref __calldata__);
        core::serde::Serde::<u8
>::serialize(@value, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    let __arg_actions_address = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ContractAddress>::deserialize(ref data),
        'Failed to deserialize param #1'
    );
    let __arg_actions_class = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<ClassHash>::deserialize(ref data),
        'Failed to deserialize param #2'
    );
    let __arg_value = core::option::OptionTraitImpl::expect(
        core::serde::Serde::<u8>::deserialize(ref data),
        'Failed to deserialize param #3'
    );
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, __arg_actions_address, __arg_actions_class, __arg_value);
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }

                #[starknet::contract]
                mod no_init_test {
                    use dojo::world;
                    use dojo::world::IWorldDispatcher;
                    use dojo::world::IWorldDispatcherTrait;
                    use dojo::world::IWorldProvider;
                    use dojo::contract::IContract;

                    #[abi(embed_v0)]
                    impl ContractImpl of IContract<ContractState> {
                        fn contract_name(self: @ContractState) -> ByteArray {
                            "no_init_test"
                        }

                        fn namespace(self: @ContractState) -> ByteArray {
                            "test_package"
                        }

                        fn tag(self: @ContractState) -> ByteArray {
                            "test_package-no_init_test"
                        }

                        fn name_hash(self: @ContractState) -> felt252 {
                            2188407785440294979090510634648735461326850740369373015349552249835679156474
                        }

                        fn namespace_hash(self: @ContractState) -> felt252 {
                            3061092720893075933752785490401950953836105364709575990296000909161416686979
                        }

                        fn selector(self: @ContractState) -> felt252 {
                            3269287263937103915837903451864388946886384011514094502724942119672327217364
                        }
                    }

                    #[abi(embed_v0)]
                    impl WorldProviderImpl of IWorldProvider<ContractState> {
                        fn world(self: @ContractState) -> IWorldDispatcher {
                            self.world_dispatcher.read()
                        }
                    }

                    #[abi(embed_v0)]
                    impl UpgradableImpl = dojo::components::upgradeable::upgradeable::UpgradableImpl<ContractState>;

                    
                    #[starknet::interface]
                    trait IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState);
                    }

                    #[abi(embed_v0)]
                    impl IDojoInitImpl of IDojoInit<ContractState> {
                        fn dojo_init(self: @ContractState) {
                            assert(starknet::get_caller_address() == self.world().contract_address, 'Only world can init');
                        }
                    }
                
            #[event]
            #[derive(Drop, starknet::Event)]
            enum Event {
                UpgradeableEvent: dojo::components::upgradeable::upgradeable::Event,
            }
trait IDojoInitDispatcherTrait<T> {
                        fn dojo_init(self: T);
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitDispatcher> {
                        fn dojo_init(self: IDojoInitDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitLibraryDispatcherImpl of IDojoInitDispatcherTrait<IDojoInitLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitLibraryDispatcher) {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        ()
    }

}

trait IDojoInitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                        fn dojo_init(self: T) -> starknet::SyscallResult<()>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IDojoInitSafeLibraryDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeLibraryDispatcher> {
                        fn dojo_init(self: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IDojoInitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IDojoInitSafeDispatcherImpl of IDojoInitSafeDispatcherTrait<IDojoInitSafeDispatcher> {
                        fn dojo_init(self: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("dojo_init"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(())
    }

}
impl EventDrop of core::traits::Drop::<Event>;
impl EventIsEvent of starknet::Event<Event> {
    fn append_keys_and_data(
        self: @Event, ref keys: Array<felt252>, ref data: Array<felt252>
    ) {
        match self {
            Event::UpgradeableEvent(val) => {
                core::array::ArrayTrait::append(ref keys, selector!("UpgradeableEvent"));
                starknet::Event::append_keys_and_data(
                    val, ref keys, ref data
                );
            },
        }
    }
    fn deserialize(
        ref keys: Span<felt252>, ref data: Span<felt252>,
    ) -> Option<Event> {
        let __selector__ = *core::array::SpanTrait::pop_front(ref keys)?;
        if __selector__ == selector!("UpgradeableEvent") {
                let val = starknet::Event::deserialize(
                    ref keys, ref data
                )?;
                return Option::Some(Event::UpgradeableEvent(val));
        }
        Option::None
    }
}
impl EventUpgradeableEventIntoEvent of Into<dojo::components::upgradeable::upgradeable::Event, Event> {
    fn into(self: dojo::components::upgradeable::upgradeable::Event) -> Event {
        Event::UpgradeableEvent(self)
    }
}


pub struct Storage {
          pub world_dispatcher: IWorldDispatcher,
          pub upgradeable: dojo::components::upgradeable::upgradeable::Storage,
}

#[derive(Drop, Copy)]
pub struct ContractStorageBase {
    pub world_dispatcher: starknet::storage::StorageBase<IWorldDispatcher>,
    pub upgradeable: starknet::storage::StorageBase<dojo::components::upgradeable::upgradeable::Storage>,
}
#[derive(Drop, Copy)]
pub struct ContractStorageBaseMut {
    pub world_dispatcher: starknet::storage::StorageBase<starknet::storage::Mutable<IWorldDispatcher>>,
    pub upgradeable: starknet::storage::StorageBase<starknet::storage::Mutable<dojo::components::upgradeable::upgradeable::Storage>>,
}
impl StorageBaseImpl of starknet::storage::StorageBaseTrait<ContractState> {
    type BaseType = ContractStorageBase;
    type BaseMutType = ContractStorageBaseMut;
    fn storage_base(self: @ContractState) -> ContractStorageBase {
        ContractStorageBase {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
    fn storage_base_mut(ref self: ContractState) -> ContractStorageBaseMut {
        ContractStorageBaseMut {
           world_dispatcher: starknet::storage::StorageBase{ address: selector!("world_dispatcher") },
           upgradeable: starknet::storage::StorageBase{ address: selector!("upgradeable") },
        }
    }
}
pub struct ContractState {
        pub upgradeable: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>,
}

impl ContractStateDrop of Drop<ContractState> {}
 
impl ContractStateDeref of core::ops::SnapshotDeref<ContractState> {
    type Target = ContractStorageBase;
    fn snapshot_deref(self: @ContractState) -> ContractStorageBase {
        self.storage_base()
    }
}
impl ContractStateDerefMut of core::ops::DerefMut<ContractState> {
    type Target = ContractStorageBaseMut;
    fn deref_mut(ref self: ContractState) -> ContractStorageBaseMut {
        self.storage_base_mut()
    }
}
pub fn unsafe_new_contract_state() -> ContractState {
    ContractState {
                    upgradeable: dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>(),
    }
}

use starknet::storage::{
    StorageMapReadAccessTrait, StorageMapWriteAccessTrait, 
    StorableStoragePointerReadAccess, StorableStoragePointerWriteAccess
};
// TODO(Gil): This generates duplicate diagnostics because of the plugin system, squash the duplicates into one.
#[deprecated(
    feature: "deprecated_legacy_map",
    note: "Use `starknet::storage::Map` instead."
)]
use starknet::storage::Map as LegacyMap;

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__contract_name(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::contract_name(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__tag(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::tag(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<ByteArray>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__name_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::name_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__namespace_hash(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::namespace_hash(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__ContractImpl__selector(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = ContractImpl::selector(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<felt252>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__WorldProviderImpl__world(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    let res = WorldProviderImpl::world(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::serde::Serde::<IWorldDispatcher>::serialize(@res, ref arr);
    core::array::ArrayTrait::span(@arr)
}

impl ContractStateUpgradableImpl of
    dojo::components::upgradeable::upgradeable::UnsafeNewContractStateTraitForUpgradableImpl<ContractState> {
    fn unsafe_new_contract_state() -> ContractState {
        unsafe_new_contract_state()
    }
}
#[implicit_precedence(Pedersen, RangeCheck, Bitwise, core::ec::EcOp, Poseidon, SegmentArena, core::circuit::RangeCheck96, core::circuit::AddMod, core::circuit::MulMod, GasBuiltin, System)]
fn __wrapper__IDojoInitImpl__dojo_init(mut data: Span::<felt252>) -> Span::<felt252> {
    core::internal::require_implicit::<System>();
    core::internal::revoke_ap_tracking();
    core::option::OptionTraitImpl::expect(core::gas::withdraw_gas(), 'Out of gas');
    
    assert(core::array::SpanTrait::is_empty(data), 'Input too long for arguments');
    core::option::OptionTraitImpl::expect(
        core::gas::withdraw_gas_all(core::gas::get_builtin_costs()), 'Out of gas',
    );
    let mut contract_state = unsafe_new_contract_state();
    IDojoInitImpl::dojo_init(@contract_state, );
    let mut arr = ArrayTrait::new();
    // References.
    // Result.
    core::array::ArrayTrait::span(@arr)
}


pub mod __external {
    pub use super::__wrapper__ContractImpl__contract_name as contract_name;
    pub use super::__wrapper__ContractImpl__namespace as namespace;
    pub use super::__wrapper__ContractImpl__tag as tag;
    pub use super::__wrapper__ContractImpl__name_hash as name_hash;
    pub use super::__wrapper__ContractImpl__namespace_hash as namespace_hash;
    pub use super::__wrapper__ContractImpl__selector as selector;
    pub use super::__wrapper__WorldProviderImpl__world as world;
    pub use super::__wrapper__IDojoInitImpl__dojo_init as dojo_init;
}
pub mod __l1_handler {
}
pub mod __constructor {
}
    impl ContractStateEventEmitter of starknet::event::EventEmitter<
        ContractState, Event
    > {
        fn emit<S, impl IntoImp: core::traits::Into<S, Event>>(
            ref self: ContractState, event: S
        ) {
            let event: Event = core::traits::Into::into(event);
            let mut keys = Default::<core::array::Array>::default();
            let mut data = Default::<core::array::Array>::default();
            starknet::Event::append_keys_and_data(@event, ref keys, ref data);
            starknet::SyscallResultTrait::unwrap_syscall(
                starknet::syscalls::emit_event_syscall(
                    core::array::ArrayTrait::span(@keys),
                    core::array::ArrayTrait::span(@data),
                )
            )
        }
    }

impl HasComponentImpl_upgradeable of dojo::components::upgradeable::upgradeable::HasComponent<ContractState> {
    fn get_component(self: @ContractState) -> @dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
                 @dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_component_mut(ref self: ContractState) -> dojo::components::upgradeable::upgradeable::ComponentState<ContractState> {
        dojo::components::upgradeable::upgradeable::unsafe_new_component_state::<ContractState>()
    }
    fn get_contract(self: @dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> @ContractState {
        @unsafe_new_contract_state()
    }
    fn get_contract_mut(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>) -> ContractState {
        unsafe_new_contract_state()
    }
    fn emit<S, impl IntoImp: core::traits::Into<S, dojo::components::upgradeable::upgradeable::Event>>(ref self: dojo::components::upgradeable::upgradeable::ComponentState<ContractState>, event: S) {
        let event: dojo::components::upgradeable::upgradeable::Event = core::traits::Into::into(event);
        let mut contract = dojo::components::upgradeable::upgradeable::HasComponent::get_contract_mut(ref self);
        ContractStateEventEmitter::emit(ref contract, Event::UpgradeableEvent(event));
    }
}
impl IDojoInitDispatcherCopy of core::traits::Copy::<IDojoInitDispatcher>;
impl IDojoInitDispatcherDrop of core::traits::Drop::<IDojoInitDispatcher>;
impl IDojoInitDispatcherSerde of core::serde::Serde::<IDojoInitDispatcher> {
    fn serialize(self: @IDojoInitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitDispatcher> {
        core::option::Option::Some(IDojoInitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitDispatcher of starknet::Store::<IDojoInitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitDispatcher> {}
impl IDojoInitLibraryDispatcherCopy of core::traits::Copy::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherDrop of core::traits::Drop::<IDojoInitLibraryDispatcher>;
impl IDojoInitLibraryDispatcherSerde of core::serde::Serde::<IDojoInitLibraryDispatcher> {
    fn serialize(self: @IDojoInitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitLibraryDispatcher> {
        core::option::Option::Some(IDojoInitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitLibraryDispatcher of starknet::Store::<IDojoInitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitLibraryDispatcher> {}
impl IDojoInitSafeLibraryDispatcherCopy of core::traits::Copy::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherDrop of core::traits::Drop::<IDojoInitSafeLibraryDispatcher>;
impl IDojoInitSafeLibraryDispatcherSerde of core::serde::Serde::<IDojoInitSafeLibraryDispatcher> {
    fn serialize(self: @IDojoInitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeLibraryDispatcher> {
        core::option::Option::Some(IDojoInitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeLibraryDispatcher of starknet::Store::<IDojoInitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeLibraryDispatcher> {}
impl IDojoInitSafeDispatcherCopy of core::traits::Copy::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherDrop of core::traits::Drop::<IDojoInitSafeDispatcher>;
impl IDojoInitSafeDispatcherSerde of core::serde::Serde::<IDojoInitSafeDispatcher> {
    fn serialize(self: @IDojoInitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IDojoInitSafeDispatcher> {
        core::option::Option::Some(IDojoInitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIDojoInitSafeDispatcher of starknet::Store::<IDojoInitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IDojoInitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IDojoInitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IDojoInitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIDojoInitSafeDispatcher of starknet::storage_access::DeriveStorage::<IDojoInitSafeDispatcher> {}
impl ContractStorageBaseDrop of core::traits::Drop::<ContractStorageBase>;
impl ContractStorageBaseCopy of core::traits::Copy::<ContractStorageBase>;
impl ContractStorageBaseMutDrop of core::traits::Drop::<ContractStorageBaseMut>;
impl ContractStorageBaseMutCopy of core::traits::Copy::<ContractStorageBaseMut>;
            
                }
trait IEmptyTraitDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IEmptyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitDispatcher> {

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IEmptyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitLibraryDispatcherImpl of IEmptyTraitDispatcherTrait<IEmptyTraitLibraryDispatcher> {

}

trait IEmptyTraitSafeDispatcherTrait<T> {
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IEmptyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IEmptyTraitSafeLibraryDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeLibraryDispatcher> {

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IEmptyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IEmptyTraitSafeDispatcherImpl of IEmptyTraitSafeDispatcherTrait<IEmptyTraitSafeDispatcher> {

}
trait IFaultyTraitDispatcherTrait<T> {
                    fn do_with_attrs(self: T, p1: u8) -> u16;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitLibraryDispatcher, p1: u8) -> u16 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_with_attrs(self: T, p1: u8) -> starknet::SyscallResult<u16>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeLibraryDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
                    fn do_with_attrs(self: IFaultyTraitSafeDispatcher, p1: u8) -> starknet::SyscallResult<u16> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p1, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_attrs"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<u16>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
trait INominalTraitDispatcherTrait<T> {
                    fn do_no_param(self: T) -> felt252;
fn do_no_param_but_world(self: T) -> felt252;
fn do_no_param_but_world_ref(self: T) -> felt252;
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> felt252;
fn do_params_and_world(self: T, p2: u8) -> felt252;
fn do_params_and_world_ref(self: T, p2: u8) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct INominalTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitDispatcher> {
                    fn do_no_param(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct INominalTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitLibraryDispatcherImpl of INominalTraitDispatcherTrait<INominalTraitLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitLibraryDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_no_world(self: INominalTraitLibraryDispatcher, p1: felt252, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_params_and_world_ref(self: INominalTraitLibraryDispatcher, p2: u8) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

trait INominalTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
                    fn do_no_param(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_no_param_but_world_ref(self: T) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_no_world(self: T, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_params_and_world_ref(self: T, p2: u8) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct INominalTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl INominalTraitSafeLibraryDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeLibraryDispatcher> {
                    fn do_no_param(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeLibraryDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeLibraryDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct INominalTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl INominalTraitSafeDispatcherImpl of INominalTraitSafeDispatcherTrait<INominalTraitSafeDispatcher> {
                    fn do_no_param(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_no_param_but_world_ref(self: INominalTraitSafeDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_no_param_but_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_no_world(self: INominalTraitSafeDispatcher, p1: felt252, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<felt252>::serialize(@p1, ref __calldata__);
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_no_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_params_and_world_ref(self: INominalTraitSafeDispatcher, p2: u8) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<u8>::serialize(@p2, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_params_and_world_ref"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
trait IFaultyTraitDispatcherTrait<T> {
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> felt252;
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> felt252;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitLibraryDispatcherImpl of IFaultyTraitDispatcherTrait<IFaultyTraitLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitLibraryDispatcher, self: @ContractState) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitLibraryDispatcher, another_world: @IWorldDispatcher) -> felt252 {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = starknet::SyscallResultTrait::unwrap_syscall(__dispatcher_return_data__);
        core::option::OptionTrait::expect(
            core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
            'Returned data too short',
        )
    }

}

trait IFaultyTraitSafeDispatcherTrait<T> {
    #[unstable(feature: "safe_dispatcher")]
fn do_with_self_and_world_inv(self: T, self: @ContractState) -> starknet::SyscallResult<felt252>;
    #[unstable(feature: "safe_dispatcher")]
fn do_with_world_not_named_world(self: T, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252>;
}

#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}

impl IFaultyTraitSafeLibraryDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeLibraryDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeLibraryDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeLibraryDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::library_call_syscall(
            self.class_hash,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}


#[derive(Copy, Drop, starknet::Store, Serde)]
struct IFaultyTraitSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}

impl IFaultyTraitSafeDispatcherImpl of IFaultyTraitSafeDispatcherTrait<IFaultyTraitSafeDispatcher> {
fn do_with_self_and_world_inv(self: IFaultyTraitSafeDispatcher, self: @ContractState) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@ContractState>::serialize(@self, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_self_and_world_inv"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }
fn do_with_world_not_named_world(self: IFaultyTraitSafeDispatcher, another_world: @IWorldDispatcher) -> starknet::SyscallResult<felt252> {
        let mut __calldata__ = core::traits::Default::default();
        core::serde::Serde::<@IWorldDispatcher>::serialize(@another_world, ref __calldata__);

        let mut __dispatcher_return_data__ = starknet::syscalls::call_contract_syscall(
            self.contract_address,
            selector!("do_with_world_not_named_world"),
            core::array::ArrayTrait::span(@__calldata__),
        );
        let mut __dispatcher_return_data__ = __dispatcher_return_data__?;
        Result::Ok(
            core::option::OptionTrait::expect(
                core::serde::Serde::<felt252>::deserialize(ref __dispatcher_return_data__),
                'Returned data too short',
            )
        )
    }

}
impl IEmptyTraitDispatcherCopy of core::traits::Copy::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherDrop of core::traits::Drop::<IEmptyTraitDispatcher>;
impl IEmptyTraitDispatcherSerde of core::serde::Serde::<IEmptyTraitDispatcher> {
    fn serialize(self: @IEmptyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitDispatcher> {
        core::option::Option::Some(IEmptyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitDispatcher of starknet::Store::<IEmptyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIEmptyTraitDispatcher of starknet::storage_access::DeriveStorage::<IEmptyTraitDispatcher> {}
impl IEmptyTraitLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitLibraryDispatcher>;
impl IEmptyTraitLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitLibraryDispatcher of starknet::Store::<IEmptyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIEmptyTraitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IEmptyTraitLibraryDispatcher> {}
impl IEmptyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeLibraryDispatcher>;
impl IEmptyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IEmptyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeLibraryDispatcher of starknet::Store::<IEmptyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIEmptyTraitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IEmptyTraitSafeLibraryDispatcher> {}
impl IEmptyTraitSafeDispatcherCopy of core::traits::Copy::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherDrop of core::traits::Drop::<IEmptyTraitSafeDispatcher>;
impl IEmptyTraitSafeDispatcherSerde of core::serde::Serde::<IEmptyTraitSafeDispatcher> {
    fn serialize(self: @IEmptyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IEmptyTraitSafeDispatcher> {
        core::option::Option::Some(IEmptyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIEmptyTraitSafeDispatcher of starknet::Store::<IEmptyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IEmptyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IEmptyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IEmptyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIEmptyTraitSafeDispatcher of starknet::storage_access::DeriveStorage::<IEmptyTraitSafeDispatcher> {}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitDispatcher> {}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitLibraryDispatcher> {}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitSafeLibraryDispatcher> {}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitSafeDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitSafeDispatcher> {}
impl INominalTraitDispatcherCopy of core::traits::Copy::<INominalTraitDispatcher>;
impl INominalTraitDispatcherDrop of core::traits::Drop::<INominalTraitDispatcher>;
impl INominalTraitDispatcherSerde of core::serde::Serde::<INominalTraitDispatcher> {
    fn serialize(self: @INominalTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitDispatcher> {
        core::option::Option::Some(INominalTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitDispatcher of starknet::Store::<INominalTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageINominalTraitDispatcher of starknet::storage_access::DeriveStorage::<INominalTraitDispatcher> {}
impl INominalTraitLibraryDispatcherCopy of core::traits::Copy::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherDrop of core::traits::Drop::<INominalTraitLibraryDispatcher>;
impl INominalTraitLibraryDispatcherSerde of core::serde::Serde::<INominalTraitLibraryDispatcher> {
    fn serialize(self: @INominalTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitLibraryDispatcher> {
        core::option::Option::Some(INominalTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitLibraryDispatcher of starknet::Store::<INominalTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageINominalTraitLibraryDispatcher of starknet::storage_access::DeriveStorage::<INominalTraitLibraryDispatcher> {}
impl INominalTraitSafeLibraryDispatcherCopy of core::traits::Copy::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherDrop of core::traits::Drop::<INominalTraitSafeLibraryDispatcher>;
impl INominalTraitSafeLibraryDispatcherSerde of core::serde::Serde::<INominalTraitSafeLibraryDispatcher> {
    fn serialize(self: @INominalTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeLibraryDispatcher> {
        core::option::Option::Some(INominalTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeLibraryDispatcher of starknet::Store::<INominalTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageINominalTraitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<INominalTraitSafeLibraryDispatcher> {}
impl INominalTraitSafeDispatcherCopy of core::traits::Copy::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherDrop of core::traits::Drop::<INominalTraitSafeDispatcher>;
impl INominalTraitSafeDispatcherSerde of core::serde::Serde::<INominalTraitSafeDispatcher> {
    fn serialize(self: @INominalTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<INominalTraitSafeDispatcher> {
        core::option::Option::Some(INominalTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreINominalTraitSafeDispatcher of starknet::Store::<INominalTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<INominalTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            INominalTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: INominalTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageINominalTraitSafeDispatcher of starknet::storage_access::DeriveStorage::<INominalTraitSafeDispatcher> {}
impl IFaultyTraitDispatcherCopy of core::traits::Copy::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherDrop of core::traits::Drop::<IFaultyTraitDispatcher>;
impl IFaultyTraitDispatcherSerde of core::serde::Serde::<IFaultyTraitDispatcher> {
    fn serialize(self: @IFaultyTraitDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitDispatcher> {
        core::option::Option::Some(IFaultyTraitDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitDispatcher of starknet::Store::<IFaultyTraitDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitDispatcher> {}
impl IFaultyTraitLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitLibraryDispatcher>;
impl IFaultyTraitLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitLibraryDispatcher of starknet::Store::<IFaultyTraitLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitLibraryDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitLibraryDispatcher> {}
impl IFaultyTraitSafeLibraryDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeLibraryDispatcher>;
impl IFaultyTraitSafeLibraryDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeLibraryDispatcher> {
    fn serialize(self: @IFaultyTraitSafeLibraryDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.class_hash, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeLibraryDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeLibraryDispatcher {
            class_hash: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeLibraryDispatcher of starknet::Store::<IFaultyTraitSafeLibraryDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write(address_domain, base, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeLibraryDispatcher> {
        let class_hash = starknet::Store::<starknet::ClassHash>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeLibraryDispatcher {
                class_hash,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeLibraryDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ClassHash>::write_at_offset(address_domain, base, offset, value.class_hash)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ClassHash>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitSafeLibraryDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitSafeLibraryDispatcher> {}
impl IFaultyTraitSafeDispatcherCopy of core::traits::Copy::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherDrop of core::traits::Drop::<IFaultyTraitSafeDispatcher>;
impl IFaultyTraitSafeDispatcherSerde of core::serde::Serde::<IFaultyTraitSafeDispatcher> {
    fn serialize(self: @IFaultyTraitSafeDispatcher, ref output: core::array::Array<felt252>) {
        core::serde::Serde::serialize(self.contract_address, ref output)
    }
    fn deserialize(ref serialized: core::array::Span<felt252>) -> core::option::Option<IFaultyTraitSafeDispatcher> {
        core::option::Option::Some(IFaultyTraitSafeDispatcher {
            contract_address: core::serde::Serde::deserialize(ref serialized)?,
        })
    }
}
impl StoreIFaultyTraitSafeDispatcher of starknet::Store::<IFaultyTraitSafeDispatcher> {
    fn read(address_domain: u32, base: starknet::storage_access::StorageBaseAddress) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read(address_domain, base)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    fn write(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write(address_domain, base, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    fn read_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8) -> starknet::SyscallResult<IFaultyTraitSafeDispatcher> {
        let contract_address = starknet::Store::<starknet::ContractAddress>::read_at_offset(address_domain, base, offset)?;
        starknet::SyscallResult::Ok(
            IFaultyTraitSafeDispatcher {
                contract_address,
            }
        )
    }
    #[inline(always)]
    fn write_at_offset(address_domain: u32, base: starknet::storage_access::StorageBaseAddress, offset: u8, value: IFaultyTraitSafeDispatcher) -> starknet::SyscallResult<()> {
        starknet::Store::<starknet::ContractAddress>::write_at_offset(address_domain, base, offset, value.contract_address)?;
        starknet::SyscallResult::Ok(())
    }
    #[inline(always)]
    fn size() -> u8 {
        starknet::Store::<starknet::ContractAddress>::size()
    }
}
#[feature("derive-storage")]
impl DeriveStorageIFaultyTraitSafeDispatcher of starknet::storage_access::DeriveStorage::<IFaultyTraitSafeDispatcher> {}

//! > expected_diagnostics
error: Anything other than functions is not supported in a dojo::interface
 --> /tmp/plugin_test/src/lib.cairo:90:5
    const ONE: u8;
    ^************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^***********************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^*********************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:113:5
    fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252;
    ^***************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^****************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:128:9
        fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252 {
        ^************************************************************************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:132:9
        fn do_with_ref_self_and_world(
        ^****************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:138:9
        fn do_with_self_and_world_inv(world: @IWorldDispatcher, self: @ContractState) -> felt252 {
        ^****************************************************************************************^

error: You cannot use `self` and `world` parameters together.
 --> /tmp/plugin_test/src/lib.cairo:142:9
        fn do_with_ref_self_and_world_inv(
        ^********************************^

error: World parameter must be the first parameter.
 --> /tmp/plugin_test/src/lib.cairo:158:9
        fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252 {
        ^*****************************************************************************^

error: You cannot use `world` and `#[generate_trait]` together. Use `self` instead.
 --> /tmp/plugin_test/src/lib.cairo:165:9
        fn bad_func_using_generate(world: @IWorldDispatcher) -> felt252 {
        ^***************************************************************^

error: World parameter must be a snapshot if `ref` is not used.
 --> /tmp/plugin_test/src/lib.cairo:224:5
    fn dojo_init(
    ^***********^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:105:5
    fn do_with_self(self: @ContractState) -> felt252;
    ^**********************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:106:5
    fn do_with_ref_self(ref self: ContractState) -> felt252;
    ^*****************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:111:5
    fn do_with_self_and_world(self: @ContractState, world: @IWorldDispatcher) -> felt252;
    ^**********************************************************************************^

error: `starknet::interface` function first parameter must be a reference to the trait's generic parameter or a snapshot of it.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:112:5
    fn do_with_ref_self_and_world(ref self: ContractState, ref world: IWorldDispatcher) -> felt252;
    ^********************************************************************************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:114:5
    fn do_with_ref_self_and_world_inv(
    ^********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:117:5
    fn do_with_several_world_dispatchers(
    ^***********************************^

error: `starknet::interface` functions don't support `ref` parameters other than the first one.
 --> /tmp/plugin_test/src/lib.cairo:121:5
    fn do_with_world_not_first(vec: Vec2, ref world: IWorldDispatcher) -> felt252;
    ^***************************************************************************^

error: Generated trait must have generic args matching the impl's generic params.
 --> /tmp/plugin_test/src/lib.cairo:163:5
    #[generate_trait]
    ^***************^
